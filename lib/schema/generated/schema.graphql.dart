class Input$DateTimeFieldUpdateOperationsInput {
  factory Input$DateTimeFieldUpdateOperationsInput({String? $set}) =>
      Input$DateTimeFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$DateTimeFieldUpdateOperationsInput._(this._$data);

  factory Input$DateTimeFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$DateTimeFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<
          Input$DateTimeFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$DateTimeFieldUpdateOperationsInput(
    Input$DateTimeFieldUpdateOperationsInput instance,
    TRes Function(Input$DateTimeFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput;

  factory CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$DateTimeFieldUpdateOperationsInput _instance;

  final TRes Function(Input$DateTimeFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$DateTimeFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$DateTimeFilter {
  factory Input$DateTimeFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      Input$DateTimeFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$DateTimeFilter._(this._$data);

  factory Input$DateTimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$DateTimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFilter<Input$DateTimeFilter> get copyWith =>
      CopyWith$Input$DateTimeFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeFilter<TRes> {
  factory CopyWith$Input$DateTimeFilter(
    Input$DateTimeFilter instance,
    TRes Function(Input$DateTimeFilter) then,
  ) = _CopyWithImpl$Input$DateTimeFilter;

  factory CopyWith$Input$DateTimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  });
  CopyWith$Input$NestedDateTimeFilter<TRes> get not;
}

class _CopyWithImpl$Input$DateTimeFilter<TRes>
    implements CopyWith$Input$DateTimeFilter<TRes> {
  _CopyWithImpl$Input$DateTimeFilter(
    this._instance,
    this._then,
  );

  final Input$DateTimeFilter _instance;

  final TRes Function(Input$DateTimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$DateTimeFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined) 'not': (not as Input$NestedDateTimeFilter?),
      }));
  CopyWith$Input$NestedDateTimeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeFilter<TRes>
    implements CopyWith$Input$DateTimeFilter<TRes> {
  _CopyWithStubImpl$Input$DateTimeFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$DateTimeNullableFilter {
  factory Input$DateTimeNullableFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  }) =>
      Input$DateTimeNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$DateTimeNullableFilter._(this._$data);

  factory Input$DateTimeNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$DateTimeNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeNullableFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeNullableFilter<Input$DateTimeNullableFilter>
      get copyWith => CopyWith$Input$DateTimeNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeNullableFilter<TRes> {
  factory CopyWith$Input$DateTimeNullableFilter(
    Input$DateTimeNullableFilter instance,
    TRes Function(Input$DateTimeNullableFilter) then,
  ) = _CopyWithImpl$Input$DateTimeNullableFilter;

  factory CopyWith$Input$DateTimeNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeNullableFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  });
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$DateTimeNullableFilter<TRes>
    implements CopyWith$Input$DateTimeNullableFilter<TRes> {
  _CopyWithImpl$Input$DateTimeNullableFilter(
    this._instance,
    this._then,
  );

  final Input$DateTimeNullableFilter _instance;

  final TRes Function(Input$DateTimeNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$DateTimeNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedDateTimeNullableFilter?),
      }));
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeNullableFilter<TRes>
    implements CopyWith$Input$DateTimeNullableFilter<TRes> {
  _CopyWithStubImpl$Input$DateTimeNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeNullableFilter.stub(_res);
}

class Input$EnumConfirmationStatusNullableFilter {
  factory Input$EnumConfirmationStatusNullableFilter({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusNullableFilter? not,
  }) =>
      Input$EnumConfirmationStatusNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$EnumConfirmationStatusNullableFilter._(this._$data);

  factory Input$EnumConfirmationStatusNullableFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConfirmationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConfirmationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumConfirmationStatusNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$EnumConfirmationStatusNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ConfirmationStatus? get equals =>
      (_$data['equals'] as Enum$ConfirmationStatus?);
  List<Enum$ConfirmationStatus>? get $in =>
      (_$data['in'] as List<Enum$ConfirmationStatus>?);
  List<Enum$ConfirmationStatus>? get notIn =>
      (_$data['notIn'] as List<Enum$ConfirmationStatus>?);
  Input$NestedEnumConfirmationStatusNullableFilter? get not =>
      (_$data['not'] as Input$NestedEnumConfirmationStatusNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$ConfirmationStatus(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$ConfirmationStatus(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$ConfirmationStatus(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EnumConfirmationStatusNullableFilter<
          Input$EnumConfirmationStatusNullableFilter>
      get copyWith => CopyWith$Input$EnumConfirmationStatusNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumConfirmationStatusNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes> {
  factory CopyWith$Input$EnumConfirmationStatusNullableFilter(
    Input$EnumConfirmationStatusNullableFilter instance,
    TRes Function(Input$EnumConfirmationStatusNullableFilter) then,
  ) = _CopyWithImpl$Input$EnumConfirmationStatusNullableFilter;

  factory CopyWith$Input$EnumConfirmationStatusNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumConfirmationStatusNullableFilter;

  TRes call({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusNullableFilter? not,
  });
  CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$EnumConfirmationStatusNullableFilter<TRes>
    implements CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes> {
  _CopyWithImpl$Input$EnumConfirmationStatusNullableFilter(
    this._instance,
    this._then,
  );

  final Input$EnumConfirmationStatusNullableFilter _instance;

  final TRes Function(Input$EnumConfirmationStatusNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$EnumConfirmationStatusNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined)
          'equals': (equals as Enum$ConfirmationStatus?),
        if ($in != _undefined) 'in': ($in as List<Enum$ConfirmationStatus>?),
        if (notIn != _undefined)
          'notIn': (notIn as List<Enum$ConfirmationStatus>?),
        if (not != _undefined)
          'not': (not as Input$NestedEnumConfirmationStatusNullableFilter?),
      }));
  CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumConfirmationStatusNullableFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedEnumConfirmationStatusNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$EnumConfirmationStatusNullableFilter<TRes>
    implements CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes> {
  _CopyWithStubImpl$Input$EnumConfirmationStatusNullableFilter(this._res);

  TRes _res;

  call({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> get not =>
      CopyWith$Input$NestedEnumConfirmationStatusNullableFilter.stub(_res);
}

class Input$EnumQueueStatusFieldUpdateOperationsInput {
  factory Input$EnumQueueStatusFieldUpdateOperationsInput(
          {Enum$QueueStatus? $set}) =>
      Input$EnumQueueStatusFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$EnumQueueStatusFieldUpdateOperationsInput._(this._$data);

  factory Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] =
          l$$set == null ? null : fromJson$Enum$QueueStatus((l$$set as String));
    }
    return Input$EnumQueueStatusFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$QueueStatus? get $set => (_$data['set'] as Enum$QueueStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] =
          l$$set == null ? null : toJson$Enum$QueueStatus(l$$set);
    }
    return result$data;
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<
          Input$EnumQueueStatusFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumQueueStatusFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
    Input$EnumQueueStatusFieldUpdateOperationsInput instance,
    TRes Function(Input$EnumQueueStatusFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$EnumQueueStatusFieldUpdateOperationsInput;

  factory CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EnumQueueStatusFieldUpdateOperationsInput;

  TRes call({Enum$QueueStatus? $set});
}

class _CopyWithImpl$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$EnumQueueStatusFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$EnumQueueStatusFieldUpdateOperationsInput _instance;

  final TRes Function(Input$EnumQueueStatusFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$EnumQueueStatusFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as Enum$QueueStatus?),
      }));
}

class _CopyWithStubImpl$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$EnumQueueStatusFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({Enum$QueueStatus? $set}) => _res;
}

class Input$EnumQueueStatusFilter {
  factory Input$EnumQueueStatusFilter({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  }) =>
      Input$EnumQueueStatusFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$EnumQueueStatusFilter._(this._$data);

  factory Input$EnumQueueStatusFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$QueueStatus((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$QueueStatus((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$QueueStatus((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumQueueStatusFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$EnumQueueStatusFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$QueueStatus? get equals => (_$data['equals'] as Enum$QueueStatus?);
  List<Enum$QueueStatus>? get $in => (_$data['in'] as List<Enum$QueueStatus>?);
  List<Enum$QueueStatus>? get notIn =>
      (_$data['notIn'] as List<Enum$QueueStatus>?);
  Input$NestedEnumQueueStatusFilter? get not =>
      (_$data['not'] as Input$NestedEnumQueueStatusFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$QueueStatus(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$QueueStatus(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$QueueStatus(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EnumQueueStatusFilter<Input$EnumQueueStatusFilter>
      get copyWith => CopyWith$Input$EnumQueueStatusFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumQueueStatusFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumQueueStatusFilter<TRes> {
  factory CopyWith$Input$EnumQueueStatusFilter(
    Input$EnumQueueStatusFilter instance,
    TRes Function(Input$EnumQueueStatusFilter) then,
  ) = _CopyWithImpl$Input$EnumQueueStatusFilter;

  factory CopyWith$Input$EnumQueueStatusFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumQueueStatusFilter;

  TRes call({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  });
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not;
}

class _CopyWithImpl$Input$EnumQueueStatusFilter<TRes>
    implements CopyWith$Input$EnumQueueStatusFilter<TRes> {
  _CopyWithImpl$Input$EnumQueueStatusFilter(
    this._instance,
    this._then,
  );

  final Input$EnumQueueStatusFilter _instance;

  final TRes Function(Input$EnumQueueStatusFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$EnumQueueStatusFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as Enum$QueueStatus?),
        if ($in != _undefined) 'in': ($in as List<Enum$QueueStatus>?),
        if (notIn != _undefined) 'notIn': (notIn as List<Enum$QueueStatus>?),
        if (not != _undefined)
          'not': (not as Input$NestedEnumQueueStatusFilter?),
      }));
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$NestedEnumQueueStatusFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$EnumQueueStatusFilter<TRes>
    implements CopyWith$Input$EnumQueueStatusFilter<TRes> {
  _CopyWithStubImpl$Input$EnumQueueStatusFilter(this._res);

  TRes _res;

  call({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not =>
      CopyWith$Input$NestedEnumQueueStatusFilter.stub(_res);
}

class Input$EnumUserRoleFieldUpdateOperationsInput {
  factory Input$EnumUserRoleFieldUpdateOperationsInput({Enum$UserRole? $set}) =>
      Input$EnumUserRoleFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$EnumUserRoleFieldUpdateOperationsInput._(this._$data);

  factory Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] =
          l$$set == null ? null : fromJson$Enum$UserRole((l$$set as String));
    }
    return Input$EnumUserRoleFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserRole? get $set => (_$data['set'] as Enum$UserRole?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set == null ? null : toJson$Enum$UserRole(l$$set);
    }
    return result$data;
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<
          Input$EnumUserRoleFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumUserRoleFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
    Input$EnumUserRoleFieldUpdateOperationsInput instance,
    TRes Function(Input$EnumUserRoleFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$EnumUserRoleFieldUpdateOperationsInput;

  factory CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumUserRoleFieldUpdateOperationsInput;

  TRes call({Enum$UserRole? $set});
}

class _CopyWithImpl$Input$EnumUserRoleFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$EnumUserRoleFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$EnumUserRoleFieldUpdateOperationsInput _instance;

  final TRes Function(Input$EnumUserRoleFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$EnumUserRoleFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as Enum$UserRole?),
      }));
}

class _CopyWithStubImpl$Input$EnumUserRoleFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$EnumUserRoleFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({Enum$UserRole? $set}) => _res;
}

class Input$EnumUserRoleFilter {
  factory Input$EnumUserRoleFilter({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  }) =>
      Input$EnumUserRoleFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$EnumUserRoleFilter._(this._$data);

  factory Input$EnumUserRoleFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$UserRole((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumUserRoleFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$EnumUserRoleFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserRole? get equals => (_$data['equals'] as Enum$UserRole?);
  List<Enum$UserRole>? get $in => (_$data['in'] as List<Enum$UserRole>?);
  List<Enum$UserRole>? get notIn => (_$data['notIn'] as List<Enum$UserRole>?);
  Input$NestedEnumUserRoleFilter? get not =>
      (_$data['not'] as Input$NestedEnumUserRoleFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$UserRole(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EnumUserRoleFilter<Input$EnumUserRoleFilter> get copyWith =>
      CopyWith$Input$EnumUserRoleFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumUserRoleFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumUserRoleFilter<TRes> {
  factory CopyWith$Input$EnumUserRoleFilter(
    Input$EnumUserRoleFilter instance,
    TRes Function(Input$EnumUserRoleFilter) then,
  ) = _CopyWithImpl$Input$EnumUserRoleFilter;

  factory CopyWith$Input$EnumUserRoleFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumUserRoleFilter;

  TRes call({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  });
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not;
}

class _CopyWithImpl$Input$EnumUserRoleFilter<TRes>
    implements CopyWith$Input$EnumUserRoleFilter<TRes> {
  _CopyWithImpl$Input$EnumUserRoleFilter(
    this._instance,
    this._then,
  );

  final Input$EnumUserRoleFilter _instance;

  final TRes Function(Input$EnumUserRoleFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$EnumUserRoleFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as Enum$UserRole?),
        if ($in != _undefined) 'in': ($in as List<Enum$UserRole>?),
        if (notIn != _undefined) 'notIn': (notIn as List<Enum$UserRole>?),
        if (not != _undefined) 'not': (not as Input$NestedEnumUserRoleFilter?),
      }));
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$NestedEnumUserRoleFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$EnumUserRoleFilter<TRes>
    implements CopyWith$Input$EnumUserRoleFilter<TRes> {
  _CopyWithStubImpl$Input$EnumUserRoleFilter(this._res);

  TRes _res;

  call({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not =>
      CopyWith$Input$NestedEnumUserRoleFilter.stub(_res);
}

class Input$FloatNullableFilter {
  factory Input$FloatNullableFilter({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatNullableFilter? not,
  }) =>
      Input$FloatNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$FloatNullableFilter._(this._$data);

  factory Input$FloatNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedFloatNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$FloatNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get equals => (_$data['equals'] as double?);
  List<double>? get $in => (_$data['in'] as List<double>?);
  List<double>? get notIn => (_$data['notIn'] as List<double>?);
  double? get lt => (_$data['lt'] as double?);
  double? get lte => (_$data['lte'] as double?);
  double? get gt => (_$data['gt'] as double?);
  double? get gte => (_$data['gte'] as double?);
  Input$NestedFloatNullableFilter? get not =>
      (_$data['not'] as Input$NestedFloatNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FloatNullableFilter<Input$FloatNullableFilter> get copyWith =>
      CopyWith$Input$FloatNullableFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FloatNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$FloatNullableFilter<TRes> {
  factory CopyWith$Input$FloatNullableFilter(
    Input$FloatNullableFilter instance,
    TRes Function(Input$FloatNullableFilter) then,
  ) = _CopyWithImpl$Input$FloatNullableFilter;

  factory CopyWith$Input$FloatNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FloatNullableFilter;

  TRes call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatNullableFilter? not,
  });
  CopyWith$Input$NestedFloatNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$FloatNullableFilter<TRes>
    implements CopyWith$Input$FloatNullableFilter<TRes> {
  _CopyWithImpl$Input$FloatNullableFilter(
    this._instance,
    this._then,
  );

  final Input$FloatNullableFilter _instance;

  final TRes Function(Input$FloatNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$FloatNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if (notIn != _undefined) 'notIn': (notIn as List<double>?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if (not != _undefined) 'not': (not as Input$NestedFloatNullableFilter?),
      }));
  CopyWith$Input$NestedFloatNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedFloatNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$FloatNullableFilter<TRes>
    implements CopyWith$Input$FloatNullableFilter<TRes> {
  _CopyWithStubImpl$Input$FloatNullableFilter(this._res);

  TRes _res;

  call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedFloatNullableFilter<TRes> get not =>
      CopyWith$Input$NestedFloatNullableFilter.stub(_res);
}

class Input$GuestAvgAggregateInput {
  factory Input$GuestAvgAggregateInput({bool? whatsapp}) =>
      Input$GuestAvgAggregateInput._({
        if (whatsapp != null) r'whatsapp': whatsapp,
      });

  Input$GuestAvgAggregateInput._(this._$data);

  factory Input$GuestAvgAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as bool?);
    }
    return Input$GuestAvgAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get whatsapp => (_$data['whatsapp'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    return result$data;
  }

  CopyWith$Input$GuestAvgAggregateInput<Input$GuestAvgAggregateInput>
      get copyWith => CopyWith$Input$GuestAvgAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestAvgAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$whatsapp = whatsapp;
    return Object.hashAll(
        [_$data.containsKey('whatsapp') ? l$whatsapp : const {}]);
  }
}

abstract class CopyWith$Input$GuestAvgAggregateInput<TRes> {
  factory CopyWith$Input$GuestAvgAggregateInput(
    Input$GuestAvgAggregateInput instance,
    TRes Function(Input$GuestAvgAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestAvgAggregateInput;

  factory CopyWith$Input$GuestAvgAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestAvgAggregateInput;

  TRes call({bool? whatsapp});
}

class _CopyWithImpl$Input$GuestAvgAggregateInput<TRes>
    implements CopyWith$Input$GuestAvgAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestAvgAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestAvgAggregateInput _instance;

  final TRes Function(Input$GuestAvgAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? whatsapp = _undefined}) =>
      _then(Input$GuestAvgAggregateInput._({
        ..._instance._$data,
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestAvgAggregateInput<TRes>
    implements CopyWith$Input$GuestAvgAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestAvgAggregateInput(this._res);

  TRes _res;

  call({bool? whatsapp}) => _res;
}

class Input$GuestCountAggregateInput {
  factory Input$GuestCountAggregateInput({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
    bool? $_all,
  }) =>
      Input$GuestCountAggregateInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (groupMemberOfId != null) r'groupMemberOfId': groupMemberOfId,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if ($_all != null) r'_all': $_all,
      });

  Input$GuestCountAggregateInput._(this._$data);

  factory Input$GuestCountAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as bool?);
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = (l$invitationName as bool?);
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as bool?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as bool?);
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as bool?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as bool?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as bool?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as bool?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as bool?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = data['groupMemberOfId'];
      result$data['groupMemberOfId'] = (l$groupMemberOfId as bool?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = (l$confirmationStatus as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$GuestCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get source => (_$data['source'] as bool?);
  bool? get invitationName => (_$data['invitationName'] as bool?);
  bool? get contactList => (_$data['contactList'] as bool?);
  bool? get whatsapp => (_$data['whatsapp'] as bool?);
  bool? get category => (_$data['category'] as bool?);
  bool? get $class => (_$data['class'] as bool?);
  bool? get seat => (_$data['seat'] as bool?);
  bool? get studio => (_$data['studio'] as bool?);
  bool? get showTime => (_$data['showTime'] as bool?);
  bool? get rejectionReason => (_$data['rejectionReason'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get groupMemberOfId => (_$data['groupMemberOfId'] as bool?);
  bool? get confirmationStatus => (_$data['confirmationStatus'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName;
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = groupMemberOfId;
      result$data['groupMemberOfId'] = l$groupMemberOfId;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$GuestCountAggregateInput<Input$GuestCountAggregateInput>
      get copyWith => CopyWith$Input$GuestCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$groupMemberOfId = groupMemberOfId;
    final lOther$groupMemberOfId = other.groupMemberOfId;
    if (_$data.containsKey('groupMemberOfId') !=
        other._$data.containsKey('groupMemberOfId')) {
      return false;
    }
    if (l$groupMemberOfId != lOther$groupMemberOfId) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$groupMemberOfId = groupMemberOfId;
    final l$confirmationStatus = confirmationStatus;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('groupMemberOfId') ? l$groupMemberOfId : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCountAggregateInput<TRes> {
  factory CopyWith$Input$GuestCountAggregateInput(
    Input$GuestCountAggregateInput instance,
    TRes Function(Input$GuestCountAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestCountAggregateInput;

  factory CopyWith$Input$GuestCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCountAggregateInput;

  TRes call({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$GuestCountAggregateInput<TRes>
    implements CopyWith$Input$GuestCountAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestCountAggregateInput _instance;

  final TRes Function(Input$GuestCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? groupMemberOfId = _undefined,
    Object? confirmationStatus = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$GuestCountAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (source != _undefined) 'source': (source as bool?),
        if (invitationName != _undefined)
          'invitationName': (invitationName as bool?),
        if (contactList != _undefined) 'contactList': (contactList as bool?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as bool?),
        if (category != _undefined) 'category': (category as bool?),
        if ($class != _undefined) 'class': ($class as bool?),
        if (seat != _undefined) 'seat': (seat as bool?),
        if (studio != _undefined) 'studio': (studio as bool?),
        if (showTime != _undefined) 'showTime': (showTime as bool?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (groupMemberOfId != _undefined)
          'groupMemberOfId': (groupMemberOfId as bool?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestCountAggregateInput<TRes>
    implements CopyWith$Input$GuestCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
    bool? $_all,
  }) =>
      _res;
}

class Input$GuestCreateInput {
  factory Input$GuestCreateInput({
    String? id,
    String? source,
    required String invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      Input$GuestCreateInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestCreateInput._(this._$data);

  factory Input$GuestCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    final l$invitationName = data['invitationName'];
    result$data['invitationName'] = (l$invitationName as String);
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as num?)?.toDouble();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as String?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestCreateNestedOneWithoutGroupMembersInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestCreateNestedManyWithoutGroupMemberOfInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeCreateNestedOneWithoutGuestInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageCreateNestedOneWithoutGuestInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get source => (_$data['source'] as String?);
  String get invitationName => (_$data['invitationName'] as String);
  String? get contactList => (_$data['contactList'] as String?);
  double? get whatsapp => (_$data['whatsapp'] as double?);
  String? get category => (_$data['category'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get studio => (_$data['studio'] as String?);
  String? get showTime => (_$data['showTime'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$GuestCreateNestedOneWithoutGroupMembersInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestCreateNestedOneWithoutGroupMembersInput?);
  Input$GuestCreateNestedManyWithoutGroupMemberOfInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?);
  Input$QrCodeCreateNestedOneWithoutGuestInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeCreateNestedOneWithoutGuestInput?);
  Input$InvitationImageCreateNestedOneWithoutGuestInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageCreateNestedOneWithoutGuestInput?);
  Input$WhatsappStatusCreateNestedManyWithoutGuestInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    final l$invitationName = invitationName;
    result$data['invitationName'] = l$invitationName;
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateInput<Input$GuestCreateInput> get copyWith =>
      CopyWith$Input$GuestCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      l$invitationName,
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateInput<TRes> {
  factory CopyWith$Input$GuestCreateInput(
    Input$GuestCreateInput instance,
    TRes Function(Input$GuestCreateInput) then,
  ) = _CopyWithImpl$Input$GuestCreateInput;

  factory CopyWith$Input$GuestCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateInput;

  TRes call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf;
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers;
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestCreateInput<TRes>
    implements CopyWith$Input$GuestCreateInput<TRes> {
  _CopyWithImpl$Input$GuestCreateInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateInput _instance;

  final TRes Function(Input$GuestCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestCreateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (source != _undefined) 'source': (source as String?),
        if (invitationName != _undefined && invitationName != null)
          'invitationName': (invitationName as String),
        if (contactList != _undefined) 'contactList': (contactList as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as double?),
        if (category != _undefined) 'category': (category as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (studio != _undefined) 'studio': (studio as String?),
        if (showTime != _undefined) 'showTime': (showTime as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestCreateNestedOneWithoutGroupMembersInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeCreateNestedOneWithoutGuestInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageCreateNestedOneWithoutGuestInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateInput<TRes>
    implements CopyWith$Input$GuestCreateInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
              _res);
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
              _res);
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
              _res);
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateManyGroupMemberOfInput {
  factory Input$GuestCreateManyGroupMemberOfInput({
    String? id,
    String? source,
    required String invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
  }) =>
      Input$GuestCreateManyGroupMemberOfInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestCreateManyGroupMemberOfInput._(this._$data);

  factory Input$GuestCreateManyGroupMemberOfInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    final l$invitationName = data['invitationName'];
    result$data['invitationName'] = (l$invitationName as String);
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as num?)?.toDouble();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as String?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    return Input$GuestCreateManyGroupMemberOfInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get source => (_$data['source'] as String?);
  String get invitationName => (_$data['invitationName'] as String);
  String? get contactList => (_$data['contactList'] as String?);
  double? get whatsapp => (_$data['whatsapp'] as double?);
  String? get category => (_$data['category'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get studio => (_$data['studio'] as String?);
  String? get showTime => (_$data['showTime'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    final l$invitationName = invitationName;
    result$data['invitationName'] = l$invitationName;
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateManyGroupMemberOfInput<
          Input$GuestCreateManyGroupMemberOfInput>
      get copyWith => CopyWith$Input$GuestCreateManyGroupMemberOfInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateManyGroupMemberOfInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      l$invitationName,
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateManyGroupMemberOfInput<TRes> {
  factory CopyWith$Input$GuestCreateManyGroupMemberOfInput(
    Input$GuestCreateManyGroupMemberOfInput instance,
    TRes Function(Input$GuestCreateManyGroupMemberOfInput) then,
  ) = _CopyWithImpl$Input$GuestCreateManyGroupMemberOfInput;

  factory CopyWith$Input$GuestCreateManyGroupMemberOfInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateManyGroupMemberOfInput;

  TRes call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
  });
}

class _CopyWithImpl$Input$GuestCreateManyGroupMemberOfInput<TRes>
    implements CopyWith$Input$GuestCreateManyGroupMemberOfInput<TRes> {
  _CopyWithImpl$Input$GuestCreateManyGroupMemberOfInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateManyGroupMemberOfInput _instance;

  final TRes Function(Input$GuestCreateManyGroupMemberOfInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestCreateManyGroupMemberOfInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (source != _undefined) 'source': (source as String?),
        if (invitationName != _undefined && invitationName != null)
          'invitationName': (invitationName as String),
        if (contactList != _undefined) 'contactList': (contactList as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as double?),
        if (category != _undefined) 'category': (category as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (studio != _undefined) 'studio': (studio as String?),
        if (showTime != _undefined) 'showTime': (showTime as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
      }));
}

class _CopyWithStubImpl$Input$GuestCreateManyGroupMemberOfInput<TRes>
    implements CopyWith$Input$GuestCreateManyGroupMemberOfInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateManyGroupMemberOfInput(this._res);

  TRes _res;

  call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
  }) =>
      _res;
}

class Input$GuestCreateManyGroupMemberOfInputEnvelope {
  factory Input$GuestCreateManyGroupMemberOfInputEnvelope({
    required List<Input$GuestCreateManyGroupMemberOfInput> data,
    bool? skipDuplicates,
  }) =>
      Input$GuestCreateManyGroupMemberOfInputEnvelope._({
        r'data': data,
        if (skipDuplicates != null) r'skipDuplicates': skipDuplicates,
      });

  Input$GuestCreateManyGroupMemberOfInputEnvelope._(this._$data);

  factory Input$GuestCreateManyGroupMemberOfInputEnvelope.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => Input$GuestCreateManyGroupMemberOfInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = data['skipDuplicates'];
      result$data['skipDuplicates'] = (l$skipDuplicates as bool?);
    }
    return Input$GuestCreateManyGroupMemberOfInputEnvelope._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$GuestCreateManyGroupMemberOfInput> get data =>
      (_$data['data'] as List<Input$GuestCreateManyGroupMemberOfInput>);
  bool? get skipDuplicates => (_$data['skipDuplicates'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = skipDuplicates;
      result$data['skipDuplicates'] = l$skipDuplicates;
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<
          Input$GuestCreateManyGroupMemberOfInputEnvelope>
      get copyWith => CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateManyGroupMemberOfInputEnvelope) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (_$data.containsKey('skipDuplicates') !=
        other._$data.containsKey('skipDuplicates')) {
      return false;
    }
    if (l$skipDuplicates != lOther$skipDuplicates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('skipDuplicates') ? l$skipDuplicates : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes> {
  factory CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope(
    Input$GuestCreateManyGroupMemberOfInputEnvelope instance,
    TRes Function(Input$GuestCreateManyGroupMemberOfInputEnvelope) then,
  ) = _CopyWithImpl$Input$GuestCreateManyGroupMemberOfInputEnvelope;

  factory CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateManyGroupMemberOfInputEnvelope;

  TRes call({
    List<Input$GuestCreateManyGroupMemberOfInput>? data,
    bool? skipDuplicates,
  });
  TRes data(
      Iterable<Input$GuestCreateManyGroupMemberOfInput> Function(
              Iterable<
                  CopyWith$Input$GuestCreateManyGroupMemberOfInput<
                      Input$GuestCreateManyGroupMemberOfInput>>)
          _fn);
}

class _CopyWithImpl$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes>
    implements CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes> {
  _CopyWithImpl$Input$GuestCreateManyGroupMemberOfInputEnvelope(
    this._instance,
    this._then,
  );

  final Input$GuestCreateManyGroupMemberOfInputEnvelope _instance;

  final TRes Function(Input$GuestCreateManyGroupMemberOfInputEnvelope) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? skipDuplicates = _undefined,
  }) =>
      _then(Input$GuestCreateManyGroupMemberOfInputEnvelope._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<Input$GuestCreateManyGroupMemberOfInput>),
        if (skipDuplicates != _undefined)
          'skipDuplicates': (skipDuplicates as bool?),
      }));
  TRes data(
          Iterable<Input$GuestCreateManyGroupMemberOfInput> Function(
                  Iterable<
                      CopyWith$Input$GuestCreateManyGroupMemberOfInput<
                          Input$GuestCreateManyGroupMemberOfInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$Input$GuestCreateManyGroupMemberOfInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes>
    implements CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes> {
  _CopyWithStubImpl$Input$GuestCreateManyGroupMemberOfInputEnvelope(this._res);

  TRes _res;

  call({
    List<Input$GuestCreateManyGroupMemberOfInput>? data,
    bool? skipDuplicates,
  }) =>
      _res;
  data(_fn) => _res;
}

class Input$GuestCreateManyInput {
  factory Input$GuestCreateManyInput({
    String? id,
    String? source,
    required String invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    String? groupMemberOfId,
    Enum$ConfirmationStatus? confirmationStatus,
  }) =>
      Input$GuestCreateManyInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (groupMemberOfId != null) r'groupMemberOfId': groupMemberOfId,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestCreateManyInput._(this._$data);

  factory Input$GuestCreateManyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    final l$invitationName = data['invitationName'];
    result$data['invitationName'] = (l$invitationName as String);
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as num?)?.toDouble();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as String?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    if (data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = data['groupMemberOfId'];
      result$data['groupMemberOfId'] = (l$groupMemberOfId as String?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    return Input$GuestCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get source => (_$data['source'] as String?);
  String get invitationName => (_$data['invitationName'] as String);
  String? get contactList => (_$data['contactList'] as String?);
  double? get whatsapp => (_$data['whatsapp'] as double?);
  String? get category => (_$data['category'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get studio => (_$data['studio'] as String?);
  String? get showTime => (_$data['showTime'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  String? get groupMemberOfId => (_$data['groupMemberOfId'] as String?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    final l$invitationName = invitationName;
    result$data['invitationName'] = l$invitationName;
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = groupMemberOfId;
      result$data['groupMemberOfId'] = l$groupMemberOfId;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateManyInput<Input$GuestCreateManyInput>
      get copyWith => CopyWith$Input$GuestCreateManyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$groupMemberOfId = groupMemberOfId;
    final lOther$groupMemberOfId = other.groupMemberOfId;
    if (_$data.containsKey('groupMemberOfId') !=
        other._$data.containsKey('groupMemberOfId')) {
      return false;
    }
    if (l$groupMemberOfId != lOther$groupMemberOfId) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$groupMemberOfId = groupMemberOfId;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      l$invitationName,
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('groupMemberOfId') ? l$groupMemberOfId : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateManyInput<TRes> {
  factory CopyWith$Input$GuestCreateManyInput(
    Input$GuestCreateManyInput instance,
    TRes Function(Input$GuestCreateManyInput) then,
  ) = _CopyWithImpl$Input$GuestCreateManyInput;

  factory CopyWith$Input$GuestCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateManyInput;

  TRes call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    String? groupMemberOfId,
    Enum$ConfirmationStatus? confirmationStatus,
  });
}

class _CopyWithImpl$Input$GuestCreateManyInput<TRes>
    implements CopyWith$Input$GuestCreateManyInput<TRes> {
  _CopyWithImpl$Input$GuestCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateManyInput _instance;

  final TRes Function(Input$GuestCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? groupMemberOfId = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestCreateManyInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (source != _undefined) 'source': (source as String?),
        if (invitationName != _undefined && invitationName != null)
          'invitationName': (invitationName as String),
        if (contactList != _undefined) 'contactList': (contactList as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as double?),
        if (category != _undefined) 'category': (category as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (studio != _undefined) 'studio': (studio as String?),
        if (showTime != _undefined) 'showTime': (showTime as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (groupMemberOfId != _undefined)
          'groupMemberOfId': (groupMemberOfId as String?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
      }));
}

class _CopyWithStubImpl$Input$GuestCreateManyInput<TRes>
    implements CopyWith$Input$GuestCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateManyInput(this._res);

  TRes _res;

  call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    String? groupMemberOfId,
    Enum$ConfirmationStatus? confirmationStatus,
  }) =>
      _res;
}

class Input$GuestCreateNestedManyWithoutGroupMemberOfInput {
  factory Input$GuestCreateNestedManyWithoutGroupMemberOfInput({
    List<Input$GuestCreateWithoutGroupMemberOfInput>? create,
    List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? connectOrCreate,
    Input$GuestCreateManyGroupMemberOfInputEnvelope? createMany,
    List<Input$GuestWhereUniqueInput>? connect,
  }) =>
      Input$GuestCreateNestedManyWithoutGroupMemberOfInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (createMany != null) r'createMany': createMany,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedManyWithoutGroupMemberOfInput._(this._$data);

  factory Input$GuestCreateNestedManyWithoutGroupMemberOfInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$GuestCreateWithoutGroupMemberOfInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$GuestCreateOrConnectWithoutGroupMemberOfInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$GuestCreateManyGroupMemberOfInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereUniqueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$GuestCreateNestedManyWithoutGroupMemberOfInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$GuestCreateWithoutGroupMemberOfInput>? get create =>
      (_$data['create'] as List<Input$GuestCreateWithoutGroupMemberOfInput>?);
  List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>?);
  Input$GuestCreateManyGroupMemberOfInputEnvelope? get createMany =>
      (_$data['createMany']
          as Input$GuestCreateManyGroupMemberOfInputEnvelope?);
  List<Input$GuestWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$GuestWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<
          Input$GuestCreateNestedManyWithoutGroupMemberOfInput>
      get copyWith =>
          CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedManyWithoutGroupMemberOfInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<
    TRes> {
  factory CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput instance,
    TRes Function(Input$GuestCreateNestedManyWithoutGroupMemberOfInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedManyWithoutGroupMemberOfInput;

  factory CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedManyWithoutGroupMemberOfInput;

  TRes call({
    List<Input$GuestCreateWithoutGroupMemberOfInput>? create,
    List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? connectOrCreate,
    Input$GuestCreateManyGroupMemberOfInputEnvelope? createMany,
    List<Input$GuestWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$GuestCreateWithoutGroupMemberOfInput>? Function(
              Iterable<
                  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<
                      Input$GuestCreateWithoutGroupMemberOfInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? Function(
              Iterable<
                  CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<
                      Input$GuestCreateOrConnectWithoutGroupMemberOfInput>>?)
          _fn);
  CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes> get createMany;
  TRes connect(
      Iterable<Input$GuestWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$GuestWhereUniqueInput<
                      Input$GuestWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
    implements
        CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedManyWithoutGroupMemberOfInput _instance;

  final TRes Function(Input$GuestCreateNestedManyWithoutGroupMemberOfInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? createMany = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedManyWithoutGroupMemberOfInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$GuestCreateWithoutGroupMemberOfInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$GuestCreateManyGroupMemberOfInputEnvelope?),
        if (connect != _undefined)
          'connect': (connect as List<Input$GuestWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$GuestCreateWithoutGroupMemberOfInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<
                          Input$GuestCreateWithoutGroupMemberOfInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$GuestCreateWithoutGroupMemberOfInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<
                          Input$GuestCreateOrConnectWithoutGroupMemberOfInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes>
      get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes connect(
          Iterable<Input$GuestWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereUniqueInput<
                          Input$GuestWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$GuestWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<
        TRes>
    implements
        CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
      this._res);

  TRes _res;

  call({
    List<Input$GuestCreateWithoutGroupMemberOfInput>? create,
    List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? connectOrCreate,
    Input$GuestCreateManyGroupMemberOfInputEnvelope? createMany,
    List<Input$GuestWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes>
      get createMany =>
          CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope.stub(_res);
  connect(_fn) => _res;
}

class Input$GuestCreateNestedOneWithoutGroupMembersInput {
  factory Input$GuestCreateNestedOneWithoutGroupMembersInput({
    Input$GuestCreateWithoutGroupMembersInput? create,
    Input$GuestCreateOrConnectWithoutGroupMembersInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      Input$GuestCreateNestedOneWithoutGroupMembersInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedOneWithoutGroupMembersInput._(this._$data);

  factory Input$GuestCreateNestedOneWithoutGroupMembersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutGroupMembersInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutGroupMembersInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$GuestCreateNestedOneWithoutGroupMembersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutGroupMembersInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutGroupMembersInput?);
  Input$GuestCreateOrConnectWithoutGroupMembersInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutGroupMembersInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<
          Input$GuestCreateNestedOneWithoutGroupMembersInput>
      get copyWith =>
          CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedOneWithoutGroupMembersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<
    TRes> {
  factory CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput(
    Input$GuestCreateNestedOneWithoutGroupMembersInput instance,
    TRes Function(Input$GuestCreateNestedOneWithoutGroupMembersInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedOneWithoutGroupMembersInput;

  factory CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutGroupMembersInput;

  TRes call({
    Input$GuestCreateWithoutGroupMembersInput? create,
    Input$GuestCreateOrConnectWithoutGroupMembersInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  });
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
    implements
        CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedOneWithoutGroupMembersInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedOneWithoutGroupMembersInput _instance;

  final TRes Function(Input$GuestCreateNestedOneWithoutGroupMembersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedOneWithoutGroupMembersInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutGroupMembersInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutGroupMembersInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutGroupMembersInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
    implements
        CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutGroupMembersInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutGroupMembersInput? create,
    Input$GuestCreateOrConnectWithoutGroupMembersInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutGroupMembersInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput.stub(
              _res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
}

class Input$GuestCreateNestedOneWithoutInvitationImageInput {
  factory Input$GuestCreateNestedOneWithoutInvitationImageInput({
    Input$GuestCreateWithoutInvitationImageInput? create,
    Input$GuestCreateOrConnectWithoutInvitationImageInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      Input$GuestCreateNestedOneWithoutInvitationImageInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedOneWithoutInvitationImageInput._(this._$data);

  factory Input$GuestCreateNestedOneWithoutInvitationImageInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutInvitationImageInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutInvitationImageInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$GuestCreateNestedOneWithoutInvitationImageInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutInvitationImageInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutInvitationImageInput?);
  Input$GuestCreateOrConnectWithoutInvitationImageInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutInvitationImageInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput<
          Input$GuestCreateNestedOneWithoutInvitationImageInput>
      get copyWith =>
          CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedOneWithoutInvitationImageInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput<
    TRes> {
  factory CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput(
    Input$GuestCreateNestedOneWithoutInvitationImageInput instance,
    TRes Function(Input$GuestCreateNestedOneWithoutInvitationImageInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedOneWithoutInvitationImageInput;

  factory CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutInvitationImageInput;

  TRes call({
    Input$GuestCreateWithoutInvitationImageInput? create,
    Input$GuestCreateOrConnectWithoutInvitationImageInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  });
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$GuestCreateNestedOneWithoutInvitationImageInput<TRes>
    implements
        CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedOneWithoutInvitationImageInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedOneWithoutInvitationImageInput _instance;

  final TRes Function(Input$GuestCreateNestedOneWithoutInvitationImageInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedOneWithoutInvitationImageInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutInvitationImageInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutInvitationImageInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutInvitationImageInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutInvitationImageInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutInvitationImageInput<
        TRes>
    implements
        CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutInvitationImageInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutInvitationImageInput? create,
    Input$GuestCreateOrConnectWithoutInvitationImageInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutInvitationImageInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput.stub(
              _res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
}

class Input$GuestCreateNestedOneWithoutQrcodeInput {
  factory Input$GuestCreateNestedOneWithoutQrcodeInput({
    Input$GuestCreateWithoutQrcodeInput? create,
    Input$GuestCreateOrConnectWithoutQrcodeInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      Input$GuestCreateNestedOneWithoutQrcodeInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedOneWithoutQrcodeInput._(this._$data);

  factory Input$GuestCreateNestedOneWithoutQrcodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutQrcodeInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutQrcodeInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$GuestCreateNestedOneWithoutQrcodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutQrcodeInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutQrcodeInput?);
  Input$GuestCreateOrConnectWithoutQrcodeInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutQrcodeInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<
          Input$GuestCreateNestedOneWithoutQrcodeInput>
      get copyWith => CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedOneWithoutQrcodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> {
  factory CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput(
    Input$GuestCreateNestedOneWithoutQrcodeInput instance,
    TRes Function(Input$GuestCreateNestedOneWithoutQrcodeInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedOneWithoutQrcodeInput;

  factory CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutQrcodeInput;

  TRes call({
    Input$GuestCreateWithoutQrcodeInput? create,
    Input$GuestCreateOrConnectWithoutQrcodeInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  });
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedOneWithoutQrcodeInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedOneWithoutQrcodeInput _instance;

  final TRes Function(Input$GuestCreateNestedOneWithoutQrcodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedOneWithoutQrcodeInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutQrcodeInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutQrcodeInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutQrcodeInput.stub(_then(_instance))
        : CopyWith$Input$GuestCreateWithoutQrcodeInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutQrcodeInput(this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutQrcodeInput? create,
    Input$GuestCreateOrConnectWithoutQrcodeInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutQrcodeInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
}

class Input$GuestCreateNestedOneWithoutWhatsappStatusesInput {
  factory Input$GuestCreateNestedOneWithoutWhatsappStatusesInput({
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappStatusesInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      Input$GuestCreateNestedOneWithoutWhatsappStatusesInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedOneWithoutWhatsappStatusesInput._(this._$data);

  factory Input$GuestCreateNestedOneWithoutWhatsappStatusesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutWhatsappStatusesInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutWhatsappStatusesInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$GuestCreateNestedOneWithoutWhatsappStatusesInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutWhatsappStatusesInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutWhatsappStatusesInput?);
  Input$GuestCreateOrConnectWithoutWhatsappStatusesInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutWhatsappStatusesInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<
          Input$GuestCreateNestedOneWithoutWhatsappStatusesInput>
      get copyWith =>
          CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedOneWithoutWhatsappStatusesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<
    TRes> {
  factory CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput(
    Input$GuestCreateNestedOneWithoutWhatsappStatusesInput instance,
    TRes Function(Input$GuestCreateNestedOneWithoutWhatsappStatusesInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput;

  factory CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput;

  TRes call({
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappStatusesInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  });
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<TRes>
    implements
        CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedOneWithoutWhatsappStatusesInput _instance;

  final TRes Function(Input$GuestCreateNestedOneWithoutWhatsappStatusesInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedOneWithoutWhatsappStatusesInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutWhatsappStatusesInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutWhatsappStatusesInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<
        TRes>
    implements
        CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappStatusesInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput.stub(
              _res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutGroupMemberOfInput {
  factory Input$GuestCreateOrConnectWithoutGroupMemberOfInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutGroupMemberOfInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutGroupMemberOfInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutGroupMemberOfInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutGroupMemberOfInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutGroupMemberOfInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutGroupMemberOfInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutGroupMemberOfInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutGroupMemberOfInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<
          Input$GuestCreateOrConnectWithoutGroupMemberOfInput>
      get copyWith =>
          CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutGroupMemberOfInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<
    TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput(
    Input$GuestCreateOrConnectWithoutGroupMemberOfInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutGroupMemberOfInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutGroupMemberOfInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutGroupMemberOfInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutGroupMemberOfInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutGroupMemberOfInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutGroupMemberOfInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutGroupMemberOfInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutGroupMemberOfInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutGroupMemberOfInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutGroupMemberOfInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<
        TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutGroupMemberOfInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutGroupMemberOfInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutGroupMemberOfInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutGroupMembersInput {
  factory Input$GuestCreateOrConnectWithoutGroupMembersInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutGroupMembersInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutGroupMembersInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutGroupMembersInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutGroupMembersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutGroupMembersInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutGroupMembersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutGroupMembersInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutGroupMembersInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<
          Input$GuestCreateOrConnectWithoutGroupMembersInput>
      get copyWith =>
          CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutGroupMembersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<
    TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput(
    Input$GuestCreateOrConnectWithoutGroupMembersInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutGroupMembersInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutGroupMembersInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutGroupMembersInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutGroupMembersInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutGroupMembersInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutGroupMembersInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutGroupMembersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutGroupMembersInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutGroupMembersInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutGroupMembersInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutGroupMembersInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutGroupMembersInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutGroupMembersInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutInvitationImageInput {
  factory Input$GuestCreateOrConnectWithoutInvitationImageInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutInvitationImageInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutInvitationImageInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutInvitationImageInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutInvitationImageInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$GuestCreateWithoutInvitationImageInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutInvitationImageInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutInvitationImageInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutInvitationImageInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<
          Input$GuestCreateOrConnectWithoutInvitationImageInput>
      get copyWith =>
          CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutInvitationImageInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<
    TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput(
    Input$GuestCreateOrConnectWithoutInvitationImageInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutInvitationImageInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutInvitationImageInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutInvitationImageInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutInvitationImageInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutInvitationImageInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutInvitationImageInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutInvitationImageInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutInvitationImageInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutInvitationImageInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutInvitationImageInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutInvitationImageInput<
        TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutInvitationImageInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutInvitationImageInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutInvitationImageInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutQrcodeInput {
  factory Input$GuestCreateOrConnectWithoutQrcodeInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutQrcodeInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutQrcodeInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutQrcodeInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutQrcodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutQrcodeInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutQrcodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutQrcodeInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutQrcodeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<
          Input$GuestCreateOrConnectWithoutQrcodeInput>
      get copyWith => CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutQrcodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput(
    Input$GuestCreateOrConnectWithoutQrcodeInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutQrcodeInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutQrcodeInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutQrcodeInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutQrcodeInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutQrcodeInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutQrcodeInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutQrcodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutQrcodeInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutQrcodeInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutQrcodeInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutQrcodeInput(this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutQrcodeInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutQrcodeInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutWhatsappStatusesInput {
  factory Input$GuestCreateOrConnectWithoutWhatsappStatusesInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutWhatsappStatusesInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutWhatsappStatusesInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutWhatsappStatusesInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutWhatsappStatusesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$GuestCreateWithoutWhatsappStatusesInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutWhatsappStatusesInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutWhatsappStatusesInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutWhatsappStatusesInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<
          Input$GuestCreateOrConnectWithoutWhatsappStatusesInput>
      get copyWith =>
          CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutWhatsappStatusesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<
    TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput(
    Input$GuestCreateOrConnectWithoutWhatsappStatusesInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutWhatsappStatusesInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutWhatsappStatusesInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutWhatsappStatusesInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutWhatsappStatusesInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutWhatsappStatusesInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<
        TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput.stub(_res);
}

class Input$GuestCreateWithoutGroupMemberOfInput {
  factory Input$GuestCreateWithoutGroupMemberOfInput({
    String? id,
    String? source,
    required String invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      Input$GuestCreateWithoutGroupMemberOfInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestCreateWithoutGroupMemberOfInput._(this._$data);

  factory Input$GuestCreateWithoutGroupMemberOfInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    final l$invitationName = data['invitationName'];
    result$data['invitationName'] = (l$invitationName as String);
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as num?)?.toDouble();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as String?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestCreateNestedManyWithoutGroupMemberOfInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeCreateNestedOneWithoutGuestInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageCreateNestedOneWithoutGuestInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutGroupMemberOfInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get source => (_$data['source'] as String?);
  String get invitationName => (_$data['invitationName'] as String);
  String? get contactList => (_$data['contactList'] as String?);
  double? get whatsapp => (_$data['whatsapp'] as double?);
  String? get category => (_$data['category'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get studio => (_$data['studio'] as String?);
  String? get showTime => (_$data['showTime'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$GuestCreateNestedManyWithoutGroupMemberOfInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?);
  Input$QrCodeCreateNestedOneWithoutGuestInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeCreateNestedOneWithoutGuestInput?);
  Input$InvitationImageCreateNestedOneWithoutGuestInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageCreateNestedOneWithoutGuestInput?);
  Input$WhatsappStatusCreateNestedManyWithoutGuestInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    final l$invitationName = invitationName;
    result$data['invitationName'] = l$invitationName;
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<
          Input$GuestCreateWithoutGroupMemberOfInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutGroupMemberOfInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutGroupMemberOfInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      l$invitationName,
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutGroupMemberOfInput(
    Input$GuestCreateWithoutGroupMemberOfInput instance,
    TRes Function(Input$GuestCreateWithoutGroupMemberOfInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutGroupMemberOfInput;

  factory CopyWith$Input$GuestCreateWithoutGroupMemberOfInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutGroupMemberOfInput;

  TRes call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  });
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers;
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestCreateWithoutGroupMemberOfInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutGroupMemberOfInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutGroupMemberOfInput _instance;

  final TRes Function(Input$GuestCreateWithoutGroupMemberOfInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutGroupMemberOfInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (source != _undefined) 'source': (source as String?),
        if (invitationName != _undefined && invitationName != null)
          'invitationName': (invitationName as String),
        if (contactList != _undefined) 'contactList': (contactList as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as double?),
        if (category != _undefined) 'category': (category as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (studio != _undefined) 'studio': (studio as String?),
        if (showTime != _undefined) 'showTime': (showTime as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeCreateNestedOneWithoutGuestInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageCreateNestedOneWithoutGuestInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutGroupMemberOfInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutGroupMemberOfInput(this._res);

  TRes _res;

  call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
              _res);
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
              _res);
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateWithoutGroupMembersInput {
  factory Input$GuestCreateWithoutGroupMembersInput({
    String? id,
    String? source,
    required String invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      Input$GuestCreateWithoutGroupMembersInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestCreateWithoutGroupMembersInput._(this._$data);

  factory Input$GuestCreateWithoutGroupMembersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    final l$invitationName = data['invitationName'];
    result$data['invitationName'] = (l$invitationName as String);
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as num?)?.toDouble();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as String?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestCreateNestedOneWithoutGroupMembersInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeCreateNestedOneWithoutGuestInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageCreateNestedOneWithoutGuestInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutGroupMembersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get source => (_$data['source'] as String?);
  String get invitationName => (_$data['invitationName'] as String);
  String? get contactList => (_$data['contactList'] as String?);
  double? get whatsapp => (_$data['whatsapp'] as double?);
  String? get category => (_$data['category'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get studio => (_$data['studio'] as String?);
  String? get showTime => (_$data['showTime'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$GuestCreateNestedOneWithoutGroupMembersInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestCreateNestedOneWithoutGroupMembersInput?);
  Input$QrCodeCreateNestedOneWithoutGuestInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeCreateNestedOneWithoutGuestInput?);
  Input$InvitationImageCreateNestedOneWithoutGuestInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageCreateNestedOneWithoutGuestInput?);
  Input$WhatsappStatusCreateNestedManyWithoutGuestInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    final l$invitationName = invitationName;
    result$data['invitationName'] = l$invitationName;
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutGroupMembersInput<
          Input$GuestCreateWithoutGroupMembersInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutGroupMembersInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutGroupMembersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      l$invitationName,
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutGroupMembersInput(
    Input$GuestCreateWithoutGroupMembersInput instance,
    TRes Function(Input$GuestCreateWithoutGroupMembersInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutGroupMembersInput;

  factory CopyWith$Input$GuestCreateWithoutGroupMembersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutGroupMembersInput;

  TRes call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf;
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestCreateWithoutGroupMembersInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutGroupMembersInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutGroupMembersInput _instance;

  final TRes Function(Input$GuestCreateWithoutGroupMembersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutGroupMembersInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (source != _undefined) 'source': (source as String?),
        if (invitationName != _undefined && invitationName != null)
          'invitationName': (invitationName as String),
        if (contactList != _undefined) 'contactList': (contactList as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as double?),
        if (category != _undefined) 'category': (category as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (studio != _undefined) 'studio': (studio as String?),
        if (showTime != _undefined) 'showTime': (showTime as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestCreateNestedOneWithoutGroupMembersInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeCreateNestedOneWithoutGuestInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageCreateNestedOneWithoutGuestInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutGroupMembersInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutGroupMembersInput(this._res);

  TRes _res;

  call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
              _res);
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
              _res);
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateWithoutInvitationImageInput {
  factory Input$GuestCreateWithoutInvitationImageInput({
    String? id,
    String? source,
    required String invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      Input$GuestCreateWithoutInvitationImageInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestCreateWithoutInvitationImageInput._(this._$data);

  factory Input$GuestCreateWithoutInvitationImageInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    final l$invitationName = data['invitationName'];
    result$data['invitationName'] = (l$invitationName as String);
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as num?)?.toDouble();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as String?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestCreateNestedOneWithoutGroupMembersInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestCreateNestedManyWithoutGroupMemberOfInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeCreateNestedOneWithoutGuestInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutInvitationImageInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get source => (_$data['source'] as String?);
  String get invitationName => (_$data['invitationName'] as String);
  String? get contactList => (_$data['contactList'] as String?);
  double? get whatsapp => (_$data['whatsapp'] as double?);
  String? get category => (_$data['category'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get studio => (_$data['studio'] as String?);
  String? get showTime => (_$data['showTime'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$GuestCreateNestedOneWithoutGroupMembersInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestCreateNestedOneWithoutGroupMembersInput?);
  Input$GuestCreateNestedManyWithoutGroupMemberOfInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?);
  Input$QrCodeCreateNestedOneWithoutGuestInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeCreateNestedOneWithoutGuestInput?);
  Input$WhatsappStatusCreateNestedManyWithoutGuestInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    final l$invitationName = invitationName;
    result$data['invitationName'] = l$invitationName;
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutInvitationImageInput<
          Input$GuestCreateWithoutInvitationImageInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutInvitationImageInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutInvitationImageInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      l$invitationName,
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutInvitationImageInput(
    Input$GuestCreateWithoutInvitationImageInput instance,
    TRes Function(Input$GuestCreateWithoutInvitationImageInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutInvitationImageInput;

  factory CopyWith$Input$GuestCreateWithoutInvitationImageInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutInvitationImageInput;

  TRes call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf;
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers;
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode;
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestCreateWithoutInvitationImageInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutInvitationImageInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutInvitationImageInput _instance;

  final TRes Function(Input$GuestCreateWithoutInvitationImageInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutInvitationImageInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (source != _undefined) 'source': (source as String?),
        if (invitationName != _undefined && invitationName != null)
          'invitationName': (invitationName as String),
        if (contactList != _undefined) 'contactList': (contactList as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as double?),
        if (category != _undefined) 'category': (category as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (studio != _undefined) 'studio': (studio as String?),
        if (showTime != _undefined) 'showTime': (showTime as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestCreateNestedOneWithoutGroupMembersInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeCreateNestedOneWithoutGuestInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutInvitationImageInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutInvitationImageInput(this._res);

  TRes _res;

  call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
              _res);
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
              _res);
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(_res);
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateWithoutQrcodeInput {
  factory Input$GuestCreateWithoutQrcodeInput({
    String? id,
    String? source,
    required String invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      Input$GuestCreateWithoutQrcodeInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestCreateWithoutQrcodeInput._(this._$data);

  factory Input$GuestCreateWithoutQrcodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    final l$invitationName = data['invitationName'];
    result$data['invitationName'] = (l$invitationName as String);
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as num?)?.toDouble();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as String?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestCreateNestedOneWithoutGroupMembersInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestCreateNestedManyWithoutGroupMemberOfInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageCreateNestedOneWithoutGuestInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutQrcodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get source => (_$data['source'] as String?);
  String get invitationName => (_$data['invitationName'] as String);
  String? get contactList => (_$data['contactList'] as String?);
  double? get whatsapp => (_$data['whatsapp'] as double?);
  String? get category => (_$data['category'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get studio => (_$data['studio'] as String?);
  String? get showTime => (_$data['showTime'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$GuestCreateNestedOneWithoutGroupMembersInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestCreateNestedOneWithoutGroupMembersInput?);
  Input$GuestCreateNestedManyWithoutGroupMemberOfInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?);
  Input$InvitationImageCreateNestedOneWithoutGuestInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageCreateNestedOneWithoutGuestInput?);
  Input$WhatsappStatusCreateNestedManyWithoutGuestInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    final l$invitationName = invitationName;
    result$data['invitationName'] = l$invitationName;
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutQrcodeInput<
          Input$GuestCreateWithoutQrcodeInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutQrcodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutQrcodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      l$invitationName,
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutQrcodeInput(
    Input$GuestCreateWithoutQrcodeInput instance,
    TRes Function(Input$GuestCreateWithoutQrcodeInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutQrcodeInput;

  factory CopyWith$Input$GuestCreateWithoutQrcodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutQrcodeInput;

  TRes call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf;
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers;
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestCreateWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutQrcodeInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutQrcodeInput _instance;

  final TRes Function(Input$GuestCreateWithoutQrcodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutQrcodeInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (source != _undefined) 'source': (source as String?),
        if (invitationName != _undefined && invitationName != null)
          'invitationName': (invitationName as String),
        if (contactList != _undefined) 'contactList': (contactList as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as double?),
        if (category != _undefined) 'category': (category as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (studio != _undefined) 'studio': (studio as String?),
        if (showTime != _undefined) 'showTime': (showTime as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestCreateNestedOneWithoutGroupMembersInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageCreateNestedOneWithoutGuestInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutQrcodeInput(this._res);

  TRes _res;

  call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
              _res);
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
              _res);
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
              _res);
  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateWithoutWhatsappStatusesInput {
  factory Input$GuestCreateWithoutWhatsappStatusesInput({
    String? id,
    String? source,
    required String invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
  }) =>
      Input$GuestCreateWithoutWhatsappStatusesInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
      });

  Input$GuestCreateWithoutWhatsappStatusesInput._(this._$data);

  factory Input$GuestCreateWithoutWhatsappStatusesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as String?);
    }
    final l$invitationName = data['invitationName'];
    result$data['invitationName'] = (l$invitationName as String);
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as num?)?.toDouble();
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as String?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestCreateNestedOneWithoutGroupMembersInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestCreateNestedManyWithoutGroupMemberOfInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeCreateNestedOneWithoutGuestInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageCreateNestedOneWithoutGuestInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutWhatsappStatusesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get source => (_$data['source'] as String?);
  String get invitationName => (_$data['invitationName'] as String);
  String? get contactList => (_$data['contactList'] as String?);
  double? get whatsapp => (_$data['whatsapp'] as double?);
  String? get category => (_$data['category'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get studio => (_$data['studio'] as String?);
  String? get showTime => (_$data['showTime'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$GuestCreateNestedOneWithoutGroupMembersInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestCreateNestedOneWithoutGroupMembersInput?);
  Input$GuestCreateNestedManyWithoutGroupMemberOfInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?);
  Input$QrCodeCreateNestedOneWithoutGuestInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeCreateNestedOneWithoutGuestInput?);
  Input$InvitationImageCreateNestedOneWithoutGuestInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageCreateNestedOneWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    final l$invitationName = invitationName;
    result$data['invitationName'] = l$invitationName;
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<
          Input$GuestCreateWithoutWhatsappStatusesInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutWhatsappStatusesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      l$invitationName,
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput(
    Input$GuestCreateWithoutWhatsappStatusesInput instance,
    TRes Function(Input$GuestCreateWithoutWhatsappStatusesInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutWhatsappStatusesInput;

  factory CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutWhatsappStatusesInput;

  TRes call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf;
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers;
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage;
}

class _CopyWithImpl$Input$GuestCreateWithoutWhatsappStatusesInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutWhatsappStatusesInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutWhatsappStatusesInput _instance;

  final TRes Function(Input$GuestCreateWithoutWhatsappStatusesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutWhatsappStatusesInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (source != _undefined) 'source': (source as String?),
        if (invitationName != _undefined && invitationName != null)
          'invitationName': (invitationName as String),
        if (contactList != _undefined) 'contactList': (contactList as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as double?),
        if (category != _undefined) 'category': (category as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (studio != _undefined) 'studio': (studio as String?),
        if (showTime != _undefined) 'showTime': (showTime as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestCreateNestedOneWithoutGroupMembersInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestCreateNestedManyWithoutGroupMemberOfInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeCreateNestedOneWithoutGuestInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageCreateNestedOneWithoutGuestInput?),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutWhatsappStatusesInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutWhatsappStatusesInput(this._res);

  TRes _res;

  call({
    String? id,
    String? source,
    String? invitationName,
    String? contactList,
    double? whatsapp,
    String? category,
    String? $class,
    String? seat,
    String? studio,
    String? showTime,
    String? rejectionReason,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$GuestCreateNestedOneWithoutGroupMembersInput? groupMemberOf,
    Input$GuestCreateNestedManyWithoutGroupMemberOfInput? groupMembers,
    Input$QrCodeCreateNestedOneWithoutGuestInput? qrcode,
    Input$InvitationImageCreateNestedOneWithoutGuestInput? invitationImage,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestCreateNestedOneWithoutGroupMembersInput.stub(
              _res);
  CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestCreateNestedManyWithoutGroupMemberOfInput.stub(
              _res);
  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
              _res);
}

class Input$GuestListRelationFilter {
  factory Input$GuestListRelationFilter({
    Input$GuestWhereInput? every,
    Input$GuestWhereInput? some,
    Input$GuestWhereInput? none,
  }) =>
      Input$GuestListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$GuestListRelationFilter._(this._$data);

  factory Input$GuestListRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$GuestWhereInput.fromJson((l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$GuestWhereInput.fromJson((l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$GuestWhereInput.fromJson((l$none as Map<String, dynamic>));
    }
    return Input$GuestListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get every =>
      (_$data['every'] as Input$GuestWhereInput?);
  Input$GuestWhereInput? get some => (_$data['some'] as Input$GuestWhereInput?);
  Input$GuestWhereInput? get none => (_$data['none'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestListRelationFilter<Input$GuestListRelationFilter>
      get copyWith => CopyWith$Input$GuestListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestListRelationFilter<TRes> {
  factory CopyWith$Input$GuestListRelationFilter(
    Input$GuestListRelationFilter instance,
    TRes Function(Input$GuestListRelationFilter) then,
  ) = _CopyWithImpl$Input$GuestListRelationFilter;

  factory CopyWith$Input$GuestListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestListRelationFilter;

  TRes call({
    Input$GuestWhereInput? every,
    Input$GuestWhereInput? some,
    Input$GuestWhereInput? none,
  });
  CopyWith$Input$GuestWhereInput<TRes> get every;
  CopyWith$Input$GuestWhereInput<TRes> get some;
  CopyWith$Input$GuestWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$GuestListRelationFilter<TRes>
    implements CopyWith$Input$GuestListRelationFilter<TRes> {
  _CopyWithImpl$Input$GuestListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$GuestListRelationFilter _instance;

  final TRes Function(Input$GuestListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$GuestListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined) 'every': (every as Input$GuestWhereInput?),
        if (some != _undefined) 'some': (some as Input$GuestWhereInput?),
        if (none != _undefined) 'none': (none as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$every, (e) => call(every: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$some, (e) => call(some: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$GuestListRelationFilter<TRes>
    implements CopyWith$Input$GuestListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$GuestListRelationFilter(this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? every,
    Input$GuestWhereInput? some,
    Input$GuestWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get every =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get some =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get none =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestMaxAggregateInput {
  factory Input$GuestMaxAggregateInput({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
  }) =>
      Input$GuestMaxAggregateInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (groupMemberOfId != null) r'groupMemberOfId': groupMemberOfId,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestMaxAggregateInput._(this._$data);

  factory Input$GuestMaxAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as bool?);
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = (l$invitationName as bool?);
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as bool?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as bool?);
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as bool?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as bool?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as bool?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as bool?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as bool?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = data['groupMemberOfId'];
      result$data['groupMemberOfId'] = (l$groupMemberOfId as bool?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = (l$confirmationStatus as bool?);
    }
    return Input$GuestMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get source => (_$data['source'] as bool?);
  bool? get invitationName => (_$data['invitationName'] as bool?);
  bool? get contactList => (_$data['contactList'] as bool?);
  bool? get whatsapp => (_$data['whatsapp'] as bool?);
  bool? get category => (_$data['category'] as bool?);
  bool? get $class => (_$data['class'] as bool?);
  bool? get seat => (_$data['seat'] as bool?);
  bool? get studio => (_$data['studio'] as bool?);
  bool? get showTime => (_$data['showTime'] as bool?);
  bool? get rejectionReason => (_$data['rejectionReason'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get groupMemberOfId => (_$data['groupMemberOfId'] as bool?);
  bool? get confirmationStatus => (_$data['confirmationStatus'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName;
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = groupMemberOfId;
      result$data['groupMemberOfId'] = l$groupMemberOfId;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus;
    }
    return result$data;
  }

  CopyWith$Input$GuestMaxAggregateInput<Input$GuestMaxAggregateInput>
      get copyWith => CopyWith$Input$GuestMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$groupMemberOfId = groupMemberOfId;
    final lOther$groupMemberOfId = other.groupMemberOfId;
    if (_$data.containsKey('groupMemberOfId') !=
        other._$data.containsKey('groupMemberOfId')) {
      return false;
    }
    if (l$groupMemberOfId != lOther$groupMemberOfId) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$groupMemberOfId = groupMemberOfId;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('groupMemberOfId') ? l$groupMemberOfId : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestMaxAggregateInput<TRes> {
  factory CopyWith$Input$GuestMaxAggregateInput(
    Input$GuestMaxAggregateInput instance,
    TRes Function(Input$GuestMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestMaxAggregateInput;

  factory CopyWith$Input$GuestMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestMaxAggregateInput;

  TRes call({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
  });
}

class _CopyWithImpl$Input$GuestMaxAggregateInput<TRes>
    implements CopyWith$Input$GuestMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestMaxAggregateInput _instance;

  final TRes Function(Input$GuestMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? groupMemberOfId = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestMaxAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (source != _undefined) 'source': (source as bool?),
        if (invitationName != _undefined)
          'invitationName': (invitationName as bool?),
        if (contactList != _undefined) 'contactList': (contactList as bool?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as bool?),
        if (category != _undefined) 'category': (category as bool?),
        if ($class != _undefined) 'class': ($class as bool?),
        if (seat != _undefined) 'seat': (seat as bool?),
        if (studio != _undefined) 'studio': (studio as bool?),
        if (showTime != _undefined) 'showTime': (showTime as bool?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (groupMemberOfId != _undefined)
          'groupMemberOfId': (groupMemberOfId as bool?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestMaxAggregateInput<TRes>
    implements CopyWith$Input$GuestMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
  }) =>
      _res;
}

class Input$GuestMinAggregateInput {
  factory Input$GuestMinAggregateInput({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
  }) =>
      Input$GuestMinAggregateInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (groupMemberOfId != null) r'groupMemberOfId': groupMemberOfId,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestMinAggregateInput._(this._$data);

  factory Input$GuestMinAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = (l$source as bool?);
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = (l$invitationName as bool?);
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = (l$contactList as bool?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as bool?);
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = (l$category as bool?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as bool?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as bool?);
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = (l$studio as bool?);
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = (l$showTime as bool?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = data['groupMemberOfId'];
      result$data['groupMemberOfId'] = (l$groupMemberOfId as bool?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = (l$confirmationStatus as bool?);
    }
    return Input$GuestMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get source => (_$data['source'] as bool?);
  bool? get invitationName => (_$data['invitationName'] as bool?);
  bool? get contactList => (_$data['contactList'] as bool?);
  bool? get whatsapp => (_$data['whatsapp'] as bool?);
  bool? get category => (_$data['category'] as bool?);
  bool? get $class => (_$data['class'] as bool?);
  bool? get seat => (_$data['seat'] as bool?);
  bool? get studio => (_$data['studio'] as bool?);
  bool? get showTime => (_$data['showTime'] as bool?);
  bool? get rejectionReason => (_$data['rejectionReason'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get groupMemberOfId => (_$data['groupMemberOfId'] as bool?);
  bool? get confirmationStatus => (_$data['confirmationStatus'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source;
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName;
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio;
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = groupMemberOfId;
      result$data['groupMemberOfId'] = l$groupMemberOfId;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus;
    }
    return result$data;
  }

  CopyWith$Input$GuestMinAggregateInput<Input$GuestMinAggregateInput>
      get copyWith => CopyWith$Input$GuestMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$groupMemberOfId = groupMemberOfId;
    final lOther$groupMemberOfId = other.groupMemberOfId;
    if (_$data.containsKey('groupMemberOfId') !=
        other._$data.containsKey('groupMemberOfId')) {
      return false;
    }
    if (l$groupMemberOfId != lOther$groupMemberOfId) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$groupMemberOfId = groupMemberOfId;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('groupMemberOfId') ? l$groupMemberOfId : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestMinAggregateInput<TRes> {
  factory CopyWith$Input$GuestMinAggregateInput(
    Input$GuestMinAggregateInput instance,
    TRes Function(Input$GuestMinAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestMinAggregateInput;

  factory CopyWith$Input$GuestMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestMinAggregateInput;

  TRes call({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
  });
}

class _CopyWithImpl$Input$GuestMinAggregateInput<TRes>
    implements CopyWith$Input$GuestMinAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestMinAggregateInput _instance;

  final TRes Function(Input$GuestMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? groupMemberOfId = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestMinAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (source != _undefined) 'source': (source as bool?),
        if (invitationName != _undefined)
          'invitationName': (invitationName as bool?),
        if (contactList != _undefined) 'contactList': (contactList as bool?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as bool?),
        if (category != _undefined) 'category': (category as bool?),
        if ($class != _undefined) 'class': ($class as bool?),
        if (seat != _undefined) 'seat': (seat as bool?),
        if (studio != _undefined) 'studio': (studio as bool?),
        if (showTime != _undefined) 'showTime': (showTime as bool?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (groupMemberOfId != _undefined)
          'groupMemberOfId': (groupMemberOfId as bool?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestMinAggregateInput<TRes>
    implements CopyWith$Input$GuestMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? source,
    bool? invitationName,
    bool? contactList,
    bool? whatsapp,
    bool? category,
    bool? $class,
    bool? seat,
    bool? studio,
    bool? showTime,
    bool? rejectionReason,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? groupMemberOfId,
    bool? confirmationStatus,
  }) =>
      _res;
}

class Input$GuestNullableRelationFilter {
  factory Input$GuestNullableRelationFilter({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  }) =>
      Input$GuestNullableRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$GuestNullableRelationFilter._(this._$data);

  factory Input$GuestNullableRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$GuestWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$GuestWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$GuestNullableRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get $is => (_$data['is'] as Input$GuestWhereInput?);
  Input$GuestWhereInput? get isNot =>
      (_$data['isNot'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestNullableRelationFilter<Input$GuestNullableRelationFilter>
      get copyWith => CopyWith$Input$GuestNullableRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestNullableRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestNullableRelationFilter<TRes> {
  factory CopyWith$Input$GuestNullableRelationFilter(
    Input$GuestNullableRelationFilter instance,
    TRes Function(Input$GuestNullableRelationFilter) then,
  ) = _CopyWithImpl$Input$GuestNullableRelationFilter;

  factory CopyWith$Input$GuestNullableRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestNullableRelationFilter;

  TRes call({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  });
  CopyWith$Input$GuestWhereInput<TRes> get $is;
  CopyWith$Input$GuestWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$GuestNullableRelationFilter<TRes>
    implements CopyWith$Input$GuestNullableRelationFilter<TRes> {
  _CopyWithImpl$Input$GuestNullableRelationFilter(
    this._instance,
    this._then,
  );

  final Input$GuestNullableRelationFilter _instance;

  final TRes Function(Input$GuestNullableRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$GuestNullableRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$GuestWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$GuestNullableRelationFilter<TRes>
    implements CopyWith$Input$GuestNullableRelationFilter<TRes> {
  _CopyWithStubImpl$Input$GuestNullableRelationFilter(this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get $is =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get isNot =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestOrderByRelationAggregateInput {
  factory Input$GuestOrderByRelationAggregateInput({Enum$SortOrder? $_count}) =>
      Input$GuestOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$GuestOrderByRelationAggregateInput._(this._$data);

  factory Input$GuestOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$GuestOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$GuestOrderByRelationAggregateInput<
          Input$GuestOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$GuestOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$GuestOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$GuestOrderByRelationAggregateInput(
    Input$GuestOrderByRelationAggregateInput instance,
    TRes Function(Input$GuestOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestOrderByRelationAggregateInput;

  factory CopyWith$Input$GuestOrderByRelationAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$GuestOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$GuestOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestOrderByRelationAggregateInput _instance;

  final TRes Function(Input$GuestOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$GuestOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$GuestOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$GuestOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$GuestOrderByWithRelationInput {
  factory Input$GuestOrderByWithRelationInput({
    Enum$SortOrder? id,
    Input$SortOrderInput? source,
    Enum$SortOrder? invitationName,
    Input$SortOrderInput? contactList,
    Input$SortOrderInput? whatsapp,
    Input$SortOrderInput? category,
    Input$SortOrderInput? $class,
    Input$SortOrderInput? seat,
    Input$SortOrderInput? studio,
    Input$SortOrderInput? showTime,
    Input$SortOrderInput? rejectionReason,
    Enum$SortOrder? createdAt,
    Input$SortOrderInput? updatedAt,
    Input$SortOrderInput? deletedAt,
    Input$SortOrderInput? groupMemberOfId,
    Input$SortOrderInput? confirmationStatus,
    Input$GuestOrderByWithRelationInput? groupMemberOf,
    Input$GuestOrderByRelationAggregateInput? groupMembers,
    Input$QrCodeOrderByWithRelationInput? qrcode,
    Input$InvitationImageOrderByWithRelationInput? invitationImage,
    Input$WhatsappStatusOrderByRelationAggregateInput? whatsappStatuses,
  }) =>
      Input$GuestOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (groupMemberOfId != null) r'groupMemberOfId': groupMemberOfId,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestOrderByWithRelationInput._(this._$data);

  factory Input$GuestOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$SortOrderInput.fromJson((l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : fromJson$Enum$SortOrder((l$invitationName as String));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$SortOrderInput.fromJson((l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$SortOrderInput.fromJson((l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$SortOrderInput.fromJson((l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$SortOrderInput.fromJson((l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$SortOrderInput.fromJson((l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$SortOrderInput.fromJson((l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = data['groupMemberOfId'];
      result$data['groupMemberOfId'] = l$groupMemberOfId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$groupMemberOfId as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestOrderByWithRelationInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestOrderByRelationAggregateInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeOrderByWithRelationInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageOrderByWithRelationInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusOrderByRelationAggregateInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Input$SortOrderInput? get source =>
      (_$data['source'] as Input$SortOrderInput?);
  Enum$SortOrder? get invitationName =>
      (_$data['invitationName'] as Enum$SortOrder?);
  Input$SortOrderInput? get contactList =>
      (_$data['contactList'] as Input$SortOrderInput?);
  Input$SortOrderInput? get whatsapp =>
      (_$data['whatsapp'] as Input$SortOrderInput?);
  Input$SortOrderInput? get category =>
      (_$data['category'] as Input$SortOrderInput?);
  Input$SortOrderInput? get $class =>
      (_$data['class'] as Input$SortOrderInput?);
  Input$SortOrderInput? get seat => (_$data['seat'] as Input$SortOrderInput?);
  Input$SortOrderInput? get studio =>
      (_$data['studio'] as Input$SortOrderInput?);
  Input$SortOrderInput? get showTime =>
      (_$data['showTime'] as Input$SortOrderInput?);
  Input$SortOrderInput? get rejectionReason =>
      (_$data['rejectionReason'] as Input$SortOrderInput?);
  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);
  Input$SortOrderInput? get updatedAt =>
      (_$data['updatedAt'] as Input$SortOrderInput?);
  Input$SortOrderInput? get deletedAt =>
      (_$data['deletedAt'] as Input$SortOrderInput?);
  Input$SortOrderInput? get groupMemberOfId =>
      (_$data['groupMemberOfId'] as Input$SortOrderInput?);
  Input$SortOrderInput? get confirmationStatus =>
      (_$data['confirmationStatus'] as Input$SortOrderInput?);
  Input$GuestOrderByWithRelationInput? get groupMemberOf =>
      (_$data['groupMemberOf'] as Input$GuestOrderByWithRelationInput?);
  Input$GuestOrderByRelationAggregateInput? get groupMembers =>
      (_$data['groupMembers'] as Input$GuestOrderByRelationAggregateInput?);
  Input$QrCodeOrderByWithRelationInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeOrderByWithRelationInput?);
  Input$InvitationImageOrderByWithRelationInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageOrderByWithRelationInput?);
  Input$WhatsappStatusOrderByRelationAggregateInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName == null
          ? null
          : toJson$Enum$SortOrder(l$invitationName);
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = groupMemberOfId;
      result$data['groupMemberOfId'] = l$groupMemberOfId?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestOrderByWithRelationInput<
          Input$GuestOrderByWithRelationInput>
      get copyWith => CopyWith$Input$GuestOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$groupMemberOfId = groupMemberOfId;
    final lOther$groupMemberOfId = other.groupMemberOfId;
    if (_$data.containsKey('groupMemberOfId') !=
        other._$data.containsKey('groupMemberOfId')) {
      return false;
    }
    if (l$groupMemberOfId != lOther$groupMemberOfId) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$groupMemberOfId = groupMemberOfId;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('groupMemberOfId') ? l$groupMemberOfId : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$GuestOrderByWithRelationInput(
    Input$GuestOrderByWithRelationInput instance,
    TRes Function(Input$GuestOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$GuestOrderByWithRelationInput;

  factory CopyWith$Input$GuestOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Input$SortOrderInput? source,
    Enum$SortOrder? invitationName,
    Input$SortOrderInput? contactList,
    Input$SortOrderInput? whatsapp,
    Input$SortOrderInput? category,
    Input$SortOrderInput? $class,
    Input$SortOrderInput? seat,
    Input$SortOrderInput? studio,
    Input$SortOrderInput? showTime,
    Input$SortOrderInput? rejectionReason,
    Enum$SortOrder? createdAt,
    Input$SortOrderInput? updatedAt,
    Input$SortOrderInput? deletedAt,
    Input$SortOrderInput? groupMemberOfId,
    Input$SortOrderInput? confirmationStatus,
    Input$GuestOrderByWithRelationInput? groupMemberOf,
    Input$GuestOrderByRelationAggregateInput? groupMembers,
    Input$QrCodeOrderByWithRelationInput? qrcode,
    Input$InvitationImageOrderByWithRelationInput? invitationImage,
    Input$WhatsappStatusOrderByRelationAggregateInput? whatsappStatuses,
  });
  CopyWith$Input$SortOrderInput<TRes> get source;
  CopyWith$Input$SortOrderInput<TRes> get contactList;
  CopyWith$Input$SortOrderInput<TRes> get whatsapp;
  CopyWith$Input$SortOrderInput<TRes> get category;
  CopyWith$Input$SortOrderInput<TRes> get $class;
  CopyWith$Input$SortOrderInput<TRes> get seat;
  CopyWith$Input$SortOrderInput<TRes> get studio;
  CopyWith$Input$SortOrderInput<TRes> get showTime;
  CopyWith$Input$SortOrderInput<TRes> get rejectionReason;
  CopyWith$Input$SortOrderInput<TRes> get updatedAt;
  CopyWith$Input$SortOrderInput<TRes> get deletedAt;
  CopyWith$Input$SortOrderInput<TRes> get groupMemberOfId;
  CopyWith$Input$SortOrderInput<TRes> get confirmationStatus;
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get groupMemberOf;
  CopyWith$Input$GuestOrderByRelationAggregateInput<TRes> get groupMembers;
  CopyWith$Input$QrCodeOrderByWithRelationInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageOrderByWithRelationInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestOrderByWithRelationInput<TRes>
    implements CopyWith$Input$GuestOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$GuestOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$GuestOrderByWithRelationInput _instance;

  final TRes Function(Input$GuestOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? groupMemberOfId = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (source != _undefined) 'source': (source as Input$SortOrderInput?),
        if (invitationName != _undefined)
          'invitationName': (invitationName as Enum$SortOrder?),
        if (contactList != _undefined)
          'contactList': (contactList as Input$SortOrderInput?),
        if (whatsapp != _undefined)
          'whatsapp': (whatsapp as Input$SortOrderInput?),
        if (category != _undefined)
          'category': (category as Input$SortOrderInput?),
        if ($class != _undefined) 'class': ($class as Input$SortOrderInput?),
        if (seat != _undefined) 'seat': (seat as Input$SortOrderInput?),
        if (studio != _undefined) 'studio': (studio as Input$SortOrderInput?),
        if (showTime != _undefined)
          'showTime': (showTime as Input$SortOrderInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as Input$SortOrderInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$SortOrderInput?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$SortOrderInput?),
        if (groupMemberOfId != _undefined)
          'groupMemberOfId': (groupMemberOfId as Input$SortOrderInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus as Input$SortOrderInput?),
        if (groupMemberOf != _undefined)
          'groupMemberOf':
              (groupMemberOf as Input$GuestOrderByWithRelationInput?),
        if (groupMembers != _undefined)
          'groupMembers':
              (groupMembers as Input$GuestOrderByRelationAggregateInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeOrderByWithRelationInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageOrderByWithRelationInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$SortOrderInput<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$source, (e) => call(source: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$$class, (e) => call($class: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get groupMemberOfId {
    final local$groupMemberOfId = _instance.groupMemberOfId;
    return local$groupMemberOfId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$groupMemberOfId, (e) => call(groupMemberOfId: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$GuestOrderByWithRelationInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestOrderByRelationAggregateInput<TRes> get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestOrderByRelationAggregateInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeOrderByWithRelationInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeOrderByWithRelationInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageOrderByWithRelationInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageOrderByWithRelationInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageOrderByWithRelationInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestOrderByWithRelationInput<TRes>
    implements CopyWith$Input$GuestOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$GuestOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Input$SortOrderInput? source,
    Enum$SortOrder? invitationName,
    Input$SortOrderInput? contactList,
    Input$SortOrderInput? whatsapp,
    Input$SortOrderInput? category,
    Input$SortOrderInput? $class,
    Input$SortOrderInput? seat,
    Input$SortOrderInput? studio,
    Input$SortOrderInput? showTime,
    Input$SortOrderInput? rejectionReason,
    Enum$SortOrder? createdAt,
    Input$SortOrderInput? updatedAt,
    Input$SortOrderInput? deletedAt,
    Input$SortOrderInput? groupMemberOfId,
    Input$SortOrderInput? confirmationStatus,
    Input$GuestOrderByWithRelationInput? groupMemberOf,
    Input$GuestOrderByRelationAggregateInput? groupMembers,
    Input$QrCodeOrderByWithRelationInput? qrcode,
    Input$InvitationImageOrderByWithRelationInput? invitationImage,
    Input$WhatsappStatusOrderByRelationAggregateInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$SortOrderInput<TRes> get source =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get contactList =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get whatsapp =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get category =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get $class =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get seat =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get studio =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get showTime =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get rejectionReason =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get updatedAt =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get deletedAt =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get groupMemberOfId =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get confirmationStatus =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get groupMemberOf =>
      CopyWith$Input$GuestOrderByWithRelationInput.stub(_res);
  CopyWith$Input$GuestOrderByRelationAggregateInput<TRes> get groupMembers =>
      CopyWith$Input$GuestOrderByRelationAggregateInput.stub(_res);
  CopyWith$Input$QrCodeOrderByWithRelationInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeOrderByWithRelationInput.stub(_res);
  CopyWith$Input$InvitationImageOrderByWithRelationInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageOrderByWithRelationInput.stub(_res);
  CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput.stub(_res);
}

class Input$GuestRelationFilter {
  factory Input$GuestRelationFilter({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  }) =>
      Input$GuestRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$GuestRelationFilter._(this._$data);

  factory Input$GuestRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$GuestWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$GuestWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$GuestRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get $is => (_$data['is'] as Input$GuestWhereInput?);
  Input$GuestWhereInput? get isNot =>
      (_$data['isNot'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestRelationFilter<Input$GuestRelationFilter> get copyWith =>
      CopyWith$Input$GuestRelationFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestRelationFilter<TRes> {
  factory CopyWith$Input$GuestRelationFilter(
    Input$GuestRelationFilter instance,
    TRes Function(Input$GuestRelationFilter) then,
  ) = _CopyWithImpl$Input$GuestRelationFilter;

  factory CopyWith$Input$GuestRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestRelationFilter;

  TRes call({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  });
  CopyWith$Input$GuestWhereInput<TRes> get $is;
  CopyWith$Input$GuestWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$GuestRelationFilter<TRes>
    implements CopyWith$Input$GuestRelationFilter<TRes> {
  _CopyWithImpl$Input$GuestRelationFilter(
    this._instance,
    this._then,
  );

  final Input$GuestRelationFilter _instance;

  final TRes Function(Input$GuestRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$GuestRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$GuestWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$GuestRelationFilter<TRes>
    implements CopyWith$Input$GuestRelationFilter<TRes> {
  _CopyWithStubImpl$Input$GuestRelationFilter(this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get $is =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get isNot =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestScalarWhereInput {
  factory Input$GuestScalarWhereInput({
    List<Input$GuestScalarWhereInput>? AND,
    List<Input$GuestScalarWhereInput>? OR,
    List<Input$GuestScalarWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
  }) =>
      Input$GuestScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (groupMemberOfId != null) r'groupMemberOfId': groupMemberOfId,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestScalarWhereInput._(this._$data);

  factory Input$GuestScalarWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$GuestScalarWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$GuestScalarWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$GuestScalarWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFilter.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$FloatNullableFilter.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = data['groupMemberOfId'];
      result$data['groupMemberOfId'] = l$groupMemberOfId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$groupMemberOfId as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusNullableFilter.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    return Input$GuestScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$GuestScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$GuestScalarWhereInput>?);
  List<Input$GuestScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$GuestScalarWhereInput>?);
  List<Input$GuestScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$GuestScalarWhereInput>?);
  Input$StringFilter? get id => (_$data['id'] as Input$StringFilter?);
  Input$StringNullableFilter? get source =>
      (_$data['source'] as Input$StringNullableFilter?);
  Input$StringFilter? get invitationName =>
      (_$data['invitationName'] as Input$StringFilter?);
  Input$StringNullableFilter? get contactList =>
      (_$data['contactList'] as Input$StringNullableFilter?);
  Input$FloatNullableFilter? get whatsapp =>
      (_$data['whatsapp'] as Input$FloatNullableFilter?);
  Input$StringNullableFilter? get category =>
      (_$data['category'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get $class =>
      (_$data['class'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get seat =>
      (_$data['seat'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get studio =>
      (_$data['studio'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get showTime =>
      (_$data['showTime'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get rejectionReason =>
      (_$data['rejectionReason'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$DateTimeNullableFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeNullableFilter? get deletedAt =>
      (_$data['deletedAt'] as Input$DateTimeNullableFilter?);
  Input$StringNullableFilter? get groupMemberOfId =>
      (_$data['groupMemberOfId'] as Input$StringNullableFilter?);
  Input$EnumConfirmationStatusNullableFilter? get confirmationStatus =>
      (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = groupMemberOfId;
      result$data['groupMemberOfId'] = l$groupMemberOfId?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestScalarWhereInput<Input$GuestScalarWhereInput>
      get copyWith => CopyWith$Input$GuestScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$groupMemberOfId = groupMemberOfId;
    final lOther$groupMemberOfId = other.groupMemberOfId;
    if (_$data.containsKey('groupMemberOfId') !=
        other._$data.containsKey('groupMemberOfId')) {
      return false;
    }
    if (l$groupMemberOfId != lOther$groupMemberOfId) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$groupMemberOfId = groupMemberOfId;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('groupMemberOfId') ? l$groupMemberOfId : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestScalarWhereInput<TRes> {
  factory CopyWith$Input$GuestScalarWhereInput(
    Input$GuestScalarWhereInput instance,
    TRes Function(Input$GuestScalarWhereInput) then,
  ) = _CopyWithImpl$Input$GuestScalarWhereInput;

  factory CopyWith$Input$GuestScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestScalarWhereInput;

  TRes call({
    List<Input$GuestScalarWhereInput>? AND,
    List<Input$GuestScalarWhereInput>? OR,
    List<Input$GuestScalarWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
  });
  TRes AND(
      Iterable<Input$GuestScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$GuestScalarWhereInput<
                      Input$GuestScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$GuestScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$GuestScalarWhereInput<
                      Input$GuestScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$GuestScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$GuestScalarWhereInput<
                      Input$GuestScalarWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get id;
  CopyWith$Input$StringNullableFilter<TRes> get source;
  CopyWith$Input$StringFilter<TRes> get invitationName;
  CopyWith$Input$StringNullableFilter<TRes> get contactList;
  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp;
  CopyWith$Input$StringNullableFilter<TRes> get category;
  CopyWith$Input$StringNullableFilter<TRes> get $class;
  CopyWith$Input$StringNullableFilter<TRes> get seat;
  CopyWith$Input$StringNullableFilter<TRes> get studio;
  CopyWith$Input$StringNullableFilter<TRes> get showTime;
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt;
  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId;
  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus;
}

class _CopyWithImpl$Input$GuestScalarWhereInput<TRes>
    implements CopyWith$Input$GuestScalarWhereInput<TRes> {
  _CopyWithImpl$Input$GuestScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$GuestScalarWhereInput _instance;

  final TRes Function(Input$GuestScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? groupMemberOfId = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$GuestScalarWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$GuestScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$GuestScalarWhereInput>?),
        if (id != _undefined) 'id': (id as Input$StringFilter?),
        if (source != _undefined)
          'source': (source as Input$StringNullableFilter?),
        if (invitationName != _undefined)
          'invitationName': (invitationName as Input$StringFilter?),
        if (contactList != _undefined)
          'contactList': (contactList as Input$StringNullableFilter?),
        if (whatsapp != _undefined)
          'whatsapp': (whatsapp as Input$FloatNullableFilter?),
        if (category != _undefined)
          'category': (category as Input$StringNullableFilter?),
        if ($class != _undefined)
          'class': ($class as Input$StringNullableFilter?),
        if (seat != _undefined) 'seat': (seat as Input$StringNullableFilter?),
        if (studio != _undefined)
          'studio': (studio as Input$StringNullableFilter?),
        if (showTime != _undefined)
          'showTime': (showTime as Input$StringNullableFilter?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeNullableFilter?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$DateTimeNullableFilter?),
        if (groupMemberOfId != _undefined)
          'groupMemberOfId': (groupMemberOfId as Input$StringNullableFilter?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusNullableFilter?),
      }));
  TRes AND(
          Iterable<Input$GuestScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestScalarWhereInput<
                          Input$GuestScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$GuestScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$GuestScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestScalarWhereInput<
                          Input$GuestScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$GuestScalarWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$GuestScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestScalarWhereInput<
                          Input$GuestScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$GuestScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$StringFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFilter<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$FloatNullableFilter.stub(_then(_instance))
        : CopyWith$Input$FloatNullableFilter(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId {
    final local$groupMemberOfId = _instance.groupMemberOfId;
    return local$groupMemberOfId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$groupMemberOfId, (e) => call(groupMemberOfId: e));
  }

  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusNullableFilter.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusNullableFilter(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }
}

class _CopyWithStubImpl$Input$GuestScalarWhereInput<TRes>
    implements CopyWith$Input$GuestScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$GuestScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$GuestScalarWhereInput>? AND,
    List<Input$GuestScalarWhereInput>? OR,
    List<Input$GuestScalarWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get id =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get source =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get invitationName =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get contactList =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp =>
      CopyWith$Input$FloatNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get category =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get $class =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get seat =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get studio =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get showTime =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusNullableFilter.stub(_res);
}

class Input$GuestSumAggregateInput {
  factory Input$GuestSumAggregateInput({bool? whatsapp}) =>
      Input$GuestSumAggregateInput._({
        if (whatsapp != null) r'whatsapp': whatsapp,
      });

  Input$GuestSumAggregateInput._(this._$data);

  factory Input$GuestSumAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as bool?);
    }
    return Input$GuestSumAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get whatsapp => (_$data['whatsapp'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    return result$data;
  }

  CopyWith$Input$GuestSumAggregateInput<Input$GuestSumAggregateInput>
      get copyWith => CopyWith$Input$GuestSumAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestSumAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$whatsapp = whatsapp;
    return Object.hashAll(
        [_$data.containsKey('whatsapp') ? l$whatsapp : const {}]);
  }
}

abstract class CopyWith$Input$GuestSumAggregateInput<TRes> {
  factory CopyWith$Input$GuestSumAggregateInput(
    Input$GuestSumAggregateInput instance,
    TRes Function(Input$GuestSumAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestSumAggregateInput;

  factory CopyWith$Input$GuestSumAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestSumAggregateInput;

  TRes call({bool? whatsapp});
}

class _CopyWithImpl$Input$GuestSumAggregateInput<TRes>
    implements CopyWith$Input$GuestSumAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestSumAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestSumAggregateInput _instance;

  final TRes Function(Input$GuestSumAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? whatsapp = _undefined}) =>
      _then(Input$GuestSumAggregateInput._({
        ..._instance._$data,
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestSumAggregateInput<TRes>
    implements CopyWith$Input$GuestSumAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestSumAggregateInput(this._res);

  TRes _res;

  call({bool? whatsapp}) => _res;
}

class Input$GuestUpdateInput {
  factory Input$GuestUpdateInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      Input$GuestUpdateInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestUpdateInput._(this._$data);

  factory Input$GuestUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableFloatFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .fromJson((l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestUpdateOneWithoutGroupMembersNestedInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeUpdateOneWithoutGuestNestedInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageUpdateOneWithoutGuestNestedInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get source =>
      (_$data['source'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get invitationName =>
      (_$data['invitationName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get contactList =>
      (_$data['contactList']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableFloatFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableFloatFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category =>
      (_$data['category'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get studio =>
      (_$data['studio'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get showTime =>
      (_$data['showTime'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateOneWithoutGroupMembersNestedInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestUpdateOneWithoutGroupMembersNestedInput?);
  Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?);
  Input$QrCodeUpdateOneWithoutGuestNestedInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeUpdateOneWithoutGuestNestedInput?);
  Input$InvitationImageUpdateOneWithoutGuestNestedInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageUpdateOneWithoutGuestNestedInput?);
  Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateInput<Input$GuestUpdateInput> get copyWith =>
      CopyWith$Input$GuestUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateInput<TRes> {
  factory CopyWith$Input$GuestUpdateInput(
    Input$GuestUpdateInput instance,
    TRes Function(Input$GuestUpdateInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateInput;

  factory CopyWith$Input$GuestUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get contactList;
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf;
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers;
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestUpdateInput<TRes>
    implements CopyWith$Input$GuestUpdateInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateInput _instance;

  final TRes Function(Input$GuestUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestUpdateInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (source != _undefined)
          'source': (source as Input$NullableStringFieldUpdateOperationsInput?),
        if (invitationName != _undefined)
          'invitationName':
              (invitationName as Input$StringFieldUpdateOperationsInput?),
        if (contactList != _undefined)
          'contactList':
              (contactList as Input$NullableStringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableFloatFieldUpdateOperationsInput?),
        if (category != _undefined)
          'category':
              (category as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (studio != _undefined)
          'studio': (studio as Input$NullableStringFieldUpdateOperationsInput?),
        if (showTime != _undefined)
          'showTime':
              (showTime as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestUpdateOneWithoutGroupMembersNestedInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeUpdateOneWithoutGuestNestedInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageUpdateOneWithoutGuestNestedInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
            .stub(_then(_instance))
        : CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateInput<TRes>
    implements CopyWith$Input$GuestUpdateInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .stub(_res);
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
              _res);
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
              _res);
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateManyMutationInput {
  factory Input$GuestUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
  }) =>
      Input$GuestUpdateManyMutationInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestUpdateManyMutationInput._(this._$data);

  factory Input$GuestUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableFloatFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .fromJson((l$confirmationStatus as Map<String, dynamic>));
    }
    return Input$GuestUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get source =>
      (_$data['source'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get invitationName =>
      (_$data['invitationName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get contactList =>
      (_$data['contactList']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableFloatFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableFloatFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category =>
      (_$data['category'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get studio =>
      (_$data['studio'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get showTime =>
      (_$data['showTime'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateManyMutationInput<
          Input$GuestUpdateManyMutationInput>
      get copyWith => CopyWith$Input$GuestUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$GuestUpdateManyMutationInput(
    Input$GuestUpdateManyMutationInput instance,
    TRes Function(Input$GuestUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateManyMutationInput;

  factory CopyWith$Input$GuestUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get contactList;
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
}

class _CopyWithImpl$Input$GuestUpdateManyMutationInput<TRes>
    implements CopyWith$Input$GuestUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateManyMutationInput _instance;

  final TRes Function(Input$GuestUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestUpdateManyMutationInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (source != _undefined)
          'source': (source as Input$NullableStringFieldUpdateOperationsInput?),
        if (invitationName != _undefined)
          'invitationName':
              (invitationName as Input$StringFieldUpdateOperationsInput?),
        if (contactList != _undefined)
          'contactList':
              (contactList as Input$NullableStringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableFloatFieldUpdateOperationsInput?),
        if (category != _undefined)
          'category':
              (category as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (studio != _undefined)
          'studio': (studio as Input$NullableStringFieldUpdateOperationsInput?),
        if (showTime != _undefined)
          'showTime':
              (showTime as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
            .stub(_then(_instance))
        : CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateManyMutationInput<TRes>
    implements CopyWith$Input$GuestUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .stub(_res);
}

class Input$GuestUpdateManyWithoutGroupMemberOfNestedInput {
  factory Input$GuestUpdateManyWithoutGroupMemberOfNestedInput({
    List<Input$GuestCreateWithoutGroupMemberOfInput>? create,
    List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? connectOrCreate,
    List<Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>? upsert,
    Input$GuestCreateManyGroupMemberOfInputEnvelope? createMany,
    List<Input$GuestWhereUniqueInput>? $set,
    List<Input$GuestWhereUniqueInput>? disconnect,
    List<Input$GuestWhereUniqueInput>? delete,
    List<Input$GuestWhereUniqueInput>? connect,
    List<Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>? update,
    List<Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>? updateMany,
    List<Input$GuestScalarWhereInput>? deleteMany,
  }) =>
      Input$GuestUpdateManyWithoutGroupMemberOfNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (createMany != null) r'createMany': createMany,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$GuestUpdateManyWithoutGroupMemberOfNestedInput._(this._$data);

  factory Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$GuestCreateWithoutGroupMemberOfInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$GuestCreateOrConnectWithoutGroupMemberOfInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) => Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$GuestCreateManyGroupMemberOfInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereUniqueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereUniqueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereUniqueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereUniqueInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) => Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) =>
              Input$GuestScalarWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$GuestUpdateManyWithoutGroupMemberOfNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$GuestCreateWithoutGroupMemberOfInput>? get create =>
      (_$data['create'] as List<Input$GuestCreateWithoutGroupMemberOfInput>?);
  List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>?);
  List<Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>? get upsert =>
      (_$data['upsert']
          as List<Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>?);
  Input$GuestCreateManyGroupMemberOfInputEnvelope? get createMany =>
      (_$data['createMany']
          as Input$GuestCreateManyGroupMemberOfInputEnvelope?);
  List<Input$GuestWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$GuestWhereUniqueInput>?);
  List<Input$GuestWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$GuestWhereUniqueInput>?);
  List<Input$GuestWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$GuestWhereUniqueInput>?);
  List<Input$GuestWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$GuestWhereUniqueInput>?);
  List<Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>? get update =>
      (_$data['update']
          as List<Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>?);
  List<Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>?
      get updateMany => (_$data['updateMany']
          as List<Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>?);
  List<Input$GuestScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$GuestScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<
          Input$GuestUpdateManyWithoutGroupMemberOfNestedInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateManyWithoutGroupMemberOfNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput instance,
    TRes Function(Input$GuestUpdateManyWithoutGroupMemberOfNestedInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput;

  factory CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput;

  TRes call({
    List<Input$GuestCreateWithoutGroupMemberOfInput>? create,
    List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? connectOrCreate,
    List<Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>? upsert,
    Input$GuestCreateManyGroupMemberOfInputEnvelope? createMany,
    List<Input$GuestWhereUniqueInput>? $set,
    List<Input$GuestWhereUniqueInput>? disconnect,
    List<Input$GuestWhereUniqueInput>? delete,
    List<Input$GuestWhereUniqueInput>? connect,
    List<Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>? update,
    List<Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>? updateMany,
    List<Input$GuestScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$GuestCreateWithoutGroupMemberOfInput>? Function(
              Iterable<
                  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<
                      Input$GuestCreateWithoutGroupMemberOfInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? Function(
              Iterable<
                  CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<
                      Input$GuestCreateOrConnectWithoutGroupMemberOfInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>? Function(
              Iterable<
                  CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput<
                      Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>>?)
          _fn);
  CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes> get createMany;
  TRes $set(
      Iterable<Input$GuestWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$GuestWhereUniqueInput<
                      Input$GuestWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$GuestWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$GuestWhereUniqueInput<
                      Input$GuestWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$GuestWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$GuestWhereUniqueInput<
                      Input$GuestWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$GuestWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$GuestWhereUniqueInput<
                      Input$GuestWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>? Function(
              Iterable<
                  CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput<
                      Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>? Function(
              Iterable<
                  CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput<
                      Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$GuestScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$GuestScalarWhereInput<
                      Input$GuestScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
    implements
        CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateManyWithoutGroupMemberOfNestedInput _instance;

  final TRes Function(Input$GuestUpdateManyWithoutGroupMemberOfNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? createMany = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$GuestUpdateManyWithoutGroupMemberOfNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$GuestCreateWithoutGroupMemberOfInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$GuestCreateManyGroupMemberOfInputEnvelope?),
        if ($set != _undefined)
          'set': ($set as List<Input$GuestWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as List<Input$GuestWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$GuestWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$GuestWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>?),
        if (deleteMany != _undefined)
          'deleteMany': (deleteMany as List<Input$GuestScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$GuestCreateWithoutGroupMemberOfInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<
                          Input$GuestCreateWithoutGroupMemberOfInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$GuestCreateWithoutGroupMemberOfInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput<
                          Input$GuestCreateOrConnectWithoutGroupMemberOfInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$GuestCreateOrConnectWithoutGroupMemberOfInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput<
                          Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes>
      get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes $set(
          Iterable<Input$GuestWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereUniqueInput<
                          Input$GuestWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(
              _instance.$set?.map((e) => CopyWith$Input$GuestWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$GuestWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereUniqueInput<
                          Input$GuestWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$GuestWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$GuestWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereUniqueInput<
                          Input$GuestWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(
              _instance.delete?.map((e) => CopyWith$Input$GuestWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$GuestWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereUniqueInput<
                          Input$GuestWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$GuestWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput<
                          Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput<
                          Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$GuestScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestScalarWhereInput<
                          Input$GuestScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$GuestScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$GuestCreateWithoutGroupMemberOfInput>? create,
    List<Input$GuestCreateOrConnectWithoutGroupMemberOfInput>? connectOrCreate,
    List<Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>? upsert,
    Input$GuestCreateManyGroupMemberOfInputEnvelope? createMany,
    List<Input$GuestWhereUniqueInput>? $set,
    List<Input$GuestWhereUniqueInput>? disconnect,
    List<Input$GuestWhereUniqueInput>? delete,
    List<Input$GuestWhereUniqueInput>? connect,
    List<Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>? update,
    List<Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>? updateMany,
    List<Input$GuestScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope<TRes>
      get createMany =>
          CopyWith$Input$GuestCreateManyGroupMemberOfInputEnvelope.stub(_res);
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput {
  factory Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput({
    required Input$GuestScalarWhereInput where,
    required Input$GuestUpdateManyMutationInput data,
  }) =>
      Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput._({
        r'where': where,
        r'data': data,
      });

  Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput._(this._$data);

  factory Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestScalarWhereInput.fromJson((l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestScalarWhereInput get where =>
      (_$data['where'] as Input$GuestScalarWhereInput);
  Input$GuestUpdateManyMutationInput get data =>
      (_$data['data'] as Input$GuestUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput<
          Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput(
    Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput instance,
    TRes Function(Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput;

  factory CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput;

  TRes call({
    Input$GuestScalarWhereInput? where,
    Input$GuestUpdateManyMutationInput? data,
  });
  CopyWith$Input$GuestScalarWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput _instance;

  final TRes Function(Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateManyMutationInput),
      }));
  CopyWith$Input$GuestScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateManyWithWhereWithoutGroupMemberOfInput(
      this._res);

  TRes _res;

  call({
    Input$GuestScalarWhereInput? where,
    Input$GuestUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestScalarWhereInput<TRes> get where =>
      CopyWith$Input$GuestScalarWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$GuestUpdateManyMutationInput.stub(_res);
}

class Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput {
  factory Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput({
    Input$GuestCreateWithoutInvitationImageInput? create,
    Input$GuestCreateOrConnectWithoutInvitationImageInput? connectOrCreate,
    Input$GuestUpsertWithoutInvitationImageInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput? update,
  }) =>
      Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput._(this._$data);

  factory Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutInvitationImageInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutInvitationImageInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$GuestUpsertWithoutInvitationImageInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutInvitationImageInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutInvitationImageInput?);
  Input$GuestCreateOrConnectWithoutInvitationImageInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutInvitationImageInput?);
  Input$GuestUpsertWithoutInvitationImageInput? get upsert =>
      (_$data['upsert'] as Input$GuestUpsertWithoutInvitationImageInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput? get update =>
      (_$data['update']
          as Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<
          Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput(
    Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput instance,
    TRes Function(Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput;

  factory CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput;

  TRes call({
    Input$GuestCreateWithoutInvitationImageInput? create,
    Input$GuestCreateOrConnectWithoutInvitationImageInput? connectOrCreate,
    Input$GuestUpsertWithoutInvitationImageInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput? update,
  });
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestUpsertWithoutInvitationImageInput<TRes> get upsert;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<TRes>
      get update;
}

class _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput _instance;

  final TRes Function(
      Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutInvitationImageInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutInvitationImageInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$GuestUpsertWithoutInvitationImageInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
        if (update != _undefined)
          'update': (update
              as Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput?),
      }));
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutInvitationImageInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutInvitationImageInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestUpsertWithoutInvitationImageInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$GuestUpsertWithoutInvitationImageInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpsertWithoutInvitationImageInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput
            .stub(_then(_instance))
        : CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutInvitationImageInput? create,
    Input$GuestCreateOrConnectWithoutInvitationImageInput? connectOrCreate,
    Input$GuestUpsertWithoutInvitationImageInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput? update,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutInvitationImageInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutInvitationImageInput.stub(
              _res);
  CopyWith$Input$GuestUpsertWithoutInvitationImageInput<TRes> get upsert =>
      CopyWith$Input$GuestUpsertWithoutInvitationImageInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<TRes>
      get update =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput
              .stub(_res);
}

class Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput {
  factory Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput({
    Input$GuestCreateWithoutQrcodeInput? create,
    Input$GuestCreateOrConnectWithoutQrcodeInput? connectOrCreate,
    Input$GuestUpsertWithoutQrcodeInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutQrcodeInput? update,
  }) =>
      Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput._(this._$data);

  factory Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutQrcodeInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutQrcodeInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$GuestUpsertWithoutQrcodeInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$GuestUpdateToOneWithWhereWithoutQrcodeInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutQrcodeInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutQrcodeInput?);
  Input$GuestCreateOrConnectWithoutQrcodeInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutQrcodeInput?);
  Input$GuestUpsertWithoutQrcodeInput? get upsert =>
      (_$data['upsert'] as Input$GuestUpsertWithoutQrcodeInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Input$GuestUpdateToOneWithWhereWithoutQrcodeInput? get update =>
      (_$data['update'] as Input$GuestUpdateToOneWithWhereWithoutQrcodeInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<
          Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput(
    Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput instance,
    TRes Function(Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput;

  factory CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput;

  TRes call({
    Input$GuestCreateWithoutQrcodeInput? create,
    Input$GuestCreateOrConnectWithoutQrcodeInput? connectOrCreate,
    Input$GuestUpsertWithoutQrcodeInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutQrcodeInput? update,
  });
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestUpsertWithoutQrcodeInput<TRes> get upsert;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<TRes> get update;
}

class _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput _instance;

  final TRes Function(Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutQrcodeInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutQrcodeInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$GuestUpsertWithoutQrcodeInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$GuestUpdateToOneWithWhereWithoutQrcodeInput?),
      }));
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutQrcodeInput.stub(_then(_instance))
        : CopyWith$Input$GuestCreateWithoutQrcodeInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestUpsertWithoutQrcodeInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$GuestUpsertWithoutQrcodeInput.stub(_then(_instance))
        : CopyWith$Input$GuestUpsertWithoutQrcodeInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutQrcodeInput? create,
    Input$GuestCreateOrConnectWithoutQrcodeInput? connectOrCreate,
    Input$GuestUpsertWithoutQrcodeInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutQrcodeInput? update,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutQrcodeInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutQrcodeInput.stub(_res);
  CopyWith$Input$GuestUpsertWithoutQrcodeInput<TRes> get upsert =>
      CopyWith$Input$GuestUpsertWithoutQrcodeInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<TRes> get update =>
      CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput.stub(_res);
}

class Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput {
  factory Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput({
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappStatusesInput? connectOrCreate,
    Input$GuestUpsertWithoutWhatsappStatusesInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput? update,
  }) =>
      Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput._(this._$data);

  factory Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutWhatsappStatusesInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutWhatsappStatusesInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$GuestUpsertWithoutWhatsappStatusesInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput
              .fromJson((l$update as Map<String, dynamic>));
    }
    return Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutWhatsappStatusesInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutWhatsappStatusesInput?);
  Input$GuestCreateOrConnectWithoutWhatsappStatusesInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutWhatsappStatusesInput?);
  Input$GuestUpsertWithoutWhatsappStatusesInput? get upsert =>
      (_$data['upsert'] as Input$GuestUpsertWithoutWhatsappStatusesInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput? get update =>
      (_$data['update']
          as Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<
          Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput(
    Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput instance,
    TRes Function(
            Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput;

  factory CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput;

  TRes call({
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappStatusesInput? connectOrCreate,
    Input$GuestUpsertWithoutWhatsappStatusesInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput? update,
  });
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput<TRes> get upsert;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<TRes>
      get update;
}

class _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput
      _instance;

  final TRes Function(
      Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutWhatsappStatusesInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutWhatsappStatusesInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$GuestUpsertWithoutWhatsappStatusesInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
        if (update != _undefined)
          'update': (update
              as Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput?),
      }));
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput
            .stub(_then(_instance))
        : CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappStatusesInput? connectOrCreate,
    Input$GuestUpsertWithoutWhatsappStatusesInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput? update,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutWhatsappStatusesInput.stub(
              _res);
  CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput<TRes> get upsert =>
      CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<TRes>
      get update =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput
              .stub(_res);
}

class Input$GuestUpdateOneWithoutGroupMembersNestedInput {
  factory Input$GuestUpdateOneWithoutGroupMembersNestedInput({
    Input$GuestCreateWithoutGroupMembersInput? create,
    Input$GuestCreateOrConnectWithoutGroupMembersInput? connectOrCreate,
    Input$GuestUpsertWithoutGroupMembersInput? upsert,
    Input$GuestWhereInput? disconnect,
    Input$GuestWhereInput? delete,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput? update,
  }) =>
      Input$GuestUpdateOneWithoutGroupMembersNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$GuestUpdateOneWithoutGroupMembersNestedInput._(this._$data);

  factory Input$GuestUpdateOneWithoutGroupMembersNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutGroupMembersInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutGroupMembersInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$GuestUpsertWithoutGroupMembersInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$GuestWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$GuestWhereInput.fromJson((l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$GuestUpdateOneWithoutGroupMembersNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutGroupMembersInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutGroupMembersInput?);
  Input$GuestCreateOrConnectWithoutGroupMembersInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutGroupMembersInput?);
  Input$GuestUpsertWithoutGroupMembersInput? get upsert =>
      (_$data['upsert'] as Input$GuestUpsertWithoutGroupMembersInput?);
  Input$GuestWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$GuestWhereInput?);
  Input$GuestWhereInput? get delete =>
      (_$data['delete'] as Input$GuestWhereInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput? get update =>
      (_$data['update']
          as Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<
          Input$GuestUpdateOneWithoutGroupMembersNestedInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateOneWithoutGroupMembersNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
    Input$GuestUpdateOneWithoutGroupMembersNestedInput instance,
    TRes Function(Input$GuestUpdateOneWithoutGroupMembersNestedInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateOneWithoutGroupMembersNestedInput;

  factory CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateOneWithoutGroupMembersNestedInput;

  TRes call({
    Input$GuestCreateWithoutGroupMembersInput? create,
    Input$GuestCreateOrConnectWithoutGroupMembersInput? connectOrCreate,
    Input$GuestUpsertWithoutGroupMembersInput? upsert,
    Input$GuestWhereInput? disconnect,
    Input$GuestWhereInput? delete,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput? update,
  });
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestUpsertWithoutGroupMembersInput<TRes> get upsert;
  CopyWith$Input$GuestWhereInput<TRes> get disconnect;
  CopyWith$Input$GuestWhereInput<TRes> get delete;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<TRes>
      get update;
}

class _CopyWithImpl$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
    implements
        CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateOneWithoutGroupMembersNestedInput _instance;

  final TRes Function(Input$GuestUpdateOneWithoutGroupMembersNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$GuestUpdateOneWithoutGroupMembersNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutGroupMembersInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutGroupMembersInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$GuestUpsertWithoutGroupMembersInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$GuestWhereInput?),
        if (delete != _undefined) 'delete': (delete as Input$GuestWhereInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
        if (update != _undefined)
          'update': (update
              as Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput?),
      }));
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutGroupMembersInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestUpsertWithoutGroupMembersInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$GuestUpsertWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpsertWithoutGroupMembersInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
    implements
        CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutGroupMembersInput? create,
    Input$GuestCreateOrConnectWithoutGroupMembersInput? connectOrCreate,
    Input$GuestUpsertWithoutGroupMembersInput? upsert,
    Input$GuestWhereInput? disconnect,
    Input$GuestWhereInput? delete,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput? update,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutGroupMembersInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutGroupMembersInput.stub(
              _res);
  CopyWith$Input$GuestUpsertWithoutGroupMembersInput<TRes> get upsert =>
      CopyWith$Input$GuestUpsertWithoutGroupMembersInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get disconnect =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get delete =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<TRes>
      get update =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput.stub(
              _res);
}

class Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput {
  factory Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput({
    Input$GuestWhereInput? where,
    required Input$GuestUpdateWithoutGroupMembersInput data,
  }) =>
      Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput._(this._$data);

  factory Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateWithoutGroupMembersInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Input$GuestUpdateWithoutGroupMembersInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutGroupMembersInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<
          Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput(
    Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput instance,
    TRes Function(Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput;

  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput;

  TRes call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutGroupMembersInput? data,
  });
  CopyWith$Input$GuestWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput _instance;

  final TRes Function(Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutGroupMembersInput),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutGroupMembersInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutGroupMembersInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutGroupMembersInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutGroupMembersInput.stub(_res);
}

class Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput {
  factory Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput({
    Input$GuestWhereInput? where,
    required Input$GuestUpdateWithoutInvitationImageInput data,
  }) =>
      Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput._(this._$data);

  factory Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateWithoutInvitationImageInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Input$GuestUpdateWithoutInvitationImageInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutInvitationImageInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<
          Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput(
    Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput instance,
    TRes Function(Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput;

  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput;

  TRes call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutInvitationImageInput? data,
  });
  CopyWith$Input$GuestWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput _instance;

  final TRes Function(
      Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutInvitationImageInput),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutInvitationImageInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutInvitationImageInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutInvitationImageInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutInvitationImageInput.stub(_res);
}

class Input$GuestUpdateToOneWithWhereWithoutQrcodeInput {
  factory Input$GuestUpdateToOneWithWhereWithoutQrcodeInput({
    Input$GuestWhereInput? where,
    required Input$GuestUpdateWithoutQrcodeInput data,
  }) =>
      Input$GuestUpdateToOneWithWhereWithoutQrcodeInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$GuestUpdateToOneWithWhereWithoutQrcodeInput._(this._$data);

  factory Input$GuestUpdateToOneWithWhereWithoutQrcodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateWithoutQrcodeInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateToOneWithWhereWithoutQrcodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Input$GuestUpdateWithoutQrcodeInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutQrcodeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<
          Input$GuestUpdateToOneWithWhereWithoutQrcodeInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateToOneWithWhereWithoutQrcodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput(
    Input$GuestUpdateToOneWithWhereWithoutQrcodeInput instance,
    TRes Function(Input$GuestUpdateToOneWithWhereWithoutQrcodeInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput;

  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput;

  TRes call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutQrcodeInput? data,
  });
  CopyWith$Input$GuestWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateToOneWithWhereWithoutQrcodeInput _instance;

  final TRes Function(Input$GuestUpdateToOneWithWhereWithoutQrcodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateToOneWithWhereWithoutQrcodeInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutQrcodeInput),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutQrcodeInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodeInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutQrcodeInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutQrcodeInput.stub(_res);
}

class Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput {
  factory Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput({
    Input$GuestWhereInput? where,
    required Input$GuestUpdateWithoutWhatsappStatusesInput data,
  }) =>
      Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput._(this._$data);

  factory Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] =
        Input$GuestUpdateWithoutWhatsappStatusesInput.fromJson(
            (l$data as Map<String, dynamic>));
    return Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Input$GuestUpdateWithoutWhatsappStatusesInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutWhatsappStatusesInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<
          Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput(
    Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput instance,
    TRes Function(Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput;

  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput;

  TRes call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutWhatsappStatusesInput? data,
  });
  CopyWith$Input$GuestWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput _instance;

  final TRes Function(
      Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutWhatsappStatusesInput),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappStatusesInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutWhatsappStatusesInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput.stub(_res);
}

class Input$GuestUpdateWithoutGroupMemberOfInput {
  factory Input$GuestUpdateWithoutGroupMemberOfInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      Input$GuestUpdateWithoutGroupMemberOfInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestUpdateWithoutGroupMemberOfInput._(this._$data);

  factory Input$GuestUpdateWithoutGroupMemberOfInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableFloatFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .fromJson((l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeUpdateOneWithoutGuestNestedInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageUpdateOneWithoutGuestNestedInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutGroupMemberOfInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get source =>
      (_$data['source'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get invitationName =>
      (_$data['invitationName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get contactList =>
      (_$data['contactList']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableFloatFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableFloatFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category =>
      (_$data['category'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get studio =>
      (_$data['studio'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get showTime =>
      (_$data['showTime'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?);
  Input$QrCodeUpdateOneWithoutGuestNestedInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeUpdateOneWithoutGuestNestedInput?);
  Input$InvitationImageUpdateOneWithoutGuestNestedInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageUpdateOneWithoutGuestNestedInput?);
  Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<
          Input$GuestUpdateWithoutGroupMemberOfInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutGroupMemberOfInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput(
    Input$GuestUpdateWithoutGroupMemberOfInput instance,
    TRes Function(Input$GuestUpdateWithoutGroupMemberOfInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutGroupMemberOfInput;

  factory CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutGroupMemberOfInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get contactList;
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers;
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestUpdateWithoutGroupMemberOfInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutGroupMemberOfInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutGroupMemberOfInput _instance;

  final TRes Function(Input$GuestUpdateWithoutGroupMemberOfInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutGroupMemberOfInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (source != _undefined)
          'source': (source as Input$NullableStringFieldUpdateOperationsInput?),
        if (invitationName != _undefined)
          'invitationName':
              (invitationName as Input$StringFieldUpdateOperationsInput?),
        if (contactList != _undefined)
          'contactList':
              (contactList as Input$NullableStringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableFloatFieldUpdateOperationsInput?),
        if (category != _undefined)
          'category':
              (category as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (studio != _undefined)
          'studio': (studio as Input$NullableStringFieldUpdateOperationsInput?),
        if (showTime != _undefined)
          'showTime':
              (showTime as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeUpdateOneWithoutGuestNestedInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageUpdateOneWithoutGuestNestedInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
            .stub(_then(_instance))
        : CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutGroupMemberOfInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutGroupMemberOfInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .stub(_res);
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
              _res);
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateWithoutGroupMembersInput {
  factory Input$GuestUpdateWithoutGroupMembersInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      Input$GuestUpdateWithoutGroupMembersInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestUpdateWithoutGroupMembersInput._(this._$data);

  factory Input$GuestUpdateWithoutGroupMembersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableFloatFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .fromJson((l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestUpdateOneWithoutGroupMembersNestedInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeUpdateOneWithoutGuestNestedInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageUpdateOneWithoutGuestNestedInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutGroupMembersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get source =>
      (_$data['source'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get invitationName =>
      (_$data['invitationName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get contactList =>
      (_$data['contactList']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableFloatFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableFloatFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category =>
      (_$data['category'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get studio =>
      (_$data['studio'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get showTime =>
      (_$data['showTime'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateOneWithoutGroupMembersNestedInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestUpdateOneWithoutGroupMembersNestedInput?);
  Input$QrCodeUpdateOneWithoutGuestNestedInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeUpdateOneWithoutGuestNestedInput?);
  Input$InvitationImageUpdateOneWithoutGuestNestedInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageUpdateOneWithoutGuestNestedInput?);
  Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutGroupMembersInput<
          Input$GuestUpdateWithoutGroupMembersInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutGroupMembersInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutGroupMembersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutGroupMembersInput(
    Input$GuestUpdateWithoutGroupMembersInput instance,
    TRes Function(Input$GuestUpdateWithoutGroupMembersInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutGroupMembersInput;

  factory CopyWith$Input$GuestUpdateWithoutGroupMembersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutGroupMembersInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get contactList;
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf;
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestUpdateWithoutGroupMembersInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutGroupMembersInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutGroupMembersInput _instance;

  final TRes Function(Input$GuestUpdateWithoutGroupMembersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutGroupMembersInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (source != _undefined)
          'source': (source as Input$NullableStringFieldUpdateOperationsInput?),
        if (invitationName != _undefined)
          'invitationName':
              (invitationName as Input$StringFieldUpdateOperationsInput?),
        if (contactList != _undefined)
          'contactList':
              (contactList as Input$NullableStringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableFloatFieldUpdateOperationsInput?),
        if (category != _undefined)
          'category':
              (category as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (studio != _undefined)
          'studio': (studio as Input$NullableStringFieldUpdateOperationsInput?),
        if (showTime != _undefined)
          'showTime':
              (showTime as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestUpdateOneWithoutGroupMembersNestedInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeUpdateOneWithoutGuestNestedInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageUpdateOneWithoutGuestNestedInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
            .stub(_then(_instance))
        : CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutGroupMembersInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutGroupMembersInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .stub(_res);
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
              _res);
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateWithoutInvitationImageInput {
  factory Input$GuestUpdateWithoutInvitationImageInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      Input$GuestUpdateWithoutInvitationImageInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestUpdateWithoutInvitationImageInput._(this._$data);

  factory Input$GuestUpdateWithoutInvitationImageInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableFloatFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .fromJson((l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestUpdateOneWithoutGroupMembersNestedInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeUpdateOneWithoutGuestNestedInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutInvitationImageInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get source =>
      (_$data['source'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get invitationName =>
      (_$data['invitationName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get contactList =>
      (_$data['contactList']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableFloatFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableFloatFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category =>
      (_$data['category'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get studio =>
      (_$data['studio'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get showTime =>
      (_$data['showTime'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateOneWithoutGroupMembersNestedInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestUpdateOneWithoutGroupMembersNestedInput?);
  Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?);
  Input$QrCodeUpdateOneWithoutGuestNestedInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeUpdateOneWithoutGuestNestedInput?);
  Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutInvitationImageInput<
          Input$GuestUpdateWithoutInvitationImageInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutInvitationImageInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutInvitationImageInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutInvitationImageInput(
    Input$GuestUpdateWithoutInvitationImageInput instance,
    TRes Function(Input$GuestUpdateWithoutInvitationImageInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutInvitationImageInput;

  factory CopyWith$Input$GuestUpdateWithoutInvitationImageInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutInvitationImageInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get contactList;
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf;
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers;
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode;
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestUpdateWithoutInvitationImageInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutInvitationImageInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutInvitationImageInput _instance;

  final TRes Function(Input$GuestUpdateWithoutInvitationImageInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutInvitationImageInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (source != _undefined)
          'source': (source as Input$NullableStringFieldUpdateOperationsInput?),
        if (invitationName != _undefined)
          'invitationName':
              (invitationName as Input$StringFieldUpdateOperationsInput?),
        if (contactList != _undefined)
          'contactList':
              (contactList as Input$NullableStringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableFloatFieldUpdateOperationsInput?),
        if (category != _undefined)
          'category':
              (category as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (studio != _undefined)
          'studio': (studio as Input$NullableStringFieldUpdateOperationsInput?),
        if (showTime != _undefined)
          'showTime':
              (showTime as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestUpdateOneWithoutGroupMembersNestedInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeUpdateOneWithoutGuestNestedInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
            .stub(_then(_instance))
        : CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutInvitationImageInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutInvitationImageInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .stub(_res);
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
              _res);
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateWithoutQrcodeInput {
  factory Input$GuestUpdateWithoutQrcodeInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      Input$GuestUpdateWithoutQrcodeInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestUpdateWithoutQrcodeInput._(this._$data);

  factory Input$GuestUpdateWithoutQrcodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableFloatFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .fromJson((l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestUpdateOneWithoutGroupMembersNestedInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageUpdateOneWithoutGuestNestedInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutQrcodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get source =>
      (_$data['source'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get invitationName =>
      (_$data['invitationName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get contactList =>
      (_$data['contactList']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableFloatFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableFloatFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category =>
      (_$data['category'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get studio =>
      (_$data['studio'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get showTime =>
      (_$data['showTime'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateOneWithoutGroupMembersNestedInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestUpdateOneWithoutGroupMembersNestedInput?);
  Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?);
  Input$InvitationImageUpdateOneWithoutGuestNestedInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageUpdateOneWithoutGuestNestedInput?);
  Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? get whatsappStatuses =>
      (_$data['whatsappStatuses']
          as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutQrcodeInput<
          Input$GuestUpdateWithoutQrcodeInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutQrcodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutQrcodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutQrcodeInput(
    Input$GuestUpdateWithoutQrcodeInput instance,
    TRes Function(Input$GuestUpdateWithoutQrcodeInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutQrcodeInput;

  factory CopyWith$Input$GuestUpdateWithoutQrcodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutQrcodeInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get contactList;
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf;
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers;
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestUpdateWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutQrcodeInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutQrcodeInput _instance;

  final TRes Function(Input$GuestUpdateWithoutQrcodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutQrcodeInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (source != _undefined)
          'source': (source as Input$NullableStringFieldUpdateOperationsInput?),
        if (invitationName != _undefined)
          'invitationName':
              (invitationName as Input$StringFieldUpdateOperationsInput?),
        if (contactList != _undefined)
          'contactList':
              (contactList as Input$NullableStringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableFloatFieldUpdateOperationsInput?),
        if (category != _undefined)
          'category':
              (category as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (studio != _undefined)
          'studio': (studio as Input$NullableStringFieldUpdateOperationsInput?),
        if (showTime != _undefined)
          'showTime':
              (showTime as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestUpdateOneWithoutGroupMembersNestedInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageUpdateOneWithoutGuestNestedInput?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses': (whatsappStatuses
              as Input$WhatsappStatusUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
            .stub(_then(_instance))
        : CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutQrcodeInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput? whatsappStatuses,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .stub(_res);
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
              _res);
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
              _res);
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
              _res);
  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappStatuses =>
          CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateWithoutWhatsappStatusesInput {
  factory Input$GuestUpdateWithoutWhatsappStatusesInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
  }) =>
      Input$GuestUpdateWithoutWhatsappStatusesInput._({
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
      });

  Input$GuestUpdateWithoutWhatsappStatusesInput._(this._$data);

  factory Input$GuestUpdateWithoutWhatsappStatusesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableFloatFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .fromJson((l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestUpdateOneWithoutGroupMembersNestedInput.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeUpdateOneWithoutGuestNestedInput.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageUpdateOneWithoutGuestNestedInput.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutWhatsappStatusesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get source =>
      (_$data['source'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get invitationName =>
      (_$data['invitationName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get contactList =>
      (_$data['contactList']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableFloatFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableFloatFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category =>
      (_$data['category'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get studio =>
      (_$data['studio'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get showTime =>
      (_$data['showTime'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateOneWithoutGroupMembersNestedInput? get groupMemberOf =>
      (_$data['groupMemberOf']
          as Input$GuestUpdateOneWithoutGroupMembersNestedInput?);
  Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? get groupMembers =>
      (_$data['groupMembers']
          as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?);
  Input$QrCodeUpdateOneWithoutGuestNestedInput? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeUpdateOneWithoutGuestNestedInput?);
  Input$InvitationImageUpdateOneWithoutGuestNestedInput? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageUpdateOneWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<
          Input$GuestUpdateWithoutWhatsappStatusesInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutWhatsappStatusesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput(
    Input$GuestUpdateWithoutWhatsappStatusesInput instance,
    TRes Function(Input$GuestUpdateWithoutWhatsappStatusesInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutWhatsappStatusesInput;

  factory CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutWhatsappStatusesInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get contactList;
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf;
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers;
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode;
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage;
}

class _CopyWithImpl$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutWhatsappStatusesInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutWhatsappStatusesInput _instance;

  final TRes Function(Input$GuestUpdateWithoutWhatsappStatusesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutWhatsappStatusesInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (source != _undefined)
          'source': (source as Input$NullableStringFieldUpdateOperationsInput?),
        if (invitationName != _undefined)
          'invitationName':
              (invitationName as Input$StringFieldUpdateOperationsInput?),
        if (contactList != _undefined)
          'contactList':
              (contactList as Input$NullableStringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableFloatFieldUpdateOperationsInput?),
        if (category != _undefined)
          'category':
              (category as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (studio != _undefined)
          'studio': (studio as Input$NullableStringFieldUpdateOperationsInput?),
        if (showTime != _undefined)
          'showTime':
              (showTime as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?),
        if (groupMemberOf != _undefined)
          'groupMemberOf': (groupMemberOf
              as Input$GuestUpdateOneWithoutGroupMembersNestedInput?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers
              as Input$GuestUpdateManyWithoutGroupMemberOfNestedInput?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeUpdateOneWithoutGuestNestedInput?),
        if (invitationImage != _undefined)
          'invitationImage': (invitationImage
              as Input$InvitationImageUpdateOneWithoutGuestNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
            .stub(_then(_instance))
        : CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
            local$invitationImage, (e) => call(invitationImage: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutWhatsappStatusesInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$NullableStringFieldUpdateOperationsInput? source,
    Input$StringFieldUpdateOperationsInput? invitationName,
    Input$NullableStringFieldUpdateOperationsInput? contactList,
    Input$NullableFloatFieldUpdateOperationsInput? whatsapp,
    Input$NullableStringFieldUpdateOperationsInput? category,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? studio,
    Input$NullableStringFieldUpdateOperationsInput? showTime,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput?
        confirmationStatus,
    Input$GuestUpdateOneWithoutGroupMembersNestedInput? groupMemberOf,
    Input$GuestUpdateManyWithoutGroupMemberOfNestedInput? groupMembers,
    Input$QrCodeUpdateOneWithoutGuestNestedInput? qrcode,
    Input$InvitationImageUpdateOneWithoutGuestNestedInput? invitationImage,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get source =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get invitationName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get contactList =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get studio =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get showTime =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
              .stub(_res);
  CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput<TRes>
      get groupMemberOf =>
          CopyWith$Input$GuestUpdateOneWithoutGroupMembersNestedInput.stub(
              _res);
  CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput<TRes>
      get groupMembers =>
          CopyWith$Input$GuestUpdateManyWithoutGroupMemberOfNestedInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> get qrcode =>
      CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput {
  factory Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestUpdateWithoutGroupMemberOfInput data,
  }) =>
      Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput._({
        r'where': where,
        r'data': data,
      });

  Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput._(this._$data);

  factory Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateWithoutGroupMemberOfInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestUpdateWithoutGroupMemberOfInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutGroupMemberOfInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput<
          Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput(
    Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput instance,
    TRes Function(Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput;

  factory CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestUpdateWithoutGroupMemberOfInput? data,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput _instance;

  final TRes Function(Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutGroupMemberOfInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithWhereUniqueWithoutGroupMemberOfInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestUpdateWithoutGroupMemberOfInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput.stub(_res);
}

class Input$GuestUpsertWithoutGroupMembersInput {
  factory Input$GuestUpsertWithoutGroupMembersInput({
    required Input$GuestUpdateWithoutGroupMembersInput update,
    required Input$GuestCreateWithoutGroupMembersInput create,
    Input$GuestWhereInput? where,
  }) =>
      Input$GuestUpsertWithoutGroupMembersInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$GuestUpsertWithoutGroupMembersInput._(this._$data);

  factory Input$GuestUpsertWithoutGroupMembersInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$GuestUpdateWithoutGroupMembersInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutGroupMembersInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$GuestUpsertWithoutGroupMembersInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestUpdateWithoutGroupMembersInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutGroupMembersInput);
  Input$GuestCreateWithoutGroupMembersInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutGroupMembersInput);
  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithoutGroupMembersInput<
          Input$GuestUpsertWithoutGroupMembersInput>
      get copyWith => CopyWith$Input$GuestUpsertWithoutGroupMembersInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithoutGroupMembersInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithoutGroupMembersInput<TRes> {
  factory CopyWith$Input$GuestUpsertWithoutGroupMembersInput(
    Input$GuestUpsertWithoutGroupMembersInput instance,
    TRes Function(Input$GuestUpsertWithoutGroupMembersInput) then,
  ) = _CopyWithImpl$Input$GuestUpsertWithoutGroupMembersInput;

  factory CopyWith$Input$GuestUpsertWithoutGroupMembersInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithoutGroupMembersInput;

  TRes call({
    Input$GuestUpdateWithoutGroupMembersInput? update,
    Input$GuestCreateWithoutGroupMembersInput? create,
    Input$GuestWhereInput? where,
  });
  CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create;
  CopyWith$Input$GuestWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$GuestUpsertWithoutGroupMembersInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutGroupMembersInput<TRes> {
  _CopyWithImpl$Input$GuestUpsertWithoutGroupMembersInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithoutGroupMembersInput _instance;

  final TRes Function(Input$GuestUpsertWithoutGroupMembersInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$GuestUpsertWithoutGroupMembersInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutGroupMembersInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutGroupMembersInput),
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutGroupMembersInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutGroupMembersInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithoutGroupMembersInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutGroupMembersInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithoutGroupMembersInput(this._res);

  TRes _res;

  call({
    Input$GuestUpdateWithoutGroupMembersInput? update,
    Input$GuestCreateWithoutGroupMembersInput? create,
    Input$GuestWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$GuestUpdateWithoutGroupMembersInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutGroupMembersInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutGroupMembersInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutGroupMembersInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestUpsertWithoutInvitationImageInput {
  factory Input$GuestUpsertWithoutInvitationImageInput({
    required Input$GuestUpdateWithoutInvitationImageInput update,
    required Input$GuestCreateWithoutInvitationImageInput create,
    Input$GuestWhereInput? where,
  }) =>
      Input$GuestUpsertWithoutInvitationImageInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$GuestUpsertWithoutInvitationImageInput._(this._$data);

  factory Input$GuestUpsertWithoutInvitationImageInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$GuestUpdateWithoutInvitationImageInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$GuestCreateWithoutInvitationImageInput.fromJson(
            (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$GuestUpsertWithoutInvitationImageInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestUpdateWithoutInvitationImageInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutInvitationImageInput);
  Input$GuestCreateWithoutInvitationImageInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutInvitationImageInput);
  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithoutInvitationImageInput<
          Input$GuestUpsertWithoutInvitationImageInput>
      get copyWith => CopyWith$Input$GuestUpsertWithoutInvitationImageInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithoutInvitationImageInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithoutInvitationImageInput<TRes> {
  factory CopyWith$Input$GuestUpsertWithoutInvitationImageInput(
    Input$GuestUpsertWithoutInvitationImageInput instance,
    TRes Function(Input$GuestUpsertWithoutInvitationImageInput) then,
  ) = _CopyWithImpl$Input$GuestUpsertWithoutInvitationImageInput;

  factory CopyWith$Input$GuestUpsertWithoutInvitationImageInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithoutInvitationImageInput;

  TRes call({
    Input$GuestUpdateWithoutInvitationImageInput? update,
    Input$GuestCreateWithoutInvitationImageInput? create,
    Input$GuestWhereInput? where,
  });
  CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create;
  CopyWith$Input$GuestWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$GuestUpsertWithoutInvitationImageInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutInvitationImageInput<TRes> {
  _CopyWithImpl$Input$GuestUpsertWithoutInvitationImageInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithoutInvitationImageInput _instance;

  final TRes Function(Input$GuestUpsertWithoutInvitationImageInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$GuestUpsertWithoutInvitationImageInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutInvitationImageInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutInvitationImageInput),
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutInvitationImageInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutInvitationImageInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithoutInvitationImageInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutInvitationImageInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithoutInvitationImageInput(this._res);

  TRes _res;

  call({
    Input$GuestUpdateWithoutInvitationImageInput? update,
    Input$GuestCreateWithoutInvitationImageInput? create,
    Input$GuestWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$GuestUpdateWithoutInvitationImageInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutInvitationImageInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutInvitationImageInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutInvitationImageInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestUpsertWithoutQrcodeInput {
  factory Input$GuestUpsertWithoutQrcodeInput({
    required Input$GuestUpdateWithoutQrcodeInput update,
    required Input$GuestCreateWithoutQrcodeInput create,
    Input$GuestWhereInput? where,
  }) =>
      Input$GuestUpsertWithoutQrcodeInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$GuestUpsertWithoutQrcodeInput._(this._$data);

  factory Input$GuestUpsertWithoutQrcodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$GuestUpdateWithoutQrcodeInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutQrcodeInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$GuestUpsertWithoutQrcodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestUpdateWithoutQrcodeInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutQrcodeInput);
  Input$GuestCreateWithoutQrcodeInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutQrcodeInput);
  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithoutQrcodeInput<
          Input$GuestUpsertWithoutQrcodeInput>
      get copyWith => CopyWith$Input$GuestUpsertWithoutQrcodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithoutQrcodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithoutQrcodeInput<TRes> {
  factory CopyWith$Input$GuestUpsertWithoutQrcodeInput(
    Input$GuestUpsertWithoutQrcodeInput instance,
    TRes Function(Input$GuestUpsertWithoutQrcodeInput) then,
  ) = _CopyWithImpl$Input$GuestUpsertWithoutQrcodeInput;

  factory CopyWith$Input$GuestUpsertWithoutQrcodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithoutQrcodeInput;

  TRes call({
    Input$GuestUpdateWithoutQrcodeInput? update,
    Input$GuestCreateWithoutQrcodeInput? create,
    Input$GuestWhereInput? where,
  });
  CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create;
  CopyWith$Input$GuestWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$GuestUpsertWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutQrcodeInput<TRes> {
  _CopyWithImpl$Input$GuestUpsertWithoutQrcodeInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithoutQrcodeInput _instance;

  final TRes Function(Input$GuestUpsertWithoutQrcodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$GuestUpsertWithoutQrcodeInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutQrcodeInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutQrcodeInput),
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutQrcodeInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutQrcodeInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithoutQrcodeInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutQrcodeInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithoutQrcodeInput(this._res);

  TRes _res;

  call({
    Input$GuestUpdateWithoutQrcodeInput? update,
    Input$GuestCreateWithoutQrcodeInput? create,
    Input$GuestWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$GuestUpdateWithoutQrcodeInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutQrcodeInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutQrcodeInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutQrcodeInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestUpsertWithoutWhatsappStatusesInput {
  factory Input$GuestUpsertWithoutWhatsappStatusesInput({
    required Input$GuestUpdateWithoutWhatsappStatusesInput update,
    required Input$GuestCreateWithoutWhatsappStatusesInput create,
    Input$GuestWhereInput? where,
  }) =>
      Input$GuestUpsertWithoutWhatsappStatusesInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$GuestUpsertWithoutWhatsappStatusesInput._(this._$data);

  factory Input$GuestUpsertWithoutWhatsappStatusesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$GuestUpdateWithoutWhatsappStatusesInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$GuestCreateWithoutWhatsappStatusesInput.fromJson(
            (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$GuestUpsertWithoutWhatsappStatusesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestUpdateWithoutWhatsappStatusesInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutWhatsappStatusesInput);
  Input$GuestCreateWithoutWhatsappStatusesInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutWhatsappStatusesInput);
  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput<
          Input$GuestUpsertWithoutWhatsappStatusesInput>
      get copyWith => CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithoutWhatsappStatusesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput<TRes> {
  factory CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput(
    Input$GuestUpsertWithoutWhatsappStatusesInput instance,
    TRes Function(Input$GuestUpsertWithoutWhatsappStatusesInput) then,
  ) = _CopyWithImpl$Input$GuestUpsertWithoutWhatsappStatusesInput;

  factory CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithoutWhatsappStatusesInput;

  TRes call({
    Input$GuestUpdateWithoutWhatsappStatusesInput? update,
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
    Input$GuestWhereInput? where,
  });
  CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create;
  CopyWith$Input$GuestWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$GuestUpsertWithoutWhatsappStatusesInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput<TRes> {
  _CopyWithImpl$Input$GuestUpsertWithoutWhatsappStatusesInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithoutWhatsappStatusesInput _instance;

  final TRes Function(Input$GuestUpsertWithoutWhatsappStatusesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$GuestUpsertWithoutWhatsappStatusesInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutWhatsappStatusesInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutWhatsappStatusesInput),
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithoutWhatsappStatusesInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutWhatsappStatusesInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithoutWhatsappStatusesInput(this._res);

  TRes _res;

  call({
    Input$GuestUpdateWithoutWhatsappStatusesInput? update,
    Input$GuestCreateWithoutWhatsappStatusesInput? create,
    Input$GuestWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutWhatsappStatusesInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutWhatsappStatusesInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput {
  factory Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestUpdateWithoutGroupMemberOfInput update,
    required Input$GuestCreateWithoutGroupMemberOfInput create,
  }) =>
      Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput._(this._$data);

  factory Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$GuestUpdateWithoutGroupMemberOfInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutGroupMemberOfInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestUpdateWithoutGroupMemberOfInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutGroupMemberOfInput);
  Input$GuestCreateWithoutGroupMemberOfInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutGroupMemberOfInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput<
          Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput>
      get copyWith =>
          CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput<
    TRes> {
  factory CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput(
    Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput instance,
    TRes Function(Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput;

  factory CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestUpdateWithoutGroupMemberOfInput? update,
    Input$GuestCreateWithoutGroupMemberOfInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput<
        TRes>
    implements
        CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput _instance;

  final TRes Function(Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutGroupMemberOfInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutGroupMemberOfInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutGroupMemberOfInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput<
        TRes>
    implements
        CopyWith$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithWhereUniqueWithoutGroupMemberOfInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestUpdateWithoutGroupMemberOfInput? update,
    Input$GuestCreateWithoutGroupMemberOfInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutGroupMemberOfInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutGroupMemberOfInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutGroupMemberOfInput.stub(_res);
}

class Input$GuestWhereInput {
  factory Input$GuestWhereInput({
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
    Input$GuestNullableRelationFilter? groupMemberOf,
    Input$GuestListRelationFilter? groupMembers,
    Input$QrCodeNullableRelationFilter? qrcode,
    Input$InvitationImageNullableRelationFilter? invitationImage,
    Input$WhatsappStatusListRelationFilter? whatsappStatuses,
  }) =>
      Input$GuestWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (groupMemberOfId != null) r'groupMemberOfId': groupMemberOfId,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestWhereInput._(this._$data);

  factory Input$GuestWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFilter.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$FloatNullableFilter.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = data['groupMemberOfId'];
      result$data['groupMemberOfId'] = l$groupMemberOfId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$groupMemberOfId as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusNullableFilter.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestNullableRelationFilter.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestListRelationFilter.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeNullableRelationFilter.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageNullableRelationFilter.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusListRelationFilter.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$GuestWhereInput>? get AND =>
      (_$data['AND'] as List<Input$GuestWhereInput>?);
  List<Input$GuestWhereInput>? get OR =>
      (_$data['OR'] as List<Input$GuestWhereInput>?);
  List<Input$GuestWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$GuestWhereInput>?);
  Input$StringFilter? get id => (_$data['id'] as Input$StringFilter?);
  Input$StringNullableFilter? get source =>
      (_$data['source'] as Input$StringNullableFilter?);
  Input$StringFilter? get invitationName =>
      (_$data['invitationName'] as Input$StringFilter?);
  Input$StringNullableFilter? get contactList =>
      (_$data['contactList'] as Input$StringNullableFilter?);
  Input$FloatNullableFilter? get whatsapp =>
      (_$data['whatsapp'] as Input$FloatNullableFilter?);
  Input$StringNullableFilter? get category =>
      (_$data['category'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get $class =>
      (_$data['class'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get seat =>
      (_$data['seat'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get studio =>
      (_$data['studio'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get showTime =>
      (_$data['showTime'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get rejectionReason =>
      (_$data['rejectionReason'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$DateTimeNullableFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeNullableFilter? get deletedAt =>
      (_$data['deletedAt'] as Input$DateTimeNullableFilter?);
  Input$StringNullableFilter? get groupMemberOfId =>
      (_$data['groupMemberOfId'] as Input$StringNullableFilter?);
  Input$EnumConfirmationStatusNullableFilter? get confirmationStatus =>
      (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusNullableFilter?);
  Input$GuestNullableRelationFilter? get groupMemberOf =>
      (_$data['groupMemberOf'] as Input$GuestNullableRelationFilter?);
  Input$GuestListRelationFilter? get groupMembers =>
      (_$data['groupMembers'] as Input$GuestListRelationFilter?);
  Input$QrCodeNullableRelationFilter? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeNullableRelationFilter?);
  Input$InvitationImageNullableRelationFilter? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageNullableRelationFilter?);
  Input$WhatsappStatusListRelationFilter? get whatsappStatuses =>
      (_$data['whatsappStatuses'] as Input$WhatsappStatusListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = groupMemberOfId;
      result$data['groupMemberOfId'] = l$groupMemberOfId?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestWhereInput<Input$GuestWhereInput> get copyWith =>
      CopyWith$Input$GuestWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestWhereInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$groupMemberOfId = groupMemberOfId;
    final lOther$groupMemberOfId = other.groupMemberOfId;
    if (_$data.containsKey('groupMemberOfId') !=
        other._$data.containsKey('groupMemberOfId')) {
      return false;
    }
    if (l$groupMemberOfId != lOther$groupMemberOfId) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$groupMemberOfId = groupMemberOfId;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('groupMemberOfId') ? l$groupMemberOfId : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestWhereInput<TRes> {
  factory CopyWith$Input$GuestWhereInput(
    Input$GuestWhereInput instance,
    TRes Function(Input$GuestWhereInput) then,
  ) = _CopyWithImpl$Input$GuestWhereInput;

  factory CopyWith$Input$GuestWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestWhereInput;

  TRes call({
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
    Input$GuestNullableRelationFilter? groupMemberOf,
    Input$GuestListRelationFilter? groupMembers,
    Input$QrCodeNullableRelationFilter? qrcode,
    Input$InvitationImageNullableRelationFilter? invitationImage,
    Input$WhatsappStatusListRelationFilter? whatsappStatuses,
  });
  TRes AND(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get id;
  CopyWith$Input$StringNullableFilter<TRes> get source;
  CopyWith$Input$StringFilter<TRes> get invitationName;
  CopyWith$Input$StringNullableFilter<TRes> get contactList;
  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp;
  CopyWith$Input$StringNullableFilter<TRes> get category;
  CopyWith$Input$StringNullableFilter<TRes> get $class;
  CopyWith$Input$StringNullableFilter<TRes> get seat;
  CopyWith$Input$StringNullableFilter<TRes> get studio;
  CopyWith$Input$StringNullableFilter<TRes> get showTime;
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt;
  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId;
  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus;
  CopyWith$Input$GuestNullableRelationFilter<TRes> get groupMemberOf;
  CopyWith$Input$GuestListRelationFilter<TRes> get groupMembers;
  CopyWith$Input$QrCodeNullableRelationFilter<TRes> get qrcode;
  CopyWith$Input$InvitationImageNullableRelationFilter<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusListRelationFilter<TRes> get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestWhereInput<TRes>
    implements CopyWith$Input$GuestWhereInput<TRes> {
  _CopyWithImpl$Input$GuestWhereInput(
    this._instance,
    this._then,
  );

  final Input$GuestWhereInput _instance;

  final TRes Function(Input$GuestWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? groupMemberOfId = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$GuestWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$GuestWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$GuestWhereInput>?),
        if (id != _undefined) 'id': (id as Input$StringFilter?),
        if (source != _undefined)
          'source': (source as Input$StringNullableFilter?),
        if (invitationName != _undefined)
          'invitationName': (invitationName as Input$StringFilter?),
        if (contactList != _undefined)
          'contactList': (contactList as Input$StringNullableFilter?),
        if (whatsapp != _undefined)
          'whatsapp': (whatsapp as Input$FloatNullableFilter?),
        if (category != _undefined)
          'category': (category as Input$StringNullableFilter?),
        if ($class != _undefined)
          'class': ($class as Input$StringNullableFilter?),
        if (seat != _undefined) 'seat': (seat as Input$StringNullableFilter?),
        if (studio != _undefined)
          'studio': (studio as Input$StringNullableFilter?),
        if (showTime != _undefined)
          'showTime': (showTime as Input$StringNullableFilter?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeNullableFilter?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$DateTimeNullableFilter?),
        if (groupMemberOfId != _undefined)
          'groupMemberOfId': (groupMemberOfId as Input$StringNullableFilter?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusNullableFilter?),
        if (groupMemberOf != _undefined)
          'groupMemberOf':
              (groupMemberOf as Input$GuestNullableRelationFilter?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers as Input$GuestListRelationFilter?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeNullableRelationFilter?),
        if (invitationImage != _undefined)
          'invitationImage':
              (invitationImage as Input$InvitationImageNullableRelationFilter?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses':
              (whatsappStatuses as Input$WhatsappStatusListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFilter<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$FloatNullableFilter.stub(_then(_instance))
        : CopyWith$Input$FloatNullableFilter(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId {
    final local$groupMemberOfId = _instance.groupMemberOfId;
    return local$groupMemberOfId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$groupMemberOfId, (e) => call(groupMemberOfId: e));
  }

  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusNullableFilter.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusNullableFilter(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestNullableRelationFilter<TRes> get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestNullableRelationFilter(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestListRelationFilter<TRes> get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestListRelationFilter(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeNullableRelationFilter<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$QrCodeNullableRelationFilter(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageNullableRelationFilter<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageNullableRelationFilter.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageNullableRelationFilter(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusListRelationFilter<TRes> get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$WhatsappStatusListRelationFilter(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestWhereInput<TRes>
    implements CopyWith$Input$GuestWhereInput<TRes> {
  _CopyWithStubImpl$Input$GuestWhereInput(this._res);

  TRes _res;

  call({
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
    Input$GuestNullableRelationFilter? groupMemberOf,
    Input$GuestListRelationFilter? groupMembers,
    Input$QrCodeNullableRelationFilter? qrcode,
    Input$InvitationImageNullableRelationFilter? invitationImage,
    Input$WhatsappStatusListRelationFilter? whatsappStatuses,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get id =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get source =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get invitationName =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get contactList =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp =>
      CopyWith$Input$FloatNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get category =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get $class =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get seat =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get studio =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get showTime =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusNullableFilter.stub(_res);
  CopyWith$Input$GuestNullableRelationFilter<TRes> get groupMemberOf =>
      CopyWith$Input$GuestNullableRelationFilter.stub(_res);
  CopyWith$Input$GuestListRelationFilter<TRes> get groupMembers =>
      CopyWith$Input$GuestListRelationFilter.stub(_res);
  CopyWith$Input$QrCodeNullableRelationFilter<TRes> get qrcode =>
      CopyWith$Input$QrCodeNullableRelationFilter.stub(_res);
  CopyWith$Input$InvitationImageNullableRelationFilter<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageNullableRelationFilter.stub(_res);
  CopyWith$Input$WhatsappStatusListRelationFilter<TRes> get whatsappStatuses =>
      CopyWith$Input$WhatsappStatusListRelationFilter.stub(_res);
}

class Input$GuestWhereUniqueInput {
  factory Input$GuestWhereUniqueInput({
    String? id,
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
    Input$GuestNullableRelationFilter? groupMemberOf,
    Input$GuestListRelationFilter? groupMembers,
    Input$QrCodeNullableRelationFilter? qrcode,
    Input$InvitationImageNullableRelationFilter? invitationImage,
    Input$WhatsappStatusListRelationFilter? whatsappStatuses,
  }) =>
      Input$GuestWhereUniqueInput._({
        if (id != null) r'id': id,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (source != null) r'source': source,
        if (invitationName != null) r'invitationName': invitationName,
        if (contactList != null) r'contactList': contactList,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (category != null) r'category': category,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (studio != null) r'studio': studio,
        if (showTime != null) r'showTime': showTime,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (groupMemberOfId != null) r'groupMemberOfId': groupMemberOfId,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (groupMemberOf != null) r'groupMemberOf': groupMemberOf,
        if (groupMembers != null) r'groupMembers': groupMembers,
        if (qrcode != null) r'qrcode': qrcode,
        if (invitationImage != null) r'invitationImage': invitationImage,
        if (whatsappStatuses != null) r'whatsappStatuses': whatsappStatuses,
      });

  Input$GuestWhereUniqueInput._(this._$data);

  factory Input$GuestWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('source')) {
      final l$source = data['source'];
      result$data['source'] = l$source == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$source as Map<String, dynamic>));
    }
    if (data.containsKey('invitationName')) {
      final l$invitationName = data['invitationName'];
      result$data['invitationName'] = l$invitationName == null
          ? null
          : Input$StringFilter.fromJson(
              (l$invitationName as Map<String, dynamic>));
    }
    if (data.containsKey('contactList')) {
      final l$contactList = data['contactList'];
      result$data['contactList'] = l$contactList == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$contactList as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$FloatNullableFilter.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('category')) {
      final l$category = data['category'];
      result$data['category'] = l$category == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$category as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('studio')) {
      final l$studio = data['studio'];
      result$data['studio'] = l$studio == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$studio as Map<String, dynamic>));
    }
    if (data.containsKey('showTime')) {
      final l$showTime = data['showTime'];
      result$data['showTime'] = l$showTime == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$showTime as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = data['groupMemberOfId'];
      result$data['groupMemberOfId'] = l$groupMemberOfId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$groupMemberOfId as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusNullableFilter.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = data['groupMemberOf'];
      result$data['groupMemberOf'] = l$groupMemberOf == null
          ? null
          : Input$GuestNullableRelationFilter.fromJson(
              (l$groupMemberOf as Map<String, dynamic>));
    }
    if (data.containsKey('groupMembers')) {
      final l$groupMembers = data['groupMembers'];
      result$data['groupMembers'] = l$groupMembers == null
          ? null
          : Input$GuestListRelationFilter.fromJson(
              (l$groupMembers as Map<String, dynamic>));
    }
    if (data.containsKey('qrcode')) {
      final l$qrcode = data['qrcode'];
      result$data['qrcode'] = l$qrcode == null
          ? null
          : Input$QrCodeNullableRelationFilter.fromJson(
              (l$qrcode as Map<String, dynamic>));
    }
    if (data.containsKey('invitationImage')) {
      final l$invitationImage = data['invitationImage'];
      result$data['invitationImage'] = l$invitationImage == null
          ? null
          : Input$InvitationImageNullableRelationFilter.fromJson(
              (l$invitationImage as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = data['whatsappStatuses'];
      result$data['whatsappStatuses'] = l$whatsappStatuses == null
          ? null
          : Input$WhatsappStatusListRelationFilter.fromJson(
              (l$whatsappStatuses as Map<String, dynamic>));
    }
    return Input$GuestWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  List<Input$GuestWhereInput>? get AND =>
      (_$data['AND'] as List<Input$GuestWhereInput>?);
  List<Input$GuestWhereInput>? get OR =>
      (_$data['OR'] as List<Input$GuestWhereInput>?);
  List<Input$GuestWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$GuestWhereInput>?);
  Input$StringNullableFilter? get source =>
      (_$data['source'] as Input$StringNullableFilter?);
  Input$StringFilter? get invitationName =>
      (_$data['invitationName'] as Input$StringFilter?);
  Input$StringNullableFilter? get contactList =>
      (_$data['contactList'] as Input$StringNullableFilter?);
  Input$FloatNullableFilter? get whatsapp =>
      (_$data['whatsapp'] as Input$FloatNullableFilter?);
  Input$StringNullableFilter? get category =>
      (_$data['category'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get $class =>
      (_$data['class'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get seat =>
      (_$data['seat'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get studio =>
      (_$data['studio'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get showTime =>
      (_$data['showTime'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get rejectionReason =>
      (_$data['rejectionReason'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$DateTimeNullableFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeNullableFilter? get deletedAt =>
      (_$data['deletedAt'] as Input$DateTimeNullableFilter?);
  Input$StringNullableFilter? get groupMemberOfId =>
      (_$data['groupMemberOfId'] as Input$StringNullableFilter?);
  Input$EnumConfirmationStatusNullableFilter? get confirmationStatus =>
      (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusNullableFilter?);
  Input$GuestNullableRelationFilter? get groupMemberOf =>
      (_$data['groupMemberOf'] as Input$GuestNullableRelationFilter?);
  Input$GuestListRelationFilter? get groupMembers =>
      (_$data['groupMembers'] as Input$GuestListRelationFilter?);
  Input$QrCodeNullableRelationFilter? get qrcode =>
      (_$data['qrcode'] as Input$QrCodeNullableRelationFilter?);
  Input$InvitationImageNullableRelationFilter? get invitationImage =>
      (_$data['invitationImage']
          as Input$InvitationImageNullableRelationFilter?);
  Input$WhatsappStatusListRelationFilter? get whatsappStatuses =>
      (_$data['whatsappStatuses'] as Input$WhatsappStatusListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('source')) {
      final l$source = source;
      result$data['source'] = l$source?.toJson();
    }
    if (_$data.containsKey('invitationName')) {
      final l$invitationName = invitationName;
      result$data['invitationName'] = l$invitationName?.toJson();
    }
    if (_$data.containsKey('contactList')) {
      final l$contactList = contactList;
      result$data['contactList'] = l$contactList?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('category')) {
      final l$category = category;
      result$data['category'] = l$category?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('studio')) {
      final l$studio = studio;
      result$data['studio'] = l$studio?.toJson();
    }
    if (_$data.containsKey('showTime')) {
      final l$showTime = showTime;
      result$data['showTime'] = l$showTime?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('groupMemberOfId')) {
      final l$groupMemberOfId = groupMemberOfId;
      result$data['groupMemberOfId'] = l$groupMemberOfId?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('groupMemberOf')) {
      final l$groupMemberOf = groupMemberOf;
      result$data['groupMemberOf'] = l$groupMemberOf?.toJson();
    }
    if (_$data.containsKey('groupMembers')) {
      final l$groupMembers = groupMembers;
      result$data['groupMembers'] = l$groupMembers?.toJson();
    }
    if (_$data.containsKey('qrcode')) {
      final l$qrcode = qrcode;
      result$data['qrcode'] = l$qrcode?.toJson();
    }
    if (_$data.containsKey('invitationImage')) {
      final l$invitationImage = invitationImage;
      result$data['invitationImage'] = l$invitationImage?.toJson();
    }
    if (_$data.containsKey('whatsappStatuses')) {
      final l$whatsappStatuses = whatsappStatuses;
      result$data['whatsappStatuses'] = l$whatsappStatuses?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestWhereUniqueInput<Input$GuestWhereUniqueInput>
      get copyWith => CopyWith$Input$GuestWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$source = source;
    final lOther$source = other.source;
    if (_$data.containsKey('source') != other._$data.containsKey('source')) {
      return false;
    }
    if (l$source != lOther$source) {
      return false;
    }
    final l$invitationName = invitationName;
    final lOther$invitationName = other.invitationName;
    if (_$data.containsKey('invitationName') !=
        other._$data.containsKey('invitationName')) {
      return false;
    }
    if (l$invitationName != lOther$invitationName) {
      return false;
    }
    final l$contactList = contactList;
    final lOther$contactList = other.contactList;
    if (_$data.containsKey('contactList') !=
        other._$data.containsKey('contactList')) {
      return false;
    }
    if (l$contactList != lOther$contactList) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$category = category;
    final lOther$category = other.category;
    if (_$data.containsKey('category') !=
        other._$data.containsKey('category')) {
      return false;
    }
    if (l$category != lOther$category) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$studio = studio;
    final lOther$studio = other.studio;
    if (_$data.containsKey('studio') != other._$data.containsKey('studio')) {
      return false;
    }
    if (l$studio != lOther$studio) {
      return false;
    }
    final l$showTime = showTime;
    final lOther$showTime = other.showTime;
    if (_$data.containsKey('showTime') !=
        other._$data.containsKey('showTime')) {
      return false;
    }
    if (l$showTime != lOther$showTime) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$groupMemberOfId = groupMemberOfId;
    final lOther$groupMemberOfId = other.groupMemberOfId;
    if (_$data.containsKey('groupMemberOfId') !=
        other._$data.containsKey('groupMemberOfId')) {
      return false;
    }
    if (l$groupMemberOfId != lOther$groupMemberOfId) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$groupMemberOf = groupMemberOf;
    final lOther$groupMemberOf = other.groupMemberOf;
    if (_$data.containsKey('groupMemberOf') !=
        other._$data.containsKey('groupMemberOf')) {
      return false;
    }
    if (l$groupMemberOf != lOther$groupMemberOf) {
      return false;
    }
    final l$groupMembers = groupMembers;
    final lOther$groupMembers = other.groupMembers;
    if (_$data.containsKey('groupMembers') !=
        other._$data.containsKey('groupMembers')) {
      return false;
    }
    if (l$groupMembers != lOther$groupMembers) {
      return false;
    }
    final l$qrcode = qrcode;
    final lOther$qrcode = other.qrcode;
    if (_$data.containsKey('qrcode') != other._$data.containsKey('qrcode')) {
      return false;
    }
    if (l$qrcode != lOther$qrcode) {
      return false;
    }
    final l$invitationImage = invitationImage;
    final lOther$invitationImage = other.invitationImage;
    if (_$data.containsKey('invitationImage') !=
        other._$data.containsKey('invitationImage')) {
      return false;
    }
    if (l$invitationImage != lOther$invitationImage) {
      return false;
    }
    final l$whatsappStatuses = whatsappStatuses;
    final lOther$whatsappStatuses = other.whatsappStatuses;
    if (_$data.containsKey('whatsappStatuses') !=
        other._$data.containsKey('whatsappStatuses')) {
      return false;
    }
    if (l$whatsappStatuses != lOther$whatsappStatuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$source = source;
    final l$invitationName = invitationName;
    final l$contactList = contactList;
    final l$whatsapp = whatsapp;
    final l$category = category;
    final l$$class = $class;
    final l$seat = seat;
    final l$studio = studio;
    final l$showTime = showTime;
    final l$rejectionReason = rejectionReason;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$groupMemberOfId = groupMemberOfId;
    final l$confirmationStatus = confirmationStatus;
    final l$groupMemberOf = groupMemberOf;
    final l$groupMembers = groupMembers;
    final l$qrcode = qrcode;
    final l$invitationImage = invitationImage;
    final l$whatsappStatuses = whatsappStatuses;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('source') ? l$source : const {},
      _$data.containsKey('invitationName') ? l$invitationName : const {},
      _$data.containsKey('contactList') ? l$contactList : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('category') ? l$category : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('studio') ? l$studio : const {},
      _$data.containsKey('showTime') ? l$showTime : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('groupMemberOfId') ? l$groupMemberOfId : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('groupMemberOf') ? l$groupMemberOf : const {},
      _$data.containsKey('groupMembers') ? l$groupMembers : const {},
      _$data.containsKey('qrcode') ? l$qrcode : const {},
      _$data.containsKey('invitationImage') ? l$invitationImage : const {},
      _$data.containsKey('whatsappStatuses') ? l$whatsappStatuses : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestWhereUniqueInput<TRes> {
  factory CopyWith$Input$GuestWhereUniqueInput(
    Input$GuestWhereUniqueInput instance,
    TRes Function(Input$GuestWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$GuestWhereUniqueInput;

  factory CopyWith$Input$GuestWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestWhereUniqueInput;

  TRes call({
    String? id,
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
    Input$GuestNullableRelationFilter? groupMemberOf,
    Input$GuestListRelationFilter? groupMembers,
    Input$QrCodeNullableRelationFilter? qrcode,
    Input$InvitationImageNullableRelationFilter? invitationImage,
    Input$WhatsappStatusListRelationFilter? whatsappStatuses,
  });
  TRes AND(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  CopyWith$Input$StringNullableFilter<TRes> get source;
  CopyWith$Input$StringFilter<TRes> get invitationName;
  CopyWith$Input$StringNullableFilter<TRes> get contactList;
  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp;
  CopyWith$Input$StringNullableFilter<TRes> get category;
  CopyWith$Input$StringNullableFilter<TRes> get $class;
  CopyWith$Input$StringNullableFilter<TRes> get seat;
  CopyWith$Input$StringNullableFilter<TRes> get studio;
  CopyWith$Input$StringNullableFilter<TRes> get showTime;
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt;
  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId;
  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus;
  CopyWith$Input$GuestNullableRelationFilter<TRes> get groupMemberOf;
  CopyWith$Input$GuestListRelationFilter<TRes> get groupMembers;
  CopyWith$Input$QrCodeNullableRelationFilter<TRes> get qrcode;
  CopyWith$Input$InvitationImageNullableRelationFilter<TRes>
      get invitationImage;
  CopyWith$Input$WhatsappStatusListRelationFilter<TRes> get whatsappStatuses;
}

class _CopyWithImpl$Input$GuestWhereUniqueInput<TRes>
    implements CopyWith$Input$GuestWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$GuestWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$GuestWhereUniqueInput _instance;

  final TRes Function(Input$GuestWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? source = _undefined,
    Object? invitationName = _undefined,
    Object? contactList = _undefined,
    Object? whatsapp = _undefined,
    Object? category = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? studio = _undefined,
    Object? showTime = _undefined,
    Object? rejectionReason = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? groupMemberOfId = _undefined,
    Object? confirmationStatus = _undefined,
    Object? groupMemberOf = _undefined,
    Object? groupMembers = _undefined,
    Object? qrcode = _undefined,
    Object? invitationImage = _undefined,
    Object? whatsappStatuses = _undefined,
  }) =>
      _then(Input$GuestWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (AND != _undefined) 'AND': (AND as List<Input$GuestWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$GuestWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$GuestWhereInput>?),
        if (source != _undefined)
          'source': (source as Input$StringNullableFilter?),
        if (invitationName != _undefined)
          'invitationName': (invitationName as Input$StringFilter?),
        if (contactList != _undefined)
          'contactList': (contactList as Input$StringNullableFilter?),
        if (whatsapp != _undefined)
          'whatsapp': (whatsapp as Input$FloatNullableFilter?),
        if (category != _undefined)
          'category': (category as Input$StringNullableFilter?),
        if ($class != _undefined)
          'class': ($class as Input$StringNullableFilter?),
        if (seat != _undefined) 'seat': (seat as Input$StringNullableFilter?),
        if (studio != _undefined)
          'studio': (studio as Input$StringNullableFilter?),
        if (showTime != _undefined)
          'showTime': (showTime as Input$StringNullableFilter?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeNullableFilter?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$DateTimeNullableFilter?),
        if (groupMemberOfId != _undefined)
          'groupMemberOfId': (groupMemberOfId as Input$StringNullableFilter?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusNullableFilter?),
        if (groupMemberOf != _undefined)
          'groupMemberOf':
              (groupMemberOf as Input$GuestNullableRelationFilter?),
        if (groupMembers != _undefined)
          'groupMembers': (groupMembers as Input$GuestListRelationFilter?),
        if (qrcode != _undefined)
          'qrcode': (qrcode as Input$QrCodeNullableRelationFilter?),
        if (invitationImage != _undefined)
          'invitationImage':
              (invitationImage as Input$InvitationImageNullableRelationFilter?),
        if (whatsappStatuses != _undefined)
          'whatsappStatuses':
              (whatsappStatuses as Input$WhatsappStatusListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringNullableFilter<TRes> get source {
    final local$source = _instance.source;
    return local$source == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$source, (e) => call(source: e));
  }

  CopyWith$Input$StringFilter<TRes> get invitationName {
    final local$invitationName = _instance.invitationName;
    return local$invitationName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$invitationName, (e) => call(invitationName: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get contactList {
    final local$contactList = _instance.contactList;
    return local$contactList == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$contactList, (e) => call(contactList: e));
  }

  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$FloatNullableFilter.stub(_then(_instance))
        : CopyWith$Input$FloatNullableFilter(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get category {
    final local$category = _instance.category;
    return local$category == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$category, (e) => call(category: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get studio {
    final local$studio = _instance.studio;
    return local$studio == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$studio, (e) => call(studio: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get showTime {
    final local$showTime = _instance.showTime;
    return local$showTime == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$showTime, (e) => call(showTime: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId {
    final local$groupMemberOfId = _instance.groupMemberOfId;
    return local$groupMemberOfId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$groupMemberOfId, (e) => call(groupMemberOfId: e));
  }

  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusNullableFilter.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusNullableFilter(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$GuestNullableRelationFilter<TRes> get groupMemberOf {
    final local$groupMemberOf = _instance.groupMemberOf;
    return local$groupMemberOf == null
        ? CopyWith$Input$GuestNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestNullableRelationFilter(
            local$groupMemberOf, (e) => call(groupMemberOf: e));
  }

  CopyWith$Input$GuestListRelationFilter<TRes> get groupMembers {
    final local$groupMembers = _instance.groupMembers;
    return local$groupMembers == null
        ? CopyWith$Input$GuestListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestListRelationFilter(
            local$groupMembers, (e) => call(groupMembers: e));
  }

  CopyWith$Input$QrCodeNullableRelationFilter<TRes> get qrcode {
    final local$qrcode = _instance.qrcode;
    return local$qrcode == null
        ? CopyWith$Input$QrCodeNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$QrCodeNullableRelationFilter(
            local$qrcode, (e) => call(qrcode: e));
  }

  CopyWith$Input$InvitationImageNullableRelationFilter<TRes>
      get invitationImage {
    final local$invitationImage = _instance.invitationImage;
    return local$invitationImage == null
        ? CopyWith$Input$InvitationImageNullableRelationFilter.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageNullableRelationFilter(
            local$invitationImage, (e) => call(invitationImage: e));
  }

  CopyWith$Input$WhatsappStatusListRelationFilter<TRes> get whatsappStatuses {
    final local$whatsappStatuses = _instance.whatsappStatuses;
    return local$whatsappStatuses == null
        ? CopyWith$Input$WhatsappStatusListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$WhatsappStatusListRelationFilter(
            local$whatsappStatuses, (e) => call(whatsappStatuses: e));
  }
}

class _CopyWithStubImpl$Input$GuestWhereUniqueInput<TRes>
    implements CopyWith$Input$GuestWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$GuestWhereUniqueInput(this._res);

  TRes _res;

  call({
    String? id,
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringNullableFilter? source,
    Input$StringFilter? invitationName,
    Input$StringNullableFilter? contactList,
    Input$FloatNullableFilter? whatsapp,
    Input$StringNullableFilter? category,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? studio,
    Input$StringNullableFilter? showTime,
    Input$StringNullableFilter? rejectionReason,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$StringNullableFilter? groupMemberOfId,
    Input$EnumConfirmationStatusNullableFilter? confirmationStatus,
    Input$GuestNullableRelationFilter? groupMemberOf,
    Input$GuestListRelationFilter? groupMembers,
    Input$QrCodeNullableRelationFilter? qrcode,
    Input$InvitationImageNullableRelationFilter? invitationImage,
    Input$WhatsappStatusListRelationFilter? whatsappStatuses,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringNullableFilter<TRes> get source =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get invitationName =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get contactList =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$FloatNullableFilter<TRes> get whatsapp =>
      CopyWith$Input$FloatNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get category =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get $class =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get seat =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get studio =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get showTime =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get groupMemberOfId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$EnumConfirmationStatusNullableFilter<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusNullableFilter.stub(_res);
  CopyWith$Input$GuestNullableRelationFilter<TRes> get groupMemberOf =>
      CopyWith$Input$GuestNullableRelationFilter.stub(_res);
  CopyWith$Input$GuestListRelationFilter<TRes> get groupMembers =>
      CopyWith$Input$GuestListRelationFilter.stub(_res);
  CopyWith$Input$QrCodeNullableRelationFilter<TRes> get qrcode =>
      CopyWith$Input$QrCodeNullableRelationFilter.stub(_res);
  CopyWith$Input$InvitationImageNullableRelationFilter<TRes>
      get invitationImage =>
          CopyWith$Input$InvitationImageNullableRelationFilter.stub(_res);
  CopyWith$Input$WhatsappStatusListRelationFilter<TRes> get whatsappStatuses =>
      CopyWith$Input$WhatsappStatusListRelationFilter.stub(_res);
}

class Input$IntFieldUpdateOperationsInput {
  factory Input$IntFieldUpdateOperationsInput({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  }) =>
      Input$IntFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
        if (increment != null) r'increment': increment,
        if (decrement != null) r'decrement': decrement,
        if (multiply != null) r'multiply': multiply,
        if (divide != null) r'divide': divide,
      });

  Input$IntFieldUpdateOperationsInput._(this._$data);

  factory Input$IntFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as int?);
    }
    if (data.containsKey('increment')) {
      final l$increment = data['increment'];
      result$data['increment'] = (l$increment as int?);
    }
    if (data.containsKey('decrement')) {
      final l$decrement = data['decrement'];
      result$data['decrement'] = (l$decrement as int?);
    }
    if (data.containsKey('multiply')) {
      final l$multiply = data['multiply'];
      result$data['multiply'] = (l$multiply as int?);
    }
    if (data.containsKey('divide')) {
      final l$divide = data['divide'];
      result$data['divide'] = (l$divide as int?);
    }
    return Input$IntFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get $set => (_$data['set'] as int?);
  int? get increment => (_$data['increment'] as int?);
  int? get decrement => (_$data['decrement'] as int?);
  int? get multiply => (_$data['multiply'] as int?);
  int? get divide => (_$data['divide'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    if (_$data.containsKey('increment')) {
      final l$increment = increment;
      result$data['increment'] = l$increment;
    }
    if (_$data.containsKey('decrement')) {
      final l$decrement = decrement;
      result$data['decrement'] = l$decrement;
    }
    if (_$data.containsKey('multiply')) {
      final l$multiply = multiply;
      result$data['multiply'] = l$multiply;
    }
    if (_$data.containsKey('divide')) {
      final l$divide = divide;
      result$data['divide'] = l$divide;
    }
    return result$data;
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<
          Input$IntFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$IntFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (_$data.containsKey('increment') !=
        other._$data.containsKey('increment')) {
      return false;
    }
    if (l$increment != lOther$increment) {
      return false;
    }
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (_$data.containsKey('decrement') !=
        other._$data.containsKey('decrement')) {
      return false;
    }
    if (l$decrement != lOther$decrement) {
      return false;
    }
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (_$data.containsKey('multiply') !=
        other._$data.containsKey('multiply')) {
      return false;
    }
    if (l$multiply != lOther$multiply) {
      return false;
    }
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (_$data.containsKey('divide') != other._$data.containsKey('divide')) {
      return false;
    }
    if (l$divide != lOther$divide) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll([
      _$data.containsKey('set') ? l$$set : const {},
      _$data.containsKey('increment') ? l$increment : const {},
      _$data.containsKey('decrement') ? l$decrement : const {},
      _$data.containsKey('multiply') ? l$multiply : const {},
      _$data.containsKey('divide') ? l$divide : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$IntFieldUpdateOperationsInput(
    Input$IntFieldUpdateOperationsInput instance,
    TRes Function(Input$IntFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$IntFieldUpdateOperationsInput;

  factory CopyWith$Input$IntFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput;

  TRes call({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  });
}

class _CopyWithImpl$Input$IntFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$IntFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$IntFieldUpdateOperationsInput _instance;

  final TRes Function(Input$IntFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $set = _undefined,
    Object? increment = _undefined,
    Object? decrement = _undefined,
    Object? multiply = _undefined,
    Object? divide = _undefined,
  }) =>
      _then(Input$IntFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as int?),
        if (increment != _undefined) 'increment': (increment as int?),
        if (decrement != _undefined) 'decrement': (decrement as int?),
        if (multiply != _undefined) 'multiply': (multiply as int?),
        if (divide != _undefined) 'divide': (divide as int?),
      }));
}

class _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  }) =>
      _res;
}

class Input$IntFilter {
  factory Input$IntFilter({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      Input$IntFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$IntFilter._(this._$data);

  factory Input$IntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$IntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  List<int>? get notIn => (_$data['notIn'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  Input$NestedIntFilter? get not => (_$data['not'] as Input$NestedIntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$IntFilter<Input$IntFilter> get copyWith =>
      CopyWith$Input$IntFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntFilter<TRes> {
  factory CopyWith$Input$IntFilter(
    Input$IntFilter instance,
    TRes Function(Input$IntFilter) then,
  ) = _CopyWithImpl$Input$IntFilter;

  factory CopyWith$Input$IntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$IntFilter;

  TRes call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  });
  CopyWith$Input$NestedIntFilter<TRes> get not;
}

class _CopyWithImpl$Input$IntFilter<TRes>
    implements CopyWith$Input$IntFilter<TRes> {
  _CopyWithImpl$Input$IntFilter(
    this._instance,
    this._then,
  );

  final Input$IntFilter _instance;

  final TRes Function(Input$IntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$IntFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntFilter?),
      }));
  CopyWith$Input$NestedIntFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$IntFilter<TRes>
    implements CopyWith$Input$IntFilter<TRes> {
  _CopyWithStubImpl$Input$IntFilter(this._res);

  TRes _res;

  call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedIntFilter<TRes> get not =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$InvitationImageCountAggregateInput {
  factory Input$InvitationImageCountAggregateInput({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
    bool? $_all,
  }) =>
      Input$InvitationImageCountAggregateInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        if (guestId != null) r'guestId': guestId,
        if ($_all != null) r'_all': $_all,
      });

  Input$InvitationImageCountAggregateInput._(this._$data);

  factory Input$InvitationImageCountAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$InvitationImageCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get path => (_$data['path'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageCountAggregateInput<
          Input$InvitationImageCountAggregateInput>
      get copyWith => CopyWith$Input$InvitationImageCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageCountAggregateInput<TRes> {
  factory CopyWith$Input$InvitationImageCountAggregateInput(
    Input$InvitationImageCountAggregateInput instance,
    TRes Function(Input$InvitationImageCountAggregateInput) then,
  ) = _CopyWithImpl$Input$InvitationImageCountAggregateInput;

  factory CopyWith$Input$InvitationImageCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageCountAggregateInput;

  TRes call({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$InvitationImageCountAggregateInput<TRes>
    implements CopyWith$Input$InvitationImageCountAggregateInput<TRes> {
  _CopyWithImpl$Input$InvitationImageCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageCountAggregateInput _instance;

  final TRes Function(Input$InvitationImageCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$InvitationImageCountAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (path != _undefined) 'path': (path as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$InvitationImageCountAggregateInput<TRes>
    implements CopyWith$Input$InvitationImageCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
    bool? $_all,
  }) =>
      _res;
}

class Input$InvitationImageCreateInput {
  factory Input$InvitationImageCreateInput({
    String? id,
    required String path,
    String? createdAt,
    required Input$GuestCreateNestedOneWithoutInvitationImageInput guest,
  }) =>
      Input$InvitationImageCreateInput._({
        if (id != null) r'id': id,
        r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        r'guest': guest,
      });

  Input$InvitationImageCreateInput._(this._$data);

  factory Input$InvitationImageCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    final l$guest = data['guest'];
    result$data['guest'] =
        Input$GuestCreateNestedOneWithoutInvitationImageInput.fromJson(
            (l$guest as Map<String, dynamic>));
    return Input$InvitationImageCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get path => (_$data['path'] as String);
  String? get createdAt => (_$data['createdAt'] as String?);
  Input$GuestCreateNestedOneWithoutInvitationImageInput get guest =>
      (_$data['guest']
          as Input$GuestCreateNestedOneWithoutInvitationImageInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    final l$guest = guest;
    result$data['guest'] = l$guest.toJson();
    return result$data;
  }

  CopyWith$Input$InvitationImageCreateInput<Input$InvitationImageCreateInput>
      get copyWith => CopyWith$Input$InvitationImageCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$path,
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      l$guest,
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageCreateInput<TRes> {
  factory CopyWith$Input$InvitationImageCreateInput(
    Input$InvitationImageCreateInput instance,
    TRes Function(Input$InvitationImageCreateInput) then,
  ) = _CopyWithImpl$Input$InvitationImageCreateInput;

  factory CopyWith$Input$InvitationImageCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageCreateInput;

  TRes call({
    String? id,
    String? path,
    String? createdAt,
    Input$GuestCreateNestedOneWithoutInvitationImageInput? guest,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput<TRes>
      get guest;
}

class _CopyWithImpl$Input$InvitationImageCreateInput<TRes>
    implements CopyWith$Input$InvitationImageCreateInput<TRes> {
  _CopyWithImpl$Input$InvitationImageCreateInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageCreateInput _instance;

  final TRes Function(Input$InvitationImageCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$InvitationImageCreateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (path != _undefined && path != null) 'path': (path as String),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (guest != _undefined && guest != null)
          'guest':
              (guest as Input$GuestCreateNestedOneWithoutInvitationImageInput),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput(
        local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageCreateInput<TRes>
    implements CopyWith$Input$InvitationImageCreateInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageCreateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? path,
    String? createdAt,
    Input$GuestCreateNestedOneWithoutInvitationImageInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput<TRes>
      get guest =>
          CopyWith$Input$GuestCreateNestedOneWithoutInvitationImageInput.stub(
              _res);
}

class Input$InvitationImageCreateManyInput {
  factory Input$InvitationImageCreateManyInput({
    String? id,
    required String path,
    String? createdAt,
    required String guestId,
  }) =>
      Input$InvitationImageCreateManyInput._({
        if (id != null) r'id': id,
        r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        r'guestId': guestId,
      });

  Input$InvitationImageCreateManyInput._(this._$data);

  factory Input$InvitationImageCreateManyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    final l$guestId = data['guestId'];
    result$data['guestId'] = (l$guestId as String);
    return Input$InvitationImageCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get path => (_$data['path'] as String);
  String? get createdAt => (_$data['createdAt'] as String?);
  String get guestId => (_$data['guestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    final l$guestId = guestId;
    result$data['guestId'] = l$guestId;
    return result$data;
  }

  CopyWith$Input$InvitationImageCreateManyInput<
          Input$InvitationImageCreateManyInput>
      get copyWith => CopyWith$Input$InvitationImageCreateManyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$path,
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      l$guestId,
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageCreateManyInput<TRes> {
  factory CopyWith$Input$InvitationImageCreateManyInput(
    Input$InvitationImageCreateManyInput instance,
    TRes Function(Input$InvitationImageCreateManyInput) then,
  ) = _CopyWithImpl$Input$InvitationImageCreateManyInput;

  factory CopyWith$Input$InvitationImageCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageCreateManyInput;

  TRes call({
    String? id,
    String? path,
    String? createdAt,
    String? guestId,
  });
}

class _CopyWithImpl$Input$InvitationImageCreateManyInput<TRes>
    implements CopyWith$Input$InvitationImageCreateManyInput<TRes> {
  _CopyWithImpl$Input$InvitationImageCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageCreateManyInput _instance;

  final TRes Function(Input$InvitationImageCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$InvitationImageCreateManyInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (path != _undefined && path != null) 'path': (path as String),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (guestId != _undefined && guestId != null)
          'guestId': (guestId as String),
      }));
}

class _CopyWithStubImpl$Input$InvitationImageCreateManyInput<TRes>
    implements CopyWith$Input$InvitationImageCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageCreateManyInput(this._res);

  TRes _res;

  call({
    String? id,
    String? path,
    String? createdAt,
    String? guestId,
  }) =>
      _res;
}

class Input$InvitationImageCreateNestedOneWithoutGuestInput {
  factory Input$InvitationImageCreateNestedOneWithoutGuestInput({
    Input$InvitationImageCreateWithoutGuestInput? create,
    Input$InvitationImageCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$InvitationImageWhereUniqueInput? connect,
  }) =>
      Input$InvitationImageCreateNestedOneWithoutGuestInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$InvitationImageCreateNestedOneWithoutGuestInput._(this._$data);

  factory Input$InvitationImageCreateNestedOneWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$InvitationImageCreateWithoutGuestInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$InvitationImageCreateOrConnectWithoutGuestInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$InvitationImageWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$InvitationImageCreateNestedOneWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$InvitationImageCreateWithoutGuestInput? get create =>
      (_$data['create'] as Input$InvitationImageCreateWithoutGuestInput?);
  Input$InvitationImageCreateOrConnectWithoutGuestInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$InvitationImageCreateOrConnectWithoutGuestInput?);
  Input$InvitationImageWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$InvitationImageWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<
          Input$InvitationImageCreateNestedOneWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageCreateNestedOneWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput(
    Input$InvitationImageCreateNestedOneWithoutGuestInput instance,
    TRes Function(Input$InvitationImageCreateNestedOneWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$InvitationImageCreateNestedOneWithoutGuestInput;

  factory CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$InvitationImageCreateNestedOneWithoutGuestInput;

  TRes call({
    Input$InvitationImageCreateWithoutGuestInput? create,
    Input$InvitationImageCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$InvitationImageWhereUniqueInput? connect,
  });
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create;
  CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate;
  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes>
    implements
        CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$InvitationImageCreateNestedOneWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageCreateNestedOneWithoutGuestInput _instance;

  final TRes Function(Input$InvitationImageCreateNestedOneWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$InvitationImageCreateNestedOneWithoutGuestInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$InvitationImageCreateWithoutGuestInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$InvitationImageCreateOrConnectWithoutGuestInput?),
        if (connect != _undefined)
          'connect': (connect as Input$InvitationImageWhereUniqueInput?),
      }));
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$InvitationImageCreateWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateWithoutGuestInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$InvitationImageWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$InvitationImageWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageCreateNestedOneWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$InvitationImageCreateNestedOneWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageCreateNestedOneWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$InvitationImageCreateWithoutGuestInput? create,
    Input$InvitationImageCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$InvitationImageWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$InvitationImageCreateWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput.stub(
              _res);
  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$InvitationImageWhereUniqueInput.stub(_res);
}

class Input$InvitationImageCreateOrConnectWithoutGuestInput {
  factory Input$InvitationImageCreateOrConnectWithoutGuestInput({
    required Input$InvitationImageWhereUniqueInput where,
    required Input$InvitationImageCreateWithoutGuestInput create,
  }) =>
      Input$InvitationImageCreateOrConnectWithoutGuestInput._({
        r'where': where,
        r'create': create,
      });

  Input$InvitationImageCreateOrConnectWithoutGuestInput._(this._$data);

  factory Input$InvitationImageCreateOrConnectWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$InvitationImageWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$InvitationImageCreateWithoutGuestInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$InvitationImageCreateOrConnectWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$InvitationImageWhereUniqueInput get where =>
      (_$data['where'] as Input$InvitationImageWhereUniqueInput);
  Input$InvitationImageCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$InvitationImageCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<
          Input$InvitationImageCreateOrConnectWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageCreateOrConnectWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput(
    Input$InvitationImageCreateOrConnectWithoutGuestInput instance,
    TRes Function(Input$InvitationImageCreateOrConnectWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$InvitationImageCreateOrConnectWithoutGuestInput;

  factory CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$InvitationImageCreateOrConnectWithoutGuestInput;

  TRes call({
    Input$InvitationImageWhereUniqueInput? where,
    Input$InvitationImageCreateWithoutGuestInput? create,
  });
  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get where;
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes>
    implements
        CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$InvitationImageCreateOrConnectWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageCreateOrConnectWithoutGuestInput _instance;

  final TRes Function(Input$InvitationImageCreateOrConnectWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$InvitationImageCreateOrConnectWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$InvitationImageWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$InvitationImageCreateWithoutGuestInput),
      }));
  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$InvitationImageWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$InvitationImageCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageCreateOrConnectWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageCreateOrConnectWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$InvitationImageWhereUniqueInput? where,
    Input$InvitationImageCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get where =>
      CopyWith$Input$InvitationImageWhereUniqueInput.stub(_res);
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$InvitationImageCreateWithoutGuestInput.stub(_res);
}

class Input$InvitationImageCreateWithoutGuestInput {
  factory Input$InvitationImageCreateWithoutGuestInput({
    String? id,
    required String path,
    String? createdAt,
  }) =>
      Input$InvitationImageCreateWithoutGuestInput._({
        if (id != null) r'id': id,
        r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$InvitationImageCreateWithoutGuestInput._(this._$data);

  factory Input$InvitationImageCreateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    return Input$InvitationImageCreateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get path => (_$data['path'] as String);
  String? get createdAt => (_$data['createdAt'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageCreateWithoutGuestInput<
          Input$InvitationImageCreateWithoutGuestInput>
      get copyWith => CopyWith$Input$InvitationImageCreateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageCreateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$path,
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> {
  factory CopyWith$Input$InvitationImageCreateWithoutGuestInput(
    Input$InvitationImageCreateWithoutGuestInput instance,
    TRes Function(Input$InvitationImageCreateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$InvitationImageCreateWithoutGuestInput;

  factory CopyWith$Input$InvitationImageCreateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageCreateWithoutGuestInput;

  TRes call({
    String? id,
    String? path,
    String? createdAt,
  });
}

class _CopyWithImpl$Input$InvitationImageCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$InvitationImageCreateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageCreateWithoutGuestInput _instance;

  final TRes Function(Input$InvitationImageCreateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$InvitationImageCreateWithoutGuestInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (path != _undefined && path != null) 'path': (path as String),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
      }));
}

class _CopyWithStubImpl$Input$InvitationImageCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageCreateWithoutGuestInput(this._res);

  TRes _res;

  call({
    String? id,
    String? path,
    String? createdAt,
  }) =>
      _res;
}

class Input$InvitationImageMaxAggregateInput {
  factory Input$InvitationImageMaxAggregateInput({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
  }) =>
      Input$InvitationImageMaxAggregateInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        if (guestId != null) r'guestId': guestId,
      });

  Input$InvitationImageMaxAggregateInput._(this._$data);

  factory Input$InvitationImageMaxAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    return Input$InvitationImageMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get path => (_$data['path'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageMaxAggregateInput<
          Input$InvitationImageMaxAggregateInput>
      get copyWith => CopyWith$Input$InvitationImageMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageMaxAggregateInput<TRes> {
  factory CopyWith$Input$InvitationImageMaxAggregateInput(
    Input$InvitationImageMaxAggregateInput instance,
    TRes Function(Input$InvitationImageMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$InvitationImageMaxAggregateInput;

  factory CopyWith$Input$InvitationImageMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageMaxAggregateInput;

  TRes call({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
  });
}

class _CopyWithImpl$Input$InvitationImageMaxAggregateInput<TRes>
    implements CopyWith$Input$InvitationImageMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$InvitationImageMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageMaxAggregateInput _instance;

  final TRes Function(Input$InvitationImageMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$InvitationImageMaxAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (path != _undefined) 'path': (path as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
      }));
}

class _CopyWithStubImpl$Input$InvitationImageMaxAggregateInput<TRes>
    implements CopyWith$Input$InvitationImageMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
  }) =>
      _res;
}

class Input$InvitationImageMinAggregateInput {
  factory Input$InvitationImageMinAggregateInput({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
  }) =>
      Input$InvitationImageMinAggregateInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        if (guestId != null) r'guestId': guestId,
      });

  Input$InvitationImageMinAggregateInput._(this._$data);

  factory Input$InvitationImageMinAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    return Input$InvitationImageMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get path => (_$data['path'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageMinAggregateInput<
          Input$InvitationImageMinAggregateInput>
      get copyWith => CopyWith$Input$InvitationImageMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageMinAggregateInput<TRes> {
  factory CopyWith$Input$InvitationImageMinAggregateInput(
    Input$InvitationImageMinAggregateInput instance,
    TRes Function(Input$InvitationImageMinAggregateInput) then,
  ) = _CopyWithImpl$Input$InvitationImageMinAggregateInput;

  factory CopyWith$Input$InvitationImageMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageMinAggregateInput;

  TRes call({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
  });
}

class _CopyWithImpl$Input$InvitationImageMinAggregateInput<TRes>
    implements CopyWith$Input$InvitationImageMinAggregateInput<TRes> {
  _CopyWithImpl$Input$InvitationImageMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageMinAggregateInput _instance;

  final TRes Function(Input$InvitationImageMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$InvitationImageMinAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (path != _undefined) 'path': (path as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
      }));
}

class _CopyWithStubImpl$Input$InvitationImageMinAggregateInput<TRes>
    implements CopyWith$Input$InvitationImageMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? path,
    bool? createdAt,
    bool? guestId,
  }) =>
      _res;
}

class Input$InvitationImageNullableRelationFilter {
  factory Input$InvitationImageNullableRelationFilter({
    Input$InvitationImageWhereInput? $is,
    Input$InvitationImageWhereInput? isNot,
  }) =>
      Input$InvitationImageNullableRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$InvitationImageNullableRelationFilter._(this._$data);

  factory Input$InvitationImageNullableRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$InvitationImageWhereInput.fromJson(
              (l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$InvitationImageWhereInput.fromJson(
              (l$isNot as Map<String, dynamic>));
    }
    return Input$InvitationImageNullableRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$InvitationImageWhereInput? get $is =>
      (_$data['is'] as Input$InvitationImageWhereInput?);
  Input$InvitationImageWhereInput? get isNot =>
      (_$data['isNot'] as Input$InvitationImageWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageNullableRelationFilter<
          Input$InvitationImageNullableRelationFilter>
      get copyWith => CopyWith$Input$InvitationImageNullableRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageNullableRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageNullableRelationFilter<TRes> {
  factory CopyWith$Input$InvitationImageNullableRelationFilter(
    Input$InvitationImageNullableRelationFilter instance,
    TRes Function(Input$InvitationImageNullableRelationFilter) then,
  ) = _CopyWithImpl$Input$InvitationImageNullableRelationFilter;

  factory CopyWith$Input$InvitationImageNullableRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageNullableRelationFilter;

  TRes call({
    Input$InvitationImageWhereInput? $is,
    Input$InvitationImageWhereInput? isNot,
  });
  CopyWith$Input$InvitationImageWhereInput<TRes> get $is;
  CopyWith$Input$InvitationImageWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$InvitationImageNullableRelationFilter<TRes>
    implements CopyWith$Input$InvitationImageNullableRelationFilter<TRes> {
  _CopyWithImpl$Input$InvitationImageNullableRelationFilter(
    this._instance,
    this._then,
  );

  final Input$InvitationImageNullableRelationFilter _instance;

  final TRes Function(Input$InvitationImageNullableRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$InvitationImageNullableRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$InvitationImageWhereInput?),
        if (isNot != _undefined)
          'isNot': (isNot as Input$InvitationImageWhereInput?),
      }));
  CopyWith$Input$InvitationImageWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$InvitationImageWhereInput.stub(_then(_instance))
        : CopyWith$Input$InvitationImageWhereInput(
            local$$is, (e) => call($is: e));
  }

  CopyWith$Input$InvitationImageWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$InvitationImageWhereInput.stub(_then(_instance))
        : CopyWith$Input$InvitationImageWhereInput(
            local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageNullableRelationFilter<TRes>
    implements CopyWith$Input$InvitationImageNullableRelationFilter<TRes> {
  _CopyWithStubImpl$Input$InvitationImageNullableRelationFilter(this._res);

  TRes _res;

  call({
    Input$InvitationImageWhereInput? $is,
    Input$InvitationImageWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$InvitationImageWhereInput<TRes> get $is =>
      CopyWith$Input$InvitationImageWhereInput.stub(_res);
  CopyWith$Input$InvitationImageWhereInput<TRes> get isNot =>
      CopyWith$Input$InvitationImageWhereInput.stub(_res);
}

class Input$InvitationImageOrderByWithRelationInput {
  factory Input$InvitationImageOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? path,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  }) =>
      Input$InvitationImageOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$InvitationImageOrderByWithRelationInput._(this._$data);

  factory Input$InvitationImageOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] =
          l$path == null ? null : fromJson$Enum$SortOrder((l$path as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : fromJson$Enum$SortOrder((l$guestId as String));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestOrderByWithRelationInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$InvitationImageOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get path => (_$data['path'] as Enum$SortOrder?);
  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);
  Enum$SortOrder? get guestId => (_$data['guestId'] as Enum$SortOrder?);
  Input$GuestOrderByWithRelationInput? get guest =>
      (_$data['guest'] as Input$GuestOrderByWithRelationInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] =
          l$path == null ? null : toJson$Enum$SortOrder(l$path);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] =
          l$guestId == null ? null : toJson$Enum$SortOrder(l$guestId);
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageOrderByWithRelationInput<
          Input$InvitationImageOrderByWithRelationInput>
      get copyWith => CopyWith$Input$InvitationImageOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$InvitationImageOrderByWithRelationInput(
    Input$InvitationImageOrderByWithRelationInput instance,
    TRes Function(Input$InvitationImageOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$InvitationImageOrderByWithRelationInput;

  factory CopyWith$Input$InvitationImageOrderByWithRelationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$InvitationImageOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? path,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  });
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest;
}

class _CopyWithImpl$Input$InvitationImageOrderByWithRelationInput<TRes>
    implements CopyWith$Input$InvitationImageOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$InvitationImageOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageOrderByWithRelationInput _instance;

  final TRes Function(Input$InvitationImageOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$InvitationImageOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (path != _undefined) 'path': (path as Enum$SortOrder?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (guestId != _undefined) 'guestId': (guestId as Enum$SortOrder?),
        if (guest != _undefined)
          'guest': (guest as Input$GuestOrderByWithRelationInput?),
      }));
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$GuestOrderByWithRelationInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageOrderByWithRelationInput<TRes>
    implements CopyWith$Input$InvitationImageOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? path,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest =>
      CopyWith$Input$GuestOrderByWithRelationInput.stub(_res);
}

class Input$InvitationImageUpdateInput {
  factory Input$InvitationImageUpdateInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput? guest,
  }) =>
      Input$InvitationImageUpdateInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        if (guest != null) r'guest': guest,
      });

  Input$InvitationImageUpdateInput._(this._$data);

  factory Input$InvitationImageUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput
              .fromJson((l$guest as Map<String, dynamic>));
    }
    return Input$InvitationImageUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput? get guest =>
      (_$data['guest']
          as Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageUpdateInput<Input$InvitationImageUpdateInput>
      get copyWith => CopyWith$Input$InvitationImageUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageUpdateInput<TRes> {
  factory CopyWith$Input$InvitationImageUpdateInput(
    Input$InvitationImageUpdateInput instance,
    TRes Function(Input$InvitationImageUpdateInput) then,
  ) = _CopyWithImpl$Input$InvitationImageUpdateInput;

  factory CopyWith$Input$InvitationImageUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput? guest,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<TRes>
      get guest;
}

class _CopyWithImpl$Input$InvitationImageUpdateInput<TRes>
    implements CopyWith$Input$InvitationImageUpdateInput<TRes> {
  _CopyWithImpl$Input$InvitationImageUpdateInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageUpdateInput _instance;

  final TRes Function(Input$InvitationImageUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$InvitationImageUpdateInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (guest != _undefined)
          'guest': (guest
              as Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageUpdateInput<TRes>
    implements CopyWith$Input$InvitationImageUpdateInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput? guest,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput<TRes>
      get guest =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutInvitationImageNestedInput
              .stub(_res);
}

class Input$InvitationImageUpdateManyMutationInput {
  factory Input$InvitationImageUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  }) =>
      Input$InvitationImageUpdateManyMutationInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$InvitationImageUpdateManyMutationInput._(this._$data);

  factory Input$InvitationImageUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    return Input$InvitationImageUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageUpdateManyMutationInput<
          Input$InvitationImageUpdateManyMutationInput>
      get copyWith => CopyWith$Input$InvitationImageUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$InvitationImageUpdateManyMutationInput(
    Input$InvitationImageUpdateManyMutationInput instance,
    TRes Function(Input$InvitationImageUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$InvitationImageUpdateManyMutationInput;

  factory CopyWith$Input$InvitationImageUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
}

class _CopyWithImpl$Input$InvitationImageUpdateManyMutationInput<TRes>
    implements CopyWith$Input$InvitationImageUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$InvitationImageUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageUpdateManyMutationInput _instance;

  final TRes Function(Input$InvitationImageUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$InvitationImageUpdateManyMutationInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageUpdateManyMutationInput<TRes>
    implements CopyWith$Input$InvitationImageUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
}

class Input$InvitationImageUpdateOneWithoutGuestNestedInput {
  factory Input$InvitationImageUpdateOneWithoutGuestNestedInput({
    Input$InvitationImageCreateWithoutGuestInput? create,
    Input$InvitationImageCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$InvitationImageUpsertWithoutGuestInput? upsert,
    Input$InvitationImageWhereInput? disconnect,
    Input$InvitationImageWhereInput? delete,
    Input$InvitationImageWhereUniqueInput? connect,
    Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput? update,
  }) =>
      Input$InvitationImageUpdateOneWithoutGuestNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$InvitationImageUpdateOneWithoutGuestNestedInput._(this._$data);

  factory Input$InvitationImageUpdateOneWithoutGuestNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$InvitationImageCreateWithoutGuestInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$InvitationImageCreateOrConnectWithoutGuestInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$InvitationImageUpsertWithoutGuestInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$InvitationImageWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$InvitationImageWhereInput.fromJson(
              (l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$InvitationImageWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$InvitationImageUpdateOneWithoutGuestNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$InvitationImageCreateWithoutGuestInput? get create =>
      (_$data['create'] as Input$InvitationImageCreateWithoutGuestInput?);
  Input$InvitationImageCreateOrConnectWithoutGuestInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$InvitationImageCreateOrConnectWithoutGuestInput?);
  Input$InvitationImageUpsertWithoutGuestInput? get upsert =>
      (_$data['upsert'] as Input$InvitationImageUpsertWithoutGuestInput?);
  Input$InvitationImageWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$InvitationImageWhereInput?);
  Input$InvitationImageWhereInput? get delete =>
      (_$data['delete'] as Input$InvitationImageWhereInput?);
  Input$InvitationImageWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$InvitationImageWhereUniqueInput?);
  Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput? get update =>
      (_$data['update']
          as Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<
          Input$InvitationImageUpdateOneWithoutGuestNestedInput>
      get copyWith =>
          CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageUpdateOneWithoutGuestNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<
    TRes> {
  factory CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
    Input$InvitationImageUpdateOneWithoutGuestNestedInput instance,
    TRes Function(Input$InvitationImageUpdateOneWithoutGuestNestedInput) then,
  ) = _CopyWithImpl$Input$InvitationImageUpdateOneWithoutGuestNestedInput;

  factory CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$InvitationImageUpdateOneWithoutGuestNestedInput;

  TRes call({
    Input$InvitationImageCreateWithoutGuestInput? create,
    Input$InvitationImageCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$InvitationImageUpsertWithoutGuestInput? upsert,
    Input$InvitationImageWhereInput? disconnect,
    Input$InvitationImageWhereInput? delete,
    Input$InvitationImageWhereUniqueInput? connect,
    Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput? update,
  });
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create;
  CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate;
  CopyWith$Input$InvitationImageUpsertWithoutGuestInput<TRes> get upsert;
  CopyWith$Input$InvitationImageWhereInput<TRes> get disconnect;
  CopyWith$Input$InvitationImageWhereInput<TRes> get delete;
  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get connect;
  CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<TRes>
      get update;
}

class _CopyWithImpl$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes>
    implements
        CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes> {
  _CopyWithImpl$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageUpdateOneWithoutGuestNestedInput _instance;

  final TRes Function(Input$InvitationImageUpdateOneWithoutGuestNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$InvitationImageUpdateOneWithoutGuestNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$InvitationImageCreateWithoutGuestInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$InvitationImageCreateOrConnectWithoutGuestInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$InvitationImageUpsertWithoutGuestInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$InvitationImageWhereInput?),
        if (delete != _undefined)
          'delete': (delete as Input$InvitationImageWhereInput?),
        if (connect != _undefined)
          'connect': (connect as Input$InvitationImageWhereUniqueInput?),
        if (update != _undefined)
          'update': (update
              as Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput?),
      }));
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$InvitationImageCreateWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateWithoutGuestInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$InvitationImageUpsertWithoutGuestInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$InvitationImageUpsertWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$InvitationImageUpsertWithoutGuestInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$InvitationImageWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$InvitationImageWhereInput.stub(_then(_instance))
        : CopyWith$Input$InvitationImageWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$InvitationImageWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$InvitationImageWhereInput.stub(_then(_instance))
        : CopyWith$Input$InvitationImageWhereInput(
            local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$InvitationImageWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$InvitationImageWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput
            .stub(_then(_instance))
        : CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageUpdateOneWithoutGuestNestedInput<
        TRes>
    implements
        CopyWith$Input$InvitationImageUpdateOneWithoutGuestNestedInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageUpdateOneWithoutGuestNestedInput(
      this._res);

  TRes _res;

  call({
    Input$InvitationImageCreateWithoutGuestInput? create,
    Input$InvitationImageCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$InvitationImageUpsertWithoutGuestInput? upsert,
    Input$InvitationImageWhereInput? disconnect,
    Input$InvitationImageWhereInput? delete,
    Input$InvitationImageWhereUniqueInput? connect,
    Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput? update,
  }) =>
      _res;
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$InvitationImageCreateWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$InvitationImageCreateOrConnectWithoutGuestInput.stub(
              _res);
  CopyWith$Input$InvitationImageUpsertWithoutGuestInput<TRes> get upsert =>
      CopyWith$Input$InvitationImageUpsertWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageWhereInput<TRes> get disconnect =>
      CopyWith$Input$InvitationImageWhereInput.stub(_res);
  CopyWith$Input$InvitationImageWhereInput<TRes> get delete =>
      CopyWith$Input$InvitationImageWhereInput.stub(_res);
  CopyWith$Input$InvitationImageWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$InvitationImageWhereUniqueInput.stub(_res);
  CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<TRes>
      get update =>
          CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput
              .stub(_res);
}

class Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput {
  factory Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput({
    Input$InvitationImageWhereInput? where,
    required Input$InvitationImageUpdateWithoutGuestInput data,
  }) =>
      Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput._(this._$data);

  factory Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$InvitationImageWhereInput.fromJson(
              (l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$InvitationImageUpdateWithoutGuestInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$InvitationImageWhereInput? get where =>
      (_$data['where'] as Input$InvitationImageWhereInput?);
  Input$InvitationImageUpdateWithoutGuestInput get data =>
      (_$data['data'] as Input$InvitationImageUpdateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<
          Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput(
    Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput instance,
    TRes Function(Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput)
        then,
  ) = _CopyWithImpl$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput;

  factory CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput;

  TRes call({
    Input$InvitationImageWhereInput? where,
    Input$InvitationImageUpdateWithoutGuestInput? data,
  });
  CopyWith$Input$InvitationImageWhereInput<TRes> get where;
  CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> get data;
}

class _CopyWithImpl$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<
            TRes> {
  _CopyWithImpl$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput _instance;

  final TRes Function(
      Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined)
          'where': (where as Input$InvitationImageWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$InvitationImageUpdateWithoutGuestInput),
      }));
  CopyWith$Input$InvitationImageWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$InvitationImageWhereInput.stub(_then(_instance))
        : CopyWith$Input$InvitationImageWhereInput(
            local$where, (e) => call(where: e));
  }

  CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$InvitationImageUpdateWithoutGuestInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput<
            TRes> {
  _CopyWithStubImpl$Input$InvitationImageUpdateToOneWithWhereWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$InvitationImageWhereInput? where,
    Input$InvitationImageUpdateWithoutGuestInput? data,
  }) =>
      _res;
  CopyWith$Input$InvitationImageWhereInput<TRes> get where =>
      CopyWith$Input$InvitationImageWhereInput.stub(_res);
  CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> get data =>
      CopyWith$Input$InvitationImageUpdateWithoutGuestInput.stub(_res);
}

class Input$InvitationImageUpdateWithoutGuestInput {
  factory Input$InvitationImageUpdateWithoutGuestInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  }) =>
      Input$InvitationImageUpdateWithoutGuestInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$InvitationImageUpdateWithoutGuestInput._(this._$data);

  factory Input$InvitationImageUpdateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    return Input$InvitationImageUpdateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageUpdateWithoutGuestInput<
          Input$InvitationImageUpdateWithoutGuestInput>
      get copyWith => CopyWith$Input$InvitationImageUpdateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageUpdateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> {
  factory CopyWith$Input$InvitationImageUpdateWithoutGuestInput(
    Input$InvitationImageUpdateWithoutGuestInput instance,
    TRes Function(Input$InvitationImageUpdateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$InvitationImageUpdateWithoutGuestInput;

  factory CopyWith$Input$InvitationImageUpdateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageUpdateWithoutGuestInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
}

class _CopyWithImpl$Input$InvitationImageUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$InvitationImageUpdateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageUpdateWithoutGuestInput _instance;

  final TRes Function(Input$InvitationImageUpdateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$InvitationImageUpdateWithoutGuestInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageUpdateWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? path,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
}

class Input$InvitationImageUpsertWithoutGuestInput {
  factory Input$InvitationImageUpsertWithoutGuestInput({
    required Input$InvitationImageUpdateWithoutGuestInput update,
    required Input$InvitationImageCreateWithoutGuestInput create,
    Input$InvitationImageWhereInput? where,
  }) =>
      Input$InvitationImageUpsertWithoutGuestInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$InvitationImageUpsertWithoutGuestInput._(this._$data);

  factory Input$InvitationImageUpsertWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$InvitationImageUpdateWithoutGuestInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$InvitationImageCreateWithoutGuestInput.fromJson(
            (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$InvitationImageWhereInput.fromJson(
              (l$where as Map<String, dynamic>));
    }
    return Input$InvitationImageUpsertWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$InvitationImageUpdateWithoutGuestInput get update =>
      (_$data['update'] as Input$InvitationImageUpdateWithoutGuestInput);
  Input$InvitationImageCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$InvitationImageCreateWithoutGuestInput);
  Input$InvitationImageWhereInput? get where =>
      (_$data['where'] as Input$InvitationImageWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageUpsertWithoutGuestInput<
          Input$InvitationImageUpsertWithoutGuestInput>
      get copyWith => CopyWith$Input$InvitationImageUpsertWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageUpsertWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageUpsertWithoutGuestInput<TRes> {
  factory CopyWith$Input$InvitationImageUpsertWithoutGuestInput(
    Input$InvitationImageUpsertWithoutGuestInput instance,
    TRes Function(Input$InvitationImageUpsertWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$InvitationImageUpsertWithoutGuestInput;

  factory CopyWith$Input$InvitationImageUpsertWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageUpsertWithoutGuestInput;

  TRes call({
    Input$InvitationImageUpdateWithoutGuestInput? update,
    Input$InvitationImageCreateWithoutGuestInput? create,
    Input$InvitationImageWhereInput? where,
  });
  CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> get update;
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create;
  CopyWith$Input$InvitationImageWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$InvitationImageUpsertWithoutGuestInput<TRes>
    implements CopyWith$Input$InvitationImageUpsertWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$InvitationImageUpsertWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageUpsertWithoutGuestInput _instance;

  final TRes Function(Input$InvitationImageUpsertWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$InvitationImageUpsertWithoutGuestInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$InvitationImageUpdateWithoutGuestInput),
        if (create != _undefined && create != null)
          'create': (create as Input$InvitationImageCreateWithoutGuestInput),
        if (where != _undefined)
          'where': (where as Input$InvitationImageWhereInput?),
      }));
  CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$InvitationImageUpdateWithoutGuestInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$InvitationImageCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$InvitationImageWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$InvitationImageWhereInput.stub(_then(_instance))
        : CopyWith$Input$InvitationImageWhereInput(
            local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageUpsertWithoutGuestInput<TRes>
    implements CopyWith$Input$InvitationImageUpsertWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageUpsertWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$InvitationImageUpdateWithoutGuestInput? update,
    Input$InvitationImageCreateWithoutGuestInput? create,
    Input$InvitationImageWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$InvitationImageUpdateWithoutGuestInput<TRes> get update =>
      CopyWith$Input$InvitationImageUpdateWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$InvitationImageCreateWithoutGuestInput.stub(_res);
  CopyWith$Input$InvitationImageWhereInput<TRes> get where =>
      CopyWith$Input$InvitationImageWhereInput.stub(_res);
}

class Input$InvitationImageWhereInput {
  factory Input$InvitationImageWhereInput({
    List<Input$InvitationImageWhereInput>? AND,
    List<Input$InvitationImageWhereInput>? OR,
    List<Input$InvitationImageWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? path,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      Input$InvitationImageWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$InvitationImageWhereInput._(this._$data);

  factory Input$InvitationImageWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$InvitationImageWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$InvitationImageWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$InvitationImageWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFilter.fromJson((l$path as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$InvitationImageWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$InvitationImageWhereInput>? get AND =>
      (_$data['AND'] as List<Input$InvitationImageWhereInput>?);
  List<Input$InvitationImageWhereInput>? get OR =>
      (_$data['OR'] as List<Input$InvitationImageWhereInput>?);
  List<Input$InvitationImageWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$InvitationImageWhereInput>?);
  Input$StringFilter? get id => (_$data['id'] as Input$StringFilter?);
  Input$StringFilter? get path => (_$data['path'] as Input$StringFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageWhereInput<Input$InvitationImageWhereInput>
      get copyWith => CopyWith$Input$InvitationImageWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageWhereInput<TRes> {
  factory CopyWith$Input$InvitationImageWhereInput(
    Input$InvitationImageWhereInput instance,
    TRes Function(Input$InvitationImageWhereInput) then,
  ) = _CopyWithImpl$Input$InvitationImageWhereInput;

  factory CopyWith$Input$InvitationImageWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageWhereInput;

  TRes call({
    List<Input$InvitationImageWhereInput>? AND,
    List<Input$InvitationImageWhereInput>? OR,
    List<Input$InvitationImageWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? path,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  });
  TRes AND(
      Iterable<Input$InvitationImageWhereInput>? Function(
              Iterable<
                  CopyWith$Input$InvitationImageWhereInput<
                      Input$InvitationImageWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$InvitationImageWhereInput>? Function(
              Iterable<
                  CopyWith$Input$InvitationImageWhereInput<
                      Input$InvitationImageWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$InvitationImageWhereInput>? Function(
              Iterable<
                  CopyWith$Input$InvitationImageWhereInput<
                      Input$InvitationImageWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get path;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
}

class _CopyWithImpl$Input$InvitationImageWhereInput<TRes>
    implements CopyWith$Input$InvitationImageWhereInput<TRes> {
  _CopyWithImpl$Input$InvitationImageWhereInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageWhereInput _instance;

  final TRes Function(Input$InvitationImageWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$InvitationImageWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$InvitationImageWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$InvitationImageWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$InvitationImageWhereInput>?),
        if (id != _undefined) 'id': (id as Input$StringFilter?),
        if (path != _undefined) 'path': (path as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$InvitationImageWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$InvitationImageWhereInput<
                          Input$InvitationImageWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$InvitationImageWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$InvitationImageWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$InvitationImageWhereInput<
                          Input$InvitationImageWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$InvitationImageWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$InvitationImageWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$InvitationImageWhereInput<
                          Input$InvitationImageWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$InvitationImageWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$StringFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageWhereInput<TRes>
    implements CopyWith$Input$InvitationImageWhereInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageWhereInput(this._res);

  TRes _res;

  call({
    List<Input$InvitationImageWhereInput>? AND,
    List<Input$InvitationImageWhereInput>? OR,
    List<Input$InvitationImageWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? path,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get id =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get path =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
}

class Input$InvitationImageWhereUniqueInput {
  factory Input$InvitationImageWhereUniqueInput({
    String? id,
    String? guestId,
    List<Input$InvitationImageWhereInput>? AND,
    List<Input$InvitationImageWhereInput>? OR,
    List<Input$InvitationImageWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeFilter? createdAt,
    Input$GuestRelationFilter? guest,
  }) =>
      Input$InvitationImageWhereUniqueInput._({
        if (id != null) r'id': id,
        if (guestId != null) r'guestId': guestId,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (path != null) r'path': path,
        if (createdAt != null) r'createdAt': createdAt,
        if (guest != null) r'guest': guest,
      });

  Input$InvitationImageWhereUniqueInput._(this._$data);

  factory Input$InvitationImageWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as String?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$InvitationImageWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$InvitationImageWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$InvitationImageWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFilter.fromJson((l$path as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$InvitationImageWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get guestId => (_$data['guestId'] as String?);
  List<Input$InvitationImageWhereInput>? get AND =>
      (_$data['AND'] as List<Input$InvitationImageWhereInput>?);
  List<Input$InvitationImageWhereInput>? get OR =>
      (_$data['OR'] as List<Input$InvitationImageWhereInput>?);
  List<Input$InvitationImageWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$InvitationImageWhereInput>?);
  Input$StringFilter? get path => (_$data['path'] as Input$StringFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$InvitationImageWhereUniqueInput<
          Input$InvitationImageWhereUniqueInput>
      get copyWith => CopyWith$Input$InvitationImageWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InvitationImageWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$guestId = guestId;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$path = path;
    final l$createdAt = createdAt;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$InvitationImageWhereUniqueInput<TRes> {
  factory CopyWith$Input$InvitationImageWhereUniqueInput(
    Input$InvitationImageWhereUniqueInput instance,
    TRes Function(Input$InvitationImageWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$InvitationImageWhereUniqueInput;

  factory CopyWith$Input$InvitationImageWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InvitationImageWhereUniqueInput;

  TRes call({
    String? id,
    String? guestId,
    List<Input$InvitationImageWhereInput>? AND,
    List<Input$InvitationImageWhereInput>? OR,
    List<Input$InvitationImageWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeFilter? createdAt,
    Input$GuestRelationFilter? guest,
  });
  TRes AND(
      Iterable<Input$InvitationImageWhereInput>? Function(
              Iterable<
                  CopyWith$Input$InvitationImageWhereInput<
                      Input$InvitationImageWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$InvitationImageWhereInput>? Function(
              Iterable<
                  CopyWith$Input$InvitationImageWhereInput<
                      Input$InvitationImageWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$InvitationImageWhereInput>? Function(
              Iterable<
                  CopyWith$Input$InvitationImageWhereInput<
                      Input$InvitationImageWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get path;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
}

class _CopyWithImpl$Input$InvitationImageWhereUniqueInput<TRes>
    implements CopyWith$Input$InvitationImageWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$InvitationImageWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$InvitationImageWhereUniqueInput _instance;

  final TRes Function(Input$InvitationImageWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? guestId = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? path = _undefined,
    Object? createdAt = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$InvitationImageWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (guestId != _undefined) 'guestId': (guestId as String?),
        if (AND != _undefined)
          'AND': (AND as List<Input$InvitationImageWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$InvitationImageWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$InvitationImageWhereInput>?),
        if (path != _undefined) 'path': (path as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$InvitationImageWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$InvitationImageWhereInput<
                          Input$InvitationImageWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$InvitationImageWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$InvitationImageWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$InvitationImageWhereInput<
                          Input$InvitationImageWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$InvitationImageWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$InvitationImageWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$InvitationImageWhereInput<
                          Input$InvitationImageWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$InvitationImageWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$StringFilter<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$InvitationImageWhereUniqueInput<TRes>
    implements CopyWith$Input$InvitationImageWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$InvitationImageWhereUniqueInput(this._res);

  TRes _res;

  call({
    String? id,
    String? guestId,
    List<Input$InvitationImageWhereInput>? AND,
    List<Input$InvitationImageWhereInput>? OR,
    List<Input$InvitationImageWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeFilter? createdAt,
    Input$GuestRelationFilter? guest,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get path =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
}

class Input$LoginArgs {
  factory Input$LoginArgs({
    required String email,
    required String password,
  }) =>
      Input$LoginArgs._({
        r'email': email,
        r'password': password,
      });

  Input$LoginArgs._(this._$data);

  factory Input$LoginArgs.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    return Input$LoginArgs._(result$data);
  }

  Map<String, dynamic> _$data;

  String get email => (_$data['email'] as String);
  String get password => (_$data['password'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$email = email;
    result$data['email'] = l$email;
    final l$password = password;
    result$data['password'] = l$password;
    return result$data;
  }

  CopyWith$Input$LoginArgs<Input$LoginArgs> get copyWith =>
      CopyWith$Input$LoginArgs(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LoginArgs) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$email = email;
    final l$password = password;
    return Object.hashAll([
      l$email,
      l$password,
    ]);
  }
}

abstract class CopyWith$Input$LoginArgs<TRes> {
  factory CopyWith$Input$LoginArgs(
    Input$LoginArgs instance,
    TRes Function(Input$LoginArgs) then,
  ) = _CopyWithImpl$Input$LoginArgs;

  factory CopyWith$Input$LoginArgs.stub(TRes res) =
      _CopyWithStubImpl$Input$LoginArgs;

  TRes call({
    String? email,
    String? password,
  });
}

class _CopyWithImpl$Input$LoginArgs<TRes>
    implements CopyWith$Input$LoginArgs<TRes> {
  _CopyWithImpl$Input$LoginArgs(
    this._instance,
    this._then,
  );

  final Input$LoginArgs _instance;

  final TRes Function(Input$LoginArgs) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? email = _undefined,
    Object? password = _undefined,
  }) =>
      _then(Input$LoginArgs._({
        ..._instance._$data,
        if (email != _undefined && email != null) 'email': (email as String),
        if (password != _undefined && password != null)
          'password': (password as String),
      }));
}

class _CopyWithStubImpl$Input$LoginArgs<TRes>
    implements CopyWith$Input$LoginArgs<TRes> {
  _CopyWithStubImpl$Input$LoginArgs(this._res);

  TRes _res;

  call({
    String? email,
    String? password,
  }) =>
      _res;
}

class Input$NestedDateTimeFilter {
  factory Input$NestedDateTimeFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      Input$NestedDateTimeFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedDateTimeFilter._(this._$data);

  factory Input$NestedDateTimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedDateTimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedDateTimeFilter<Input$NestedDateTimeFilter>
      get copyWith => CopyWith$Input$NestedDateTimeFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedDateTimeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedDateTimeFilter<TRes> {
  factory CopyWith$Input$NestedDateTimeFilter(
    Input$NestedDateTimeFilter instance,
    TRes Function(Input$NestedDateTimeFilter) then,
  ) = _CopyWithImpl$Input$NestedDateTimeFilter;

  factory CopyWith$Input$NestedDateTimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedDateTimeFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  });
  CopyWith$Input$NestedDateTimeFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedDateTimeFilter<TRes>
    implements CopyWith$Input$NestedDateTimeFilter<TRes> {
  _CopyWithImpl$Input$NestedDateTimeFilter(
    this._instance,
    this._then,
  );

  final Input$NestedDateTimeFilter _instance;

  final TRes Function(Input$NestedDateTimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedDateTimeFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined) 'not': (not as Input$NestedDateTimeFilter?),
      }));
  CopyWith$Input$NestedDateTimeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedDateTimeFilter<TRes>
    implements CopyWith$Input$NestedDateTimeFilter<TRes> {
  _CopyWithStubImpl$Input$NestedDateTimeFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$NestedDateTimeNullableFilter {
  factory Input$NestedDateTimeNullableFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  }) =>
      Input$NestedDateTimeNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedDateTimeNullableFilter._(this._$data);

  factory Input$NestedDateTimeNullableFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedDateTimeNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeNullableFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedDateTimeNullableFilter<
          Input$NestedDateTimeNullableFilter>
      get copyWith => CopyWith$Input$NestedDateTimeNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedDateTimeNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedDateTimeNullableFilter<TRes> {
  factory CopyWith$Input$NestedDateTimeNullableFilter(
    Input$NestedDateTimeNullableFilter instance,
    TRes Function(Input$NestedDateTimeNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedDateTimeNullableFilter;

  factory CopyWith$Input$NestedDateTimeNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedDateTimeNullableFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  });
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedDateTimeNullableFilter<TRes>
    implements CopyWith$Input$NestedDateTimeNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedDateTimeNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedDateTimeNullableFilter _instance;

  final TRes Function(Input$NestedDateTimeNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedDateTimeNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedDateTimeNullableFilter?),
      }));
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedDateTimeNullableFilter<TRes>
    implements CopyWith$Input$NestedDateTimeNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedDateTimeNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeNullableFilter.stub(_res);
}

class Input$NestedEnumConfirmationStatusNullableFilter {
  factory Input$NestedEnumConfirmationStatusNullableFilter({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusNullableFilter? not,
  }) =>
      Input$NestedEnumConfirmationStatusNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$NestedEnumConfirmationStatusNullableFilter._(this._$data);

  factory Input$NestedEnumConfirmationStatusNullableFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConfirmationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConfirmationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumConfirmationStatusNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedEnumConfirmationStatusNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ConfirmationStatus? get equals =>
      (_$data['equals'] as Enum$ConfirmationStatus?);
  List<Enum$ConfirmationStatus>? get $in =>
      (_$data['in'] as List<Enum$ConfirmationStatus>?);
  List<Enum$ConfirmationStatus>? get notIn =>
      (_$data['notIn'] as List<Enum$ConfirmationStatus>?);
  Input$NestedEnumConfirmationStatusNullableFilter? get not =>
      (_$data['not'] as Input$NestedEnumConfirmationStatusNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$ConfirmationStatus(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$ConfirmationStatus(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$ConfirmationStatus(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<
          Input$NestedEnumConfirmationStatusNullableFilter>
      get copyWith => CopyWith$Input$NestedEnumConfirmationStatusNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedEnumConfirmationStatusNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> {
  factory CopyWith$Input$NestedEnumConfirmationStatusNullableFilter(
    Input$NestedEnumConfirmationStatusNullableFilter instance,
    TRes Function(Input$NestedEnumConfirmationStatusNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedEnumConfirmationStatusNullableFilter;

  factory CopyWith$Input$NestedEnumConfirmationStatusNullableFilter.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NestedEnumConfirmationStatusNullableFilter;

  TRes call({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusNullableFilter? not,
  });
  CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedEnumConfirmationStatusNullableFilter<TRes>
    implements CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedEnumConfirmationStatusNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedEnumConfirmationStatusNullableFilter _instance;

  final TRes Function(Input$NestedEnumConfirmationStatusNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedEnumConfirmationStatusNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined)
          'equals': (equals as Enum$ConfirmationStatus?),
        if ($in != _undefined) 'in': ($in as List<Enum$ConfirmationStatus>?),
        if (notIn != _undefined)
          'notIn': (notIn as List<Enum$ConfirmationStatus>?),
        if (not != _undefined)
          'not': (not as Input$NestedEnumConfirmationStatusNullableFilter?),
      }));
  CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumConfirmationStatusNullableFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedEnumConfirmationStatusNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedEnumConfirmationStatusNullableFilter<TRes>
    implements CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedEnumConfirmationStatusNullableFilter(this._res);

  TRes _res;

  call({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumConfirmationStatusNullableFilter<TRes> get not =>
      CopyWith$Input$NestedEnumConfirmationStatusNullableFilter.stub(_res);
}

class Input$NestedEnumQueueStatusFilter {
  factory Input$NestedEnumQueueStatusFilter({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  }) =>
      Input$NestedEnumQueueStatusFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$NestedEnumQueueStatusFilter._(this._$data);

  factory Input$NestedEnumQueueStatusFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$QueueStatus((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$QueueStatus((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$QueueStatus((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumQueueStatusFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedEnumQueueStatusFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$QueueStatus? get equals => (_$data['equals'] as Enum$QueueStatus?);
  List<Enum$QueueStatus>? get $in => (_$data['in'] as List<Enum$QueueStatus>?);
  List<Enum$QueueStatus>? get notIn =>
      (_$data['notIn'] as List<Enum$QueueStatus>?);
  Input$NestedEnumQueueStatusFilter? get not =>
      (_$data['not'] as Input$NestedEnumQueueStatusFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$QueueStatus(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$QueueStatus(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$QueueStatus(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedEnumQueueStatusFilter<Input$NestedEnumQueueStatusFilter>
      get copyWith => CopyWith$Input$NestedEnumQueueStatusFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedEnumQueueStatusFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedEnumQueueStatusFilter<TRes> {
  factory CopyWith$Input$NestedEnumQueueStatusFilter(
    Input$NestedEnumQueueStatusFilter instance,
    TRes Function(Input$NestedEnumQueueStatusFilter) then,
  ) = _CopyWithImpl$Input$NestedEnumQueueStatusFilter;

  factory CopyWith$Input$NestedEnumQueueStatusFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedEnumQueueStatusFilter;

  TRes call({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  });
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedEnumQueueStatusFilter<TRes>
    implements CopyWith$Input$NestedEnumQueueStatusFilter<TRes> {
  _CopyWithImpl$Input$NestedEnumQueueStatusFilter(
    this._instance,
    this._then,
  );

  final Input$NestedEnumQueueStatusFilter _instance;

  final TRes Function(Input$NestedEnumQueueStatusFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedEnumQueueStatusFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as Enum$QueueStatus?),
        if ($in != _undefined) 'in': ($in as List<Enum$QueueStatus>?),
        if (notIn != _undefined) 'notIn': (notIn as List<Enum$QueueStatus>?),
        if (not != _undefined)
          'not': (not as Input$NestedEnumQueueStatusFilter?),
      }));
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$NestedEnumQueueStatusFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedEnumQueueStatusFilter<TRes>
    implements CopyWith$Input$NestedEnumQueueStatusFilter<TRes> {
  _CopyWithStubImpl$Input$NestedEnumQueueStatusFilter(this._res);

  TRes _res;

  call({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not =>
      CopyWith$Input$NestedEnumQueueStatusFilter.stub(_res);
}

class Input$NestedEnumUserRoleFilter {
  factory Input$NestedEnumUserRoleFilter({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  }) =>
      Input$NestedEnumUserRoleFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$NestedEnumUserRoleFilter._(this._$data);

  factory Input$NestedEnumUserRoleFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$UserRole((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumUserRoleFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedEnumUserRoleFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserRole? get equals => (_$data['equals'] as Enum$UserRole?);
  List<Enum$UserRole>? get $in => (_$data['in'] as List<Enum$UserRole>?);
  List<Enum$UserRole>? get notIn => (_$data['notIn'] as List<Enum$UserRole>?);
  Input$NestedEnumUserRoleFilter? get not =>
      (_$data['not'] as Input$NestedEnumUserRoleFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$UserRole(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedEnumUserRoleFilter<Input$NestedEnumUserRoleFilter>
      get copyWith => CopyWith$Input$NestedEnumUserRoleFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedEnumUserRoleFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedEnumUserRoleFilter<TRes> {
  factory CopyWith$Input$NestedEnumUserRoleFilter(
    Input$NestedEnumUserRoleFilter instance,
    TRes Function(Input$NestedEnumUserRoleFilter) then,
  ) = _CopyWithImpl$Input$NestedEnumUserRoleFilter;

  factory CopyWith$Input$NestedEnumUserRoleFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedEnumUserRoleFilter;

  TRes call({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  });
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedEnumUserRoleFilter<TRes>
    implements CopyWith$Input$NestedEnumUserRoleFilter<TRes> {
  _CopyWithImpl$Input$NestedEnumUserRoleFilter(
    this._instance,
    this._then,
  );

  final Input$NestedEnumUserRoleFilter _instance;

  final TRes Function(Input$NestedEnumUserRoleFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedEnumUserRoleFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as Enum$UserRole?),
        if ($in != _undefined) 'in': ($in as List<Enum$UserRole>?),
        if (notIn != _undefined) 'notIn': (notIn as List<Enum$UserRole>?),
        if (not != _undefined) 'not': (not as Input$NestedEnumUserRoleFilter?),
      }));
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$NestedEnumUserRoleFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedEnumUserRoleFilter<TRes>
    implements CopyWith$Input$NestedEnumUserRoleFilter<TRes> {
  _CopyWithStubImpl$Input$NestedEnumUserRoleFilter(this._res);

  TRes _res;

  call({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not =>
      CopyWith$Input$NestedEnumUserRoleFilter.stub(_res);
}

class Input$NestedFloatNullableFilter {
  factory Input$NestedFloatNullableFilter({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatNullableFilter? not,
  }) =>
      Input$NestedFloatNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedFloatNullableFilter._(this._$data);

  factory Input$NestedFloatNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedFloatNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedFloatNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get equals => (_$data['equals'] as double?);
  List<double>? get $in => (_$data['in'] as List<double>?);
  List<double>? get notIn => (_$data['notIn'] as List<double>?);
  double? get lt => (_$data['lt'] as double?);
  double? get lte => (_$data['lte'] as double?);
  double? get gt => (_$data['gt'] as double?);
  double? get gte => (_$data['gte'] as double?);
  Input$NestedFloatNullableFilter? get not =>
      (_$data['not'] as Input$NestedFloatNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedFloatNullableFilter<Input$NestedFloatNullableFilter>
      get copyWith => CopyWith$Input$NestedFloatNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedFloatNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedFloatNullableFilter<TRes> {
  factory CopyWith$Input$NestedFloatNullableFilter(
    Input$NestedFloatNullableFilter instance,
    TRes Function(Input$NestedFloatNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedFloatNullableFilter;

  factory CopyWith$Input$NestedFloatNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedFloatNullableFilter;

  TRes call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatNullableFilter? not,
  });
  CopyWith$Input$NestedFloatNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedFloatNullableFilter<TRes>
    implements CopyWith$Input$NestedFloatNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedFloatNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedFloatNullableFilter _instance;

  final TRes Function(Input$NestedFloatNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedFloatNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if (notIn != _undefined) 'notIn': (notIn as List<double>?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if (not != _undefined) 'not': (not as Input$NestedFloatNullableFilter?),
      }));
  CopyWith$Input$NestedFloatNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedFloatNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedFloatNullableFilter<TRes>
    implements CopyWith$Input$NestedFloatNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedFloatNullableFilter(this._res);

  TRes _res;

  call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedFloatNullableFilter<TRes> get not =>
      CopyWith$Input$NestedFloatNullableFilter.stub(_res);
}

class Input$NestedIntFilter {
  factory Input$NestedIntFilter({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      Input$NestedIntFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedIntFilter._(this._$data);

  factory Input$NestedIntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NestedIntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  List<int>? get notIn => (_$data['notIn'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  Input$NestedIntFilter? get not => (_$data['not'] as Input$NestedIntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedIntFilter<Input$NestedIntFilter> get copyWith =>
      CopyWith$Input$NestedIntFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedIntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedIntFilter<TRes> {
  factory CopyWith$Input$NestedIntFilter(
    Input$NestedIntFilter instance,
    TRes Function(Input$NestedIntFilter) then,
  ) = _CopyWithImpl$Input$NestedIntFilter;

  factory CopyWith$Input$NestedIntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedIntFilter;

  TRes call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  });
  CopyWith$Input$NestedIntFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedIntFilter<TRes>
    implements CopyWith$Input$NestedIntFilter<TRes> {
  _CopyWithImpl$Input$NestedIntFilter(
    this._instance,
    this._then,
  );

  final Input$NestedIntFilter _instance;

  final TRes Function(Input$NestedIntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedIntFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntFilter?),
      }));
  CopyWith$Input$NestedIntFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedIntFilter<TRes>
    implements CopyWith$Input$NestedIntFilter<TRes> {
  _CopyWithStubImpl$Input$NestedIntFilter(this._res);

  TRes _res;

  call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedIntFilter<TRes> get not =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$NestedStringFilter {
  factory Input$NestedStringFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      Input$NestedStringFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$NestedStringFilter._(this._$data);

  factory Input$NestedStringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NestedStringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringFilter? get not =>
      (_$data['not'] as Input$NestedStringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedStringFilter<Input$NestedStringFilter> get copyWith =>
      CopyWith$Input$NestedStringFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringFilter<TRes> {
  factory CopyWith$Input$NestedStringFilter(
    Input$NestedStringFilter instance,
    TRes Function(Input$NestedStringFilter) then,
  ) = _CopyWithImpl$Input$NestedStringFilter;

  factory CopyWith$Input$NestedStringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  });
  CopyWith$Input$NestedStringFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringFilter<TRes>
    implements CopyWith$Input$NestedStringFilter<TRes> {
  _CopyWithImpl$Input$NestedStringFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringFilter _instance;

  final TRes Function(Input$NestedStringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedStringFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined) 'not': (not as Input$NestedStringFilter?),
      }));
  CopyWith$Input$NestedStringFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringFilter<TRes>
    implements CopyWith$Input$NestedStringFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringFilter<TRes> get not =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$NestedStringNullableFilter {
  factory Input$NestedStringNullableFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  }) =>
      Input$NestedStringNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$NestedStringNullableFilter._(this._$data);

  factory Input$NestedStringNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedStringNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringNullableFilter? get not =>
      (_$data['not'] as Input$NestedStringNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedStringNullableFilter<Input$NestedStringNullableFilter>
      get copyWith => CopyWith$Input$NestedStringNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringNullableFilter<TRes> {
  factory CopyWith$Input$NestedStringNullableFilter(
    Input$NestedStringNullableFilter instance,
    TRes Function(Input$NestedStringNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedStringNullableFilter;

  factory CopyWith$Input$NestedStringNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringNullableFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  });
  CopyWith$Input$NestedStringNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringNullableFilter<TRes>
    implements CopyWith$Input$NestedStringNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedStringNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringNullableFilter _instance;

  final TRes Function(Input$NestedStringNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedStringNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringNullableFilter?),
      }));
  CopyWith$Input$NestedStringNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringNullableFilter<TRes>
    implements CopyWith$Input$NestedStringNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringNullableFilter<TRes> get not =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);
}

class Input$NullableDateTimeFieldUpdateOperationsInput {
  factory Input$NullableDateTimeFieldUpdateOperationsInput({String? $set}) =>
      Input$NullableDateTimeFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$NullableDateTimeFieldUpdateOperationsInput._(this._$data);

  factory Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$NullableDateTimeFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<
          Input$NullableDateTimeFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NullableDateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
    Input$NullableDateTimeFieldUpdateOperationsInput instance,
    TRes Function(Input$NullableDateTimeFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$NullableDateTimeFieldUpdateOperationsInput;

  factory CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NullableDateTimeFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$NullableDateTimeFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$NullableDateTimeFieldUpdateOperationsInput _instance;

  final TRes Function(Input$NullableDateTimeFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$NullableDateTimeFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$NullableDateTimeFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput {
  factory Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
          {Enum$ConfirmationStatus? $set}) =>
      Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput._(this._$data);

  factory Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = l$$set == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$$set as String));
    }
    return Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ConfirmationStatus? get $set =>
      (_$data['set'] as Enum$ConfirmationStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] =
          l$$set == null ? null : toJson$Enum$ConfirmationStatus(l$$set);
    }
    return result$data;
  }

  CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<
          Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput>
      get copyWith =>
          CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<
    TRes> {
  factory CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
    Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput instance,
    TRes Function(
            Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput)
        then,
  ) = _CopyWithImpl$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput;

  factory CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput;

  TRes call({Enum$ConfirmationStatus? $set});
}

class _CopyWithImpl$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<
        TRes>
    implements
        CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<
            TRes> {
  _CopyWithImpl$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput
      _instance;

  final TRes Function(
      Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as Enum$ConfirmationStatus?),
      }));
}

class _CopyWithStubImpl$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<
        TRes>
    implements
        CopyWith$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput<
            TRes> {
  _CopyWithStubImpl$Input$NullableEnumConfirmationStatusFieldUpdateOperationsInput(
      this._res);

  TRes _res;

  call({Enum$ConfirmationStatus? $set}) => _res;
}

class Input$NullableFloatFieldUpdateOperationsInput {
  factory Input$NullableFloatFieldUpdateOperationsInput({
    double? $set,
    double? increment,
    double? decrement,
    double? multiply,
    double? divide,
  }) =>
      Input$NullableFloatFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
        if (increment != null) r'increment': increment,
        if (decrement != null) r'decrement': decrement,
        if (multiply != null) r'multiply': multiply,
        if (divide != null) r'divide': divide,
      });

  Input$NullableFloatFieldUpdateOperationsInput._(this._$data);

  factory Input$NullableFloatFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as num?)?.toDouble();
    }
    if (data.containsKey('increment')) {
      final l$increment = data['increment'];
      result$data['increment'] = (l$increment as num?)?.toDouble();
    }
    if (data.containsKey('decrement')) {
      final l$decrement = data['decrement'];
      result$data['decrement'] = (l$decrement as num?)?.toDouble();
    }
    if (data.containsKey('multiply')) {
      final l$multiply = data['multiply'];
      result$data['multiply'] = (l$multiply as num?)?.toDouble();
    }
    if (data.containsKey('divide')) {
      final l$divide = data['divide'];
      result$data['divide'] = (l$divide as num?)?.toDouble();
    }
    return Input$NullableFloatFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get $set => (_$data['set'] as double?);
  double? get increment => (_$data['increment'] as double?);
  double? get decrement => (_$data['decrement'] as double?);
  double? get multiply => (_$data['multiply'] as double?);
  double? get divide => (_$data['divide'] as double?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    if (_$data.containsKey('increment')) {
      final l$increment = increment;
      result$data['increment'] = l$increment;
    }
    if (_$data.containsKey('decrement')) {
      final l$decrement = decrement;
      result$data['decrement'] = l$decrement;
    }
    if (_$data.containsKey('multiply')) {
      final l$multiply = multiply;
      result$data['multiply'] = l$multiply;
    }
    if (_$data.containsKey('divide')) {
      final l$divide = divide;
      result$data['divide'] = l$divide;
    }
    return result$data;
  }

  CopyWith$Input$NullableFloatFieldUpdateOperationsInput<
          Input$NullableFloatFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NullableFloatFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (_$data.containsKey('increment') !=
        other._$data.containsKey('increment')) {
      return false;
    }
    if (l$increment != lOther$increment) {
      return false;
    }
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (_$data.containsKey('decrement') !=
        other._$data.containsKey('decrement')) {
      return false;
    }
    if (l$decrement != lOther$decrement) {
      return false;
    }
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (_$data.containsKey('multiply') !=
        other._$data.containsKey('multiply')) {
      return false;
    }
    if (l$multiply != lOther$multiply) {
      return false;
    }
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (_$data.containsKey('divide') != other._$data.containsKey('divide')) {
      return false;
    }
    if (l$divide != lOther$divide) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll([
      _$data.containsKey('set') ? l$$set : const {},
      _$data.containsKey('increment') ? l$increment : const {},
      _$data.containsKey('decrement') ? l$decrement : const {},
      _$data.containsKey('multiply') ? l$multiply : const {},
      _$data.containsKey('divide') ? l$divide : const {},
    ]);
  }
}

abstract class CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$NullableFloatFieldUpdateOperationsInput(
    Input$NullableFloatFieldUpdateOperationsInput instance,
    TRes Function(Input$NullableFloatFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$NullableFloatFieldUpdateOperationsInput;

  factory CopyWith$Input$NullableFloatFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NullableFloatFieldUpdateOperationsInput;

  TRes call({
    double? $set,
    double? increment,
    double? decrement,
    double? multiply,
    double? divide,
  });
}

class _CopyWithImpl$Input$NullableFloatFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$NullableFloatFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$NullableFloatFieldUpdateOperationsInput _instance;

  final TRes Function(Input$NullableFloatFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $set = _undefined,
    Object? increment = _undefined,
    Object? decrement = _undefined,
    Object? multiply = _undefined,
    Object? divide = _undefined,
  }) =>
      _then(Input$NullableFloatFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as double?),
        if (increment != _undefined) 'increment': (increment as double?),
        if (decrement != _undefined) 'decrement': (decrement as double?),
        if (multiply != _undefined) 'multiply': (multiply as double?),
        if (divide != _undefined) 'divide': (divide as double?),
      }));
}

class _CopyWithStubImpl$Input$NullableFloatFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableFloatFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$NullableFloatFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({
    double? $set,
    double? increment,
    double? decrement,
    double? multiply,
    double? divide,
  }) =>
      _res;
}

class Input$NullableStringFieldUpdateOperationsInput {
  factory Input$NullableStringFieldUpdateOperationsInput({String? $set}) =>
      Input$NullableStringFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$NullableStringFieldUpdateOperationsInput._(this._$data);

  factory Input$NullableStringFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$NullableStringFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<
          Input$NullableStringFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NullableStringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$NullableStringFieldUpdateOperationsInput(
    Input$NullableStringFieldUpdateOperationsInput instance,
    TRes Function(Input$NullableStringFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput;

  factory CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$NullableStringFieldUpdateOperationsInput _instance;

  final TRes Function(Input$NullableStringFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$NullableStringFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$QrCodeAvgAggregateInput {
  factory Input$QrCodeAvgAggregateInput({
    bool? id,
    bool? raceConditionValue,
  }) =>
      Input$QrCodeAvgAggregateInput._({
        if (id != null) r'id': id,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
      });

  Input$QrCodeAvgAggregateInput._(this._$data);

  factory Input$QrCodeAvgAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as bool?);
    }
    return Input$QrCodeAvgAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get raceConditionValue => (_$data['raceConditionValue'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeAvgAggregateInput<Input$QrCodeAvgAggregateInput>
      get copyWith => CopyWith$Input$QrCodeAvgAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeAvgAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$raceConditionValue = raceConditionValue;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeAvgAggregateInput<TRes> {
  factory CopyWith$Input$QrCodeAvgAggregateInput(
    Input$QrCodeAvgAggregateInput instance,
    TRes Function(Input$QrCodeAvgAggregateInput) then,
  ) = _CopyWithImpl$Input$QrCodeAvgAggregateInput;

  factory CopyWith$Input$QrCodeAvgAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeAvgAggregateInput;

  TRes call({
    bool? id,
    bool? raceConditionValue,
  });
}

class _CopyWithImpl$Input$QrCodeAvgAggregateInput<TRes>
    implements CopyWith$Input$QrCodeAvgAggregateInput<TRes> {
  _CopyWithImpl$Input$QrCodeAvgAggregateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeAvgAggregateInput _instance;

  final TRes Function(Input$QrCodeAvgAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? raceConditionValue = _undefined,
  }) =>
      _then(Input$QrCodeAvgAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as bool?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeAvgAggregateInput<TRes>
    implements CopyWith$Input$QrCodeAvgAggregateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeAvgAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? raceConditionValue,
  }) =>
      _res;
}

class Input$QrCodeCountAggregateInput {
  factory Input$QrCodeCountAggregateInput({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
    bool? $_all,
  }) =>
      Input$QrCodeCountAggregateInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (guestId != null) r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
        if ($_all != null) r'_all': $_all,
      });

  Input$QrCodeCountAggregateInput._(this._$data);

  factory Input$QrCodeCountAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as bool?);
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = (l$scannedByUserId as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$QrCodeCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get path => (_$data['path'] as bool?);
  bool? get scannedAt => (_$data['scannedAt'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get raceConditionValue => (_$data['raceConditionValue'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  bool? get scannedByUserId => (_$data['scannedByUserId'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCountAggregateInput<Input$QrCodeCountAggregateInput>
      get copyWith => CopyWith$Input$QrCodeCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCountAggregateInput<TRes> {
  factory CopyWith$Input$QrCodeCountAggregateInput(
    Input$QrCodeCountAggregateInput instance,
    TRes Function(Input$QrCodeCountAggregateInput) then,
  ) = _CopyWithImpl$Input$QrCodeCountAggregateInput;

  factory CopyWith$Input$QrCodeCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCountAggregateInput;

  TRes call({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$QrCodeCountAggregateInput<TRes>
    implements CopyWith$Input$QrCodeCountAggregateInput<TRes> {
  _CopyWithImpl$Input$QrCodeCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCountAggregateInput _instance;

  final TRes Function(Input$QrCodeCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$QrCodeCountAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (path != _undefined) 'path': (path as bool?),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeCountAggregateInput<TRes>
    implements CopyWith$Input$QrCodeCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
    bool? $_all,
  }) =>
      _res;
}

class Input$QrCodeCreateInput {
  factory Input$QrCodeCreateInput({
    required String path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    required Input$GuestCreateNestedOneWithoutQrcodeInput guest,
    Input$UserCreateNestedOneWithoutScannedQrsInput? scannedBy,
  }) =>
      Input$QrCodeCreateInput._({
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        r'guest': guest,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeCreateInput._(this._$data);

  factory Input$QrCodeCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as int?);
    }
    final l$guest = data['guest'];
    result$data['guest'] =
        Input$GuestCreateNestedOneWithoutQrcodeInput.fromJson(
            (l$guest as Map<String, dynamic>));
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserCreateNestedOneWithoutScannedQrsInput.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  int? get raceConditionValue => (_$data['raceConditionValue'] as int?);
  Input$GuestCreateNestedOneWithoutQrcodeInput get guest =>
      (_$data['guest'] as Input$GuestCreateNestedOneWithoutQrcodeInput);
  Input$UserCreateNestedOneWithoutScannedQrsInput? get scannedBy =>
      (_$data['scannedBy'] as Input$UserCreateNestedOneWithoutScannedQrsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    final l$guest = guest;
    result$data['guest'] = l$guest.toJson();
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateInput<Input$QrCodeCreateInput> get copyWith =>
      CopyWith$Input$QrCodeCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (l$guest != lOther$guest) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guest = guest;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      l$guest,
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateInput<TRes> {
  factory CopyWith$Input$QrCodeCreateInput(
    Input$QrCodeCreateInput instance,
    TRes Function(Input$QrCodeCreateInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateInput;

  factory CopyWith$Input$QrCodeCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateInput;

  TRes call({
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    Input$GuestCreateNestedOneWithoutQrcodeInput? guest,
    Input$UserCreateNestedOneWithoutScannedQrsInput? scannedBy,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> get guest;
  CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeCreateInput<TRes>
    implements CopyWith$Input$QrCodeCreateInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateInput _instance;

  final TRes Function(Input$QrCodeCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guest = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeCreateInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as int?),
        if (guest != _undefined && guest != null)
          'guest': (guest as Input$GuestCreateNestedOneWithoutQrcodeInput),
        if (scannedBy != _undefined)
          'scannedBy':
              (scannedBy as Input$UserCreateNestedOneWithoutScannedQrsInput?),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> get guest {
    final local$guest = _instance.guest;
    return CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput(
        local$guest, (e) => call(guest: e));
  }

  CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateInput<TRes>
    implements CopyWith$Input$QrCodeCreateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateInput(this._res);

  TRes _res;

  call({
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    Input$GuestCreateNestedOneWithoutQrcodeInput? guest,
    Input$UserCreateNestedOneWithoutScannedQrsInput? scannedBy,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> get guest =>
      CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput.stub(_res);
  CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes>
      get scannedBy =>
          CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput.stub(_res);
}

class Input$QrCodeCreateManyInput {
  factory Input$QrCodeCreateManyInput({
    int? id,
    required String path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    required String guestId,
    String? scannedByUserId,
  }) =>
      Input$QrCodeCreateManyInput._({
        if (id != null) r'id': id,
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
      });

  Input$QrCodeCreateManyInput._(this._$data);

  factory Input$QrCodeCreateManyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as int?);
    }
    final l$guestId = data['guestId'];
    result$data['guestId'] = (l$guestId as String);
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = (l$scannedByUserId as String?);
    }
    return Input$QrCodeCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  int? get raceConditionValue => (_$data['raceConditionValue'] as int?);
  String get guestId => (_$data['guestId'] as String);
  String? get scannedByUserId => (_$data['scannedByUserId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    final l$guestId = guestId;
    result$data['guestId'] = l$guestId;
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateManyInput<Input$QrCodeCreateManyInput>
      get copyWith => CopyWith$Input$QrCodeCreateManyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      l$guestId,
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateManyInput<TRes> {
  factory CopyWith$Input$QrCodeCreateManyInput(
    Input$QrCodeCreateManyInput instance,
    TRes Function(Input$QrCodeCreateManyInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateManyInput;

  factory CopyWith$Input$QrCodeCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateManyInput;

  TRes call({
    int? id,
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    String? guestId,
    String? scannedByUserId,
  });
}

class _CopyWithImpl$Input$QrCodeCreateManyInput<TRes>
    implements CopyWith$Input$QrCodeCreateManyInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateManyInput _instance;

  final TRes Function(Input$QrCodeCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
  }) =>
      _then(Input$QrCodeCreateManyInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as int?),
        if (guestId != _undefined && guestId != null)
          'guestId': (guestId as String),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as String?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeCreateManyInput<TRes>
    implements CopyWith$Input$QrCodeCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateManyInput(this._res);

  TRes _res;

  call({
    int? id,
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    String? guestId,
    String? scannedByUserId,
  }) =>
      _res;
}

class Input$QrCodeCreateManyScannedByInput {
  factory Input$QrCodeCreateManyScannedByInput({
    int? id,
    required String path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    required String guestId,
  }) =>
      Input$QrCodeCreateManyScannedByInput._({
        if (id != null) r'id': id,
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        r'guestId': guestId,
      });

  Input$QrCodeCreateManyScannedByInput._(this._$data);

  factory Input$QrCodeCreateManyScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as int?);
    }
    final l$guestId = data['guestId'];
    result$data['guestId'] = (l$guestId as String);
    return Input$QrCodeCreateManyScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  int? get raceConditionValue => (_$data['raceConditionValue'] as int?);
  String get guestId => (_$data['guestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    final l$guestId = guestId;
    result$data['guestId'] = l$guestId;
    return result$data;
  }

  CopyWith$Input$QrCodeCreateManyScannedByInput<
          Input$QrCodeCreateManyScannedByInput>
      get copyWith => CopyWith$Input$QrCodeCreateManyScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateManyScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      l$guestId,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateManyScannedByInput<TRes> {
  factory CopyWith$Input$QrCodeCreateManyScannedByInput(
    Input$QrCodeCreateManyScannedByInput instance,
    TRes Function(Input$QrCodeCreateManyScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateManyScannedByInput;

  factory CopyWith$Input$QrCodeCreateManyScannedByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInput;

  TRes call({
    int? id,
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    String? guestId,
  });
}

class _CopyWithImpl$Input$QrCodeCreateManyScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateManyScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateManyScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateManyScannedByInput _instance;

  final TRes Function(Input$QrCodeCreateManyScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$QrCodeCreateManyScannedByInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as int?),
        if (guestId != _undefined && guestId != null)
          'guestId': (guestId as String),
      }));
}

class _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateManyScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInput(this._res);

  TRes _res;

  call({
    int? id,
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    String? guestId,
  }) =>
      _res;
}

class Input$QrCodeCreateManyScannedByInputEnvelope {
  factory Input$QrCodeCreateManyScannedByInputEnvelope({
    required List<Input$QrCodeCreateManyScannedByInput> data,
    bool? skipDuplicates,
  }) =>
      Input$QrCodeCreateManyScannedByInputEnvelope._({
        r'data': data,
        if (skipDuplicates != null) r'skipDuplicates': skipDuplicates,
      });

  Input$QrCodeCreateManyScannedByInputEnvelope._(this._$data);

  factory Input$QrCodeCreateManyScannedByInputEnvelope.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => Input$QrCodeCreateManyScannedByInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = data['skipDuplicates'];
      result$data['skipDuplicates'] = (l$skipDuplicates as bool?);
    }
    return Input$QrCodeCreateManyScannedByInputEnvelope._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateManyScannedByInput> get data =>
      (_$data['data'] as List<Input$QrCodeCreateManyScannedByInput>);
  bool? get skipDuplicates => (_$data['skipDuplicates'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = skipDuplicates;
      result$data['skipDuplicates'] = l$skipDuplicates;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<
          Input$QrCodeCreateManyScannedByInputEnvelope>
      get copyWith => CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateManyScannedByInputEnvelope) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (_$data.containsKey('skipDuplicates') !=
        other._$data.containsKey('skipDuplicates')) {
      return false;
    }
    if (l$skipDuplicates != lOther$skipDuplicates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('skipDuplicates') ? l$skipDuplicates : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> {
  factory CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope(
    Input$QrCodeCreateManyScannedByInputEnvelope instance,
    TRes Function(Input$QrCodeCreateManyScannedByInputEnvelope) then,
  ) = _CopyWithImpl$Input$QrCodeCreateManyScannedByInputEnvelope;

  factory CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInputEnvelope;

  TRes call({
    List<Input$QrCodeCreateManyScannedByInput>? data,
    bool? skipDuplicates,
  });
  TRes data(
      Iterable<Input$QrCodeCreateManyScannedByInput> Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateManyScannedByInput<
                      Input$QrCodeCreateManyScannedByInput>>)
          _fn);
}

class _CopyWithImpl$Input$QrCodeCreateManyScannedByInputEnvelope<TRes>
    implements CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> {
  _CopyWithImpl$Input$QrCodeCreateManyScannedByInputEnvelope(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateManyScannedByInputEnvelope _instance;

  final TRes Function(Input$QrCodeCreateManyScannedByInputEnvelope) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? skipDuplicates = _undefined,
  }) =>
      _then(Input$QrCodeCreateManyScannedByInputEnvelope._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<Input$QrCodeCreateManyScannedByInput>),
        if (skipDuplicates != _undefined)
          'skipDuplicates': (skipDuplicates as bool?),
      }));
  TRes data(
          Iterable<Input$QrCodeCreateManyScannedByInput> Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateManyScannedByInput<
                          Input$QrCodeCreateManyScannedByInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$Input$QrCodeCreateManyScannedByInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInputEnvelope<TRes>
    implements CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInputEnvelope(this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateManyScannedByInput>? data,
    bool? skipDuplicates,
  }) =>
      _res;
  data(_fn) => _res;
}

class Input$QrCodeCreateNestedManyWithoutScannedByInput {
  factory Input$QrCodeCreateNestedManyWithoutScannedByInput({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  }) =>
      Input$QrCodeCreateNestedManyWithoutScannedByInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (createMany != null) r'createMany': createMany,
        if (connect != null) r'connect': connect,
      });

  Input$QrCodeCreateNestedManyWithoutScannedByInput._(this._$data);

  factory Input$QrCodeCreateNestedManyWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$QrCodeCreateWithoutScannedByInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeCreateOrConnectWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$QrCodeCreateManyScannedByInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$QrCodeCreateNestedManyWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateWithoutScannedByInput>? get create =>
      (_$data['create'] as List<Input$QrCodeCreateWithoutScannedByInput>?);
  List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$QrCodeCreateOrConnectWithoutScannedByInput>?);
  Input$QrCodeCreateManyScannedByInputEnvelope? get createMany =>
      (_$data['createMany'] as Input$QrCodeCreateManyScannedByInputEnvelope?);
  List<Input$QrCodeWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$QrCodeWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<
          Input$QrCodeCreateNestedManyWithoutScannedByInput>
      get copyWith =>
          CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateNestedManyWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<
    TRes> {
  factory CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput(
    Input$QrCodeCreateNestedManyWithoutScannedByInput instance,
    TRes Function(Input$QrCodeCreateNestedManyWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput;

  factory CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput;

  TRes call({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$QrCodeCreateWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateWithoutScannedByInput<
                      Input$QrCodeCreateWithoutScannedByInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$QrCodeCreateOrConnectWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
                      Input$QrCodeCreateOrConnectWithoutScannedByInput>>?)
          _fn);
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany;
  TRes connect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateNestedManyWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeCreateNestedManyWithoutScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? createMany = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$QrCodeCreateNestedManyWithoutScannedByInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$QrCodeCreateWithoutScannedByInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$QrCodeCreateOrConnectWithoutScannedByInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$QrCodeCreateManyScannedByInputEnvelope?),
        if (connect != _undefined)
          'connect': (connect as List<Input$QrCodeWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$QrCodeCreateWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateWithoutScannedByInput<
                          Input$QrCodeCreateWithoutScannedByInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$QrCodeCreateWithoutScannedByInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$QrCodeCreateOrConnectWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
                          Input$QrCodeCreateOrConnectWithoutScannedByInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes connect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput(
      this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany =>
      CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(_res);
  connect(_fn) => _res;
}

class Input$QrCodeCreateNestedOneWithoutGuestInput {
  factory Input$QrCodeCreateNestedOneWithoutGuestInput({
    Input$QrCodeCreateWithoutGuestInput? create,
    Input$QrCodeCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$QrCodeWhereUniqueInput? connect,
  }) =>
      Input$QrCodeCreateNestedOneWithoutGuestInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$QrCodeCreateNestedOneWithoutGuestInput._(this._$data);

  factory Input$QrCodeCreateNestedOneWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$QrCodeCreateWithoutGuestInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$QrCodeCreateOrConnectWithoutGuestInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$QrCodeWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$QrCodeCreateNestedOneWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeCreateWithoutGuestInput? get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutGuestInput?);
  Input$QrCodeCreateOrConnectWithoutGuestInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$QrCodeCreateOrConnectWithoutGuestInput?);
  Input$QrCodeWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$QrCodeWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<
          Input$QrCodeCreateNestedOneWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateNestedOneWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput(
    Input$QrCodeCreateNestedOneWithoutGuestInput instance,
    TRes Function(Input$QrCodeCreateNestedOneWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateNestedOneWithoutGuestInput;

  factory CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateNestedOneWithoutGuestInput;

  TRes call({
    Input$QrCodeCreateWithoutGuestInput? create,
    Input$QrCodeCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$QrCodeWhereUniqueInput? connect,
  });
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create;
  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateNestedOneWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateNestedOneWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeCreateNestedOneWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$QrCodeCreateNestedOneWithoutGuestInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$QrCodeCreateWithoutGuestInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$QrCodeCreateOrConnectWithoutGuestInput?),
        if (connect != _undefined)
          'connect': (connect as Input$QrCodeWhereUniqueInput?),
      }));
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeCreateWithoutGuestInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$QrCodeWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateNestedOneWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateNestedOneWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$QrCodeCreateWithoutGuestInput? create,
    Input$QrCodeCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$QrCodeWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(_res);
  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput.stub(_res);
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
}

class Input$QrCodeCreateOrConnectWithoutGuestInput {
  factory Input$QrCodeCreateOrConnectWithoutGuestInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeCreateWithoutGuestInput create,
  }) =>
      Input$QrCodeCreateOrConnectWithoutGuestInput._({
        r'where': where,
        r'create': create,
      });

  Input$QrCodeCreateOrConnectWithoutGuestInput._(this._$data);

  factory Input$QrCodeCreateOrConnectWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$QrCodeCreateWithoutGuestInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$QrCodeCreateOrConnectWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<
          Input$QrCodeCreateOrConnectWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateOrConnectWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput(
    Input$QrCodeCreateOrConnectWithoutGuestInput instance,
    TRes Function(Input$QrCodeCreateOrConnectWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutGuestInput;

  factory CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutGuestInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeCreateWithoutGuestInput? create,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateOrConnectWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeCreateOrConnectWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$QrCodeCreateOrConnectWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$QrCodeCreateWithoutGuestInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$QrCodeCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(_res);
}

class Input$QrCodeCreateOrConnectWithoutScannedByInput {
  factory Input$QrCodeCreateOrConnectWithoutScannedByInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeCreateWithoutScannedByInput create,
  }) =>
      Input$QrCodeCreateOrConnectWithoutScannedByInput._({
        r'where': where,
        r'create': create,
      });

  Input$QrCodeCreateOrConnectWithoutScannedByInput._(this._$data);

  factory Input$QrCodeCreateOrConnectWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$QrCodeCreateWithoutScannedByInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$QrCodeCreateOrConnectWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeCreateWithoutScannedByInput get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutScannedByInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
          Input$QrCodeCreateOrConnectWithoutScannedByInput>
      get copyWith => CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateOrConnectWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes> {
  factory CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput(
    Input$QrCodeCreateOrConnectWithoutScannedByInput instance,
    TRes Function(Input$QrCodeCreateOrConnectWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput;

  factory CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeCreateWithoutScannedByInput? create,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create;
}

class _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateOrConnectWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeCreateOrConnectWithoutScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$QrCodeCreateOrConnectWithoutScannedByInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$QrCodeCreateWithoutScannedByInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$QrCodeCreateWithoutScannedByInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput(this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeCreateWithoutScannedByInput? create,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutScannedByInput.stub(_res);
}

class Input$QrCodeCreateWithoutGuestInput {
  factory Input$QrCodeCreateWithoutGuestInput({
    required String path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    Input$UserCreateNestedOneWithoutScannedQrsInput? scannedBy,
  }) =>
      Input$QrCodeCreateWithoutGuestInput._({
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeCreateWithoutGuestInput._(this._$data);

  factory Input$QrCodeCreateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as int?);
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserCreateNestedOneWithoutScannedQrsInput.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeCreateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  int? get raceConditionValue => (_$data['raceConditionValue'] as int?);
  Input$UserCreateNestedOneWithoutScannedQrsInput? get scannedBy =>
      (_$data['scannedBy'] as Input$UserCreateNestedOneWithoutScannedQrsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateWithoutGuestInput<
          Input$QrCodeCreateWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeCreateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeCreateWithoutGuestInput(
    Input$QrCodeCreateWithoutGuestInput instance,
    TRes Function(Input$QrCodeCreateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateWithoutGuestInput;

  factory CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateWithoutGuestInput;

  TRes call({
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    Input$UserCreateNestedOneWithoutScannedQrsInput? scannedBy,
  });
  CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeCreateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeCreateWithoutGuestInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as int?),
        if (scannedBy != _undefined)
          'scannedBy':
              (scannedBy as Input$UserCreateNestedOneWithoutScannedQrsInput?),
      }));
  CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateWithoutGuestInput(this._res);

  TRes _res;

  call({
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    Input$UserCreateNestedOneWithoutScannedQrsInput? scannedBy,
  }) =>
      _res;
  CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes>
      get scannedBy =>
          CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput.stub(_res);
}

class Input$QrCodeCreateWithoutScannedByInput {
  factory Input$QrCodeCreateWithoutScannedByInput({
    required String path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    required Input$GuestCreateNestedOneWithoutQrcodeInput guest,
  }) =>
      Input$QrCodeCreateWithoutScannedByInput._({
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        r'guest': guest,
      });

  Input$QrCodeCreateWithoutScannedByInput._(this._$data);

  factory Input$QrCodeCreateWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as int?);
    }
    final l$guest = data['guest'];
    result$data['guest'] =
        Input$GuestCreateNestedOneWithoutQrcodeInput.fromJson(
            (l$guest as Map<String, dynamic>));
    return Input$QrCodeCreateWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  int? get raceConditionValue => (_$data['raceConditionValue'] as int?);
  Input$GuestCreateNestedOneWithoutQrcodeInput get guest =>
      (_$data['guest'] as Input$GuestCreateNestedOneWithoutQrcodeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    final l$guest = guest;
    result$data['guest'] = l$guest.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeCreateWithoutScannedByInput<
          Input$QrCodeCreateWithoutScannedByInput>
      get copyWith => CopyWith$Input$QrCodeCreateWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guest = guest;
    return Object.hashAll([
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      l$guest,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> {
  factory CopyWith$Input$QrCodeCreateWithoutScannedByInput(
    Input$QrCodeCreateWithoutScannedByInput instance,
    TRes Function(Input$QrCodeCreateWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateWithoutScannedByInput;

  factory CopyWith$Input$QrCodeCreateWithoutScannedByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateWithoutScannedByInput;

  TRes call({
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    Input$GuestCreateNestedOneWithoutQrcodeInput? guest,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> get guest;
}

class _CopyWithImpl$Input$QrCodeCreateWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeCreateWithoutScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$QrCodeCreateWithoutScannedByInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as int?),
        if (guest != _undefined && guest != null)
          'guest': (guest as Input$GuestCreateNestedOneWithoutQrcodeInput),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> get guest {
    final local$guest = _instance.guest;
    return CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput(
        local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateWithoutScannedByInput(this._res);

  TRes _res;

  call({
    String? path,
    String? scannedAt,
    String? createdAt,
    int? raceConditionValue,
    Input$GuestCreateNestedOneWithoutQrcodeInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput<TRes> get guest =>
      CopyWith$Input$GuestCreateNestedOneWithoutQrcodeInput.stub(_res);
}

class Input$QrCodeListRelationFilter {
  factory Input$QrCodeListRelationFilter({
    Input$QrCodeWhereInput? every,
    Input$QrCodeWhereInput? some,
    Input$QrCodeWhereInput? none,
  }) =>
      Input$QrCodeListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$QrCodeListRelationFilter._(this._$data);

  factory Input$QrCodeListRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$none as Map<String, dynamic>));
    }
    return Input$QrCodeListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereInput? get every =>
      (_$data['every'] as Input$QrCodeWhereInput?);
  Input$QrCodeWhereInput? get some =>
      (_$data['some'] as Input$QrCodeWhereInput?);
  Input$QrCodeWhereInput? get none =>
      (_$data['none'] as Input$QrCodeWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeListRelationFilter<Input$QrCodeListRelationFilter>
      get copyWith => CopyWith$Input$QrCodeListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeListRelationFilter<TRes> {
  factory CopyWith$Input$QrCodeListRelationFilter(
    Input$QrCodeListRelationFilter instance,
    TRes Function(Input$QrCodeListRelationFilter) then,
  ) = _CopyWithImpl$Input$QrCodeListRelationFilter;

  factory CopyWith$Input$QrCodeListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeListRelationFilter;

  TRes call({
    Input$QrCodeWhereInput? every,
    Input$QrCodeWhereInput? some,
    Input$QrCodeWhereInput? none,
  });
  CopyWith$Input$QrCodeWhereInput<TRes> get every;
  CopyWith$Input$QrCodeWhereInput<TRes> get some;
  CopyWith$Input$QrCodeWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$QrCodeListRelationFilter<TRes>
    implements CopyWith$Input$QrCodeListRelationFilter<TRes> {
  _CopyWithImpl$Input$QrCodeListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$QrCodeListRelationFilter _instance;

  final TRes Function(Input$QrCodeListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$QrCodeListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined) 'every': (every as Input$QrCodeWhereInput?),
        if (some != _undefined) 'some': (some as Input$QrCodeWhereInput?),
        if (none != _undefined) 'none': (none as Input$QrCodeWhereInput?),
      }));
  CopyWith$Input$QrCodeWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$every, (e) => call(every: e));
  }

  CopyWith$Input$QrCodeWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$some, (e) => call(some: e));
  }

  CopyWith$Input$QrCodeWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeListRelationFilter<TRes>
    implements CopyWith$Input$QrCodeListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$QrCodeListRelationFilter(this._res);

  TRes _res;

  call({
    Input$QrCodeWhereInput? every,
    Input$QrCodeWhereInput? some,
    Input$QrCodeWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereInput<TRes> get every =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
  CopyWith$Input$QrCodeWhereInput<TRes> get some =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
  CopyWith$Input$QrCodeWhereInput<TRes> get none =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
}

class Input$QrCodeMaxAggregateInput {
  factory Input$QrCodeMaxAggregateInput({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
  }) =>
      Input$QrCodeMaxAggregateInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (guestId != null) r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
      });

  Input$QrCodeMaxAggregateInput._(this._$data);

  factory Input$QrCodeMaxAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as bool?);
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = (l$scannedByUserId as bool?);
    }
    return Input$QrCodeMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get path => (_$data['path'] as bool?);
  bool? get scannedAt => (_$data['scannedAt'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get raceConditionValue => (_$data['raceConditionValue'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  bool? get scannedByUserId => (_$data['scannedByUserId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeMaxAggregateInput<Input$QrCodeMaxAggregateInput>
      get copyWith => CopyWith$Input$QrCodeMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeMaxAggregateInput<TRes> {
  factory CopyWith$Input$QrCodeMaxAggregateInput(
    Input$QrCodeMaxAggregateInput instance,
    TRes Function(Input$QrCodeMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$QrCodeMaxAggregateInput;

  factory CopyWith$Input$QrCodeMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeMaxAggregateInput;

  TRes call({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
  });
}

class _CopyWithImpl$Input$QrCodeMaxAggregateInput<TRes>
    implements CopyWith$Input$QrCodeMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$QrCodeMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeMaxAggregateInput _instance;

  final TRes Function(Input$QrCodeMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
  }) =>
      _then(Input$QrCodeMaxAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (path != _undefined) 'path': (path as bool?),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as bool?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeMaxAggregateInput<TRes>
    implements CopyWith$Input$QrCodeMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
  }) =>
      _res;
}

class Input$QrCodeMinAggregateInput {
  factory Input$QrCodeMinAggregateInput({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
  }) =>
      Input$QrCodeMinAggregateInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (guestId != null) r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
      });

  Input$QrCodeMinAggregateInput._(this._$data);

  factory Input$QrCodeMinAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as bool?);
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = (l$scannedByUserId as bool?);
    }
    return Input$QrCodeMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get path => (_$data['path'] as bool?);
  bool? get scannedAt => (_$data['scannedAt'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get raceConditionValue => (_$data['raceConditionValue'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  bool? get scannedByUserId => (_$data['scannedByUserId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeMinAggregateInput<Input$QrCodeMinAggregateInput>
      get copyWith => CopyWith$Input$QrCodeMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeMinAggregateInput<TRes> {
  factory CopyWith$Input$QrCodeMinAggregateInput(
    Input$QrCodeMinAggregateInput instance,
    TRes Function(Input$QrCodeMinAggregateInput) then,
  ) = _CopyWithImpl$Input$QrCodeMinAggregateInput;

  factory CopyWith$Input$QrCodeMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeMinAggregateInput;

  TRes call({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
  });
}

class _CopyWithImpl$Input$QrCodeMinAggregateInput<TRes>
    implements CopyWith$Input$QrCodeMinAggregateInput<TRes> {
  _CopyWithImpl$Input$QrCodeMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeMinAggregateInput _instance;

  final TRes Function(Input$QrCodeMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
  }) =>
      _then(Input$QrCodeMinAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (path != _undefined) 'path': (path as bool?),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as bool?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeMinAggregateInput<TRes>
    implements CopyWith$Input$QrCodeMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? path,
    bool? scannedAt,
    bool? createdAt,
    bool? raceConditionValue,
    bool? guestId,
    bool? scannedByUserId,
  }) =>
      _res;
}

class Input$QrCodeNullableRelationFilter {
  factory Input$QrCodeNullableRelationFilter({
    Input$QrCodeWhereInput? $is,
    Input$QrCodeWhereInput? isNot,
  }) =>
      Input$QrCodeNullableRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$QrCodeNullableRelationFilter._(this._$data);

  factory Input$QrCodeNullableRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$QrCodeNullableRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereInput? get $is => (_$data['is'] as Input$QrCodeWhereInput?);
  Input$QrCodeWhereInput? get isNot =>
      (_$data['isNot'] as Input$QrCodeWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeNullableRelationFilter<
          Input$QrCodeNullableRelationFilter>
      get copyWith => CopyWith$Input$QrCodeNullableRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeNullableRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeNullableRelationFilter<TRes> {
  factory CopyWith$Input$QrCodeNullableRelationFilter(
    Input$QrCodeNullableRelationFilter instance,
    TRes Function(Input$QrCodeNullableRelationFilter) then,
  ) = _CopyWithImpl$Input$QrCodeNullableRelationFilter;

  factory CopyWith$Input$QrCodeNullableRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeNullableRelationFilter;

  TRes call({
    Input$QrCodeWhereInput? $is,
    Input$QrCodeWhereInput? isNot,
  });
  CopyWith$Input$QrCodeWhereInput<TRes> get $is;
  CopyWith$Input$QrCodeWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$QrCodeNullableRelationFilter<TRes>
    implements CopyWith$Input$QrCodeNullableRelationFilter<TRes> {
  _CopyWithImpl$Input$QrCodeNullableRelationFilter(
    this._instance,
    this._then,
  );

  final Input$QrCodeNullableRelationFilter _instance;

  final TRes Function(Input$QrCodeNullableRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$QrCodeNullableRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$QrCodeWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$QrCodeWhereInput?),
      }));
  CopyWith$Input$QrCodeWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$QrCodeWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeNullableRelationFilter<TRes>
    implements CopyWith$Input$QrCodeNullableRelationFilter<TRes> {
  _CopyWithStubImpl$Input$QrCodeNullableRelationFilter(this._res);

  TRes _res;

  call({
    Input$QrCodeWhereInput? $is,
    Input$QrCodeWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereInput<TRes> get $is =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
  CopyWith$Input$QrCodeWhereInput<TRes> get isNot =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
}

class Input$QrCodeOrderByRelationAggregateInput {
  factory Input$QrCodeOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$QrCodeOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$QrCodeOrderByRelationAggregateInput._(this._$data);

  factory Input$QrCodeOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$QrCodeOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$QrCodeOrderByRelationAggregateInput<
          Input$QrCodeOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$QrCodeOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$QrCodeOrderByRelationAggregateInput(
    Input$QrCodeOrderByRelationAggregateInput instance,
    TRes Function(Input$QrCodeOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$QrCodeOrderByRelationAggregateInput;

  factory CopyWith$Input$QrCodeOrderByRelationAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$QrCodeOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$QrCodeOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeOrderByRelationAggregateInput _instance;

  final TRes Function(Input$QrCodeOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$QrCodeOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$QrCodeOrderByWithRelationInput {
  factory Input$QrCodeOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? path,
    Input$SortOrderInput? scannedAt,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? raceConditionValue,
    Enum$SortOrder? guestId,
    Input$SortOrderInput? scannedByUserId,
    Input$GuestOrderByWithRelationInput? guest,
    Input$UserOrderByWithRelationInput? scannedBy,
  }) =>
      Input$QrCodeOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (guestId != null) r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
        if (guest != null) r'guest': guest,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeOrderByWithRelationInput._(this._$data);

  factory Input$QrCodeOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] =
          l$path == null ? null : fromJson$Enum$SortOrder((l$path as String));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : fromJson$Enum$SortOrder((l$raceConditionValue as String));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : fromJson$Enum$SortOrder((l$guestId as String));
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = l$scannedByUserId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$scannedByUserId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestOrderByWithRelationInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserOrderByWithRelationInput.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get path => (_$data['path'] as Enum$SortOrder?);
  Input$SortOrderInput? get scannedAt =>
      (_$data['scannedAt'] as Input$SortOrderInput?);
  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);
  Enum$SortOrder? get raceConditionValue =>
      (_$data['raceConditionValue'] as Enum$SortOrder?);
  Enum$SortOrder? get guestId => (_$data['guestId'] as Enum$SortOrder?);
  Input$SortOrderInput? get scannedByUserId =>
      (_$data['scannedByUserId'] as Input$SortOrderInput?);
  Input$GuestOrderByWithRelationInput? get guest =>
      (_$data['guest'] as Input$GuestOrderByWithRelationInput?);
  Input$UserOrderByWithRelationInput? get scannedBy =>
      (_$data['scannedBy'] as Input$UserOrderByWithRelationInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] =
          l$path == null ? null : toJson$Enum$SortOrder(l$path);
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : toJson$Enum$SortOrder(l$raceConditionValue);
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] =
          l$guestId == null ? null : toJson$Enum$SortOrder(l$guestId);
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeOrderByWithRelationInput<
          Input$QrCodeOrderByWithRelationInput>
      get copyWith => CopyWith$Input$QrCodeOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    final l$guest = guest;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$QrCodeOrderByWithRelationInput(
    Input$QrCodeOrderByWithRelationInput instance,
    TRes Function(Input$QrCodeOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$QrCodeOrderByWithRelationInput;

  factory CopyWith$Input$QrCodeOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? path,
    Input$SortOrderInput? scannedAt,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? raceConditionValue,
    Enum$SortOrder? guestId,
    Input$SortOrderInput? scannedByUserId,
    Input$GuestOrderByWithRelationInput? guest,
    Input$UserOrderByWithRelationInput? scannedBy,
  });
  CopyWith$Input$SortOrderInput<TRes> get scannedAt;
  CopyWith$Input$SortOrderInput<TRes> get scannedByUserId;
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest;
  CopyWith$Input$UserOrderByWithRelationInput<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeOrderByWithRelationInput<TRes>
    implements CopyWith$Input$QrCodeOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$QrCodeOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeOrderByWithRelationInput _instance;

  final TRes Function(Input$QrCodeOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
    Object? guest = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (path != _undefined) 'path': (path as Enum$SortOrder?),
        if (scannedAt != _undefined)
          'scannedAt': (scannedAt as Input$SortOrderInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as Enum$SortOrder?),
        if (guestId != _undefined) 'guestId': (guestId as Enum$SortOrder?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as Input$SortOrderInput?),
        if (guest != _undefined)
          'guest': (guest as Input$GuestOrderByWithRelationInput?),
        if (scannedBy != _undefined)
          'scannedBy': (scannedBy as Input$UserOrderByWithRelationInput?),
      }));
  CopyWith$Input$SortOrderInput<TRes> get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get scannedByUserId {
    final local$scannedByUserId = _instance.scannedByUserId;
    return local$scannedByUserId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$scannedByUserId, (e) => call(scannedByUserId: e));
  }

  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$GuestOrderByWithRelationInput(
            local$guest, (e) => call(guest: e));
  }

  CopyWith$Input$UserOrderByWithRelationInput<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$UserOrderByWithRelationInput(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeOrderByWithRelationInput<TRes>
    implements CopyWith$Input$QrCodeOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? path,
    Input$SortOrderInput? scannedAt,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? raceConditionValue,
    Enum$SortOrder? guestId,
    Input$SortOrderInput? scannedByUserId,
    Input$GuestOrderByWithRelationInput? guest,
    Input$UserOrderByWithRelationInput? scannedBy,
  }) =>
      _res;
  CopyWith$Input$SortOrderInput<TRes> get scannedAt =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get scannedByUserId =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest =>
      CopyWith$Input$GuestOrderByWithRelationInput.stub(_res);
  CopyWith$Input$UserOrderByWithRelationInput<TRes> get scannedBy =>
      CopyWith$Input$UserOrderByWithRelationInput.stub(_res);
}

class Input$QrCodeScalarWhereInput {
  factory Input$QrCodeScalarWhereInput({
    List<Input$QrCodeScalarWhereInput>? AND,
    List<Input$QrCodeScalarWhereInput>? OR,
    List<Input$QrCodeScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
  }) =>
      Input$QrCodeScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (guestId != null) r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
      });

  Input$QrCodeScalarWhereInput._(this._$data);

  factory Input$QrCodeScalarWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFilter.fromJson((l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : Input$IntFilter.fromJson(
              (l$raceConditionValue as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = l$scannedByUserId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$scannedByUserId as Map<String, dynamic>));
    }
    return Input$QrCodeScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$QrCodeScalarWhereInput>?);
  List<Input$QrCodeScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$QrCodeScalarWhereInput>?);
  List<Input$QrCodeScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$QrCodeScalarWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$StringFilter? get path => (_$data['path'] as Input$StringFilter?);
  Input$DateTimeNullableFilter? get scannedAt =>
      (_$data['scannedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$IntFilter? get raceConditionValue =>
      (_$data['raceConditionValue'] as Input$IntFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$StringNullableFilter? get scannedByUserId =>
      (_$data['scannedByUserId'] as Input$StringNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeScalarWhereInput<Input$QrCodeScalarWhereInput>
      get copyWith => CopyWith$Input$QrCodeScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeScalarWhereInput<TRes> {
  factory CopyWith$Input$QrCodeScalarWhereInput(
    Input$QrCodeScalarWhereInput instance,
    TRes Function(Input$QrCodeScalarWhereInput) then,
  ) = _CopyWithImpl$Input$QrCodeScalarWhereInput;

  factory CopyWith$Input$QrCodeScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeScalarWhereInput;

  TRes call({
    List<Input$QrCodeScalarWhereInput>? AND,
    List<Input$QrCodeScalarWhereInput>? OR,
    List<Input$QrCodeScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
  });
  TRes AND(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get path;
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$IntFilter<TRes> get raceConditionValue;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId;
}

class _CopyWithImpl$Input$QrCodeScalarWhereInput<TRes>
    implements CopyWith$Input$QrCodeScalarWhereInput<TRes> {
  _CopyWithImpl$Input$QrCodeScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeScalarWhereInput _instance;

  final TRes Function(Input$QrCodeScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
  }) =>
      _then(Input$QrCodeScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$QrCodeScalarWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$QrCodeScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$QrCodeScalarWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (path != _undefined) 'path': (path as Input$StringFilter?),
        if (scannedAt != _undefined)
          'scannedAt': (scannedAt as Input$DateTimeNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as Input$IntFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as Input$StringNullableFilter?),
      }));
  TRes AND(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IntFilter<TRes> get raceConditionValue {
    final local$raceConditionValue = _instance.raceConditionValue;
    return local$raceConditionValue == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$raceConditionValue, (e) => call(raceConditionValue: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId {
    final local$scannedByUserId = _instance.scannedByUserId;
    return local$scannedByUserId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$scannedByUserId, (e) => call(scannedByUserId: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeScalarWhereInput<TRes>
    implements CopyWith$Input$QrCodeScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$QrCodeScalarWhereInput>? AND,
    List<Input$QrCodeScalarWhereInput>? OR,
    List<Input$QrCodeScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get path =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get raceConditionValue =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
}

class Input$QrCodeSumAggregateInput {
  factory Input$QrCodeSumAggregateInput({
    bool? id,
    bool? raceConditionValue,
  }) =>
      Input$QrCodeSumAggregateInput._({
        if (id != null) r'id': id,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
      });

  Input$QrCodeSumAggregateInput._(this._$data);

  factory Input$QrCodeSumAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = (l$raceConditionValue as bool?);
    }
    return Input$QrCodeSumAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get raceConditionValue => (_$data['raceConditionValue'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeSumAggregateInput<Input$QrCodeSumAggregateInput>
      get copyWith => CopyWith$Input$QrCodeSumAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeSumAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$raceConditionValue = raceConditionValue;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeSumAggregateInput<TRes> {
  factory CopyWith$Input$QrCodeSumAggregateInput(
    Input$QrCodeSumAggregateInput instance,
    TRes Function(Input$QrCodeSumAggregateInput) then,
  ) = _CopyWithImpl$Input$QrCodeSumAggregateInput;

  factory CopyWith$Input$QrCodeSumAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeSumAggregateInput;

  TRes call({
    bool? id,
    bool? raceConditionValue,
  });
}

class _CopyWithImpl$Input$QrCodeSumAggregateInput<TRes>
    implements CopyWith$Input$QrCodeSumAggregateInput<TRes> {
  _CopyWithImpl$Input$QrCodeSumAggregateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeSumAggregateInput _instance;

  final TRes Function(Input$QrCodeSumAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? raceConditionValue = _undefined,
  }) =>
      _then(Input$QrCodeSumAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as bool?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeSumAggregateInput<TRes>
    implements CopyWith$Input$QrCodeSumAggregateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeSumAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? raceConditionValue,
  }) =>
      _res;
}

class Input$QrCodeUpdateInput {
  factory Input$QrCodeUpdateInput({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput? guest,
    Input$UserUpdateOneWithoutScannedQrsNestedInput? scannedBy,
  }) =>
      Input$QrCodeUpdateInput._({
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (guest != null) r'guest': guest,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeUpdateInput._(this._$data);

  factory Input$QrCodeUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$raceConditionValue as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserUpdateOneWithoutScannedQrsNestedInput.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get scannedAt =>
      (_$data['scannedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get raceConditionValue =>
      (_$data['raceConditionValue'] as Input$IntFieldUpdateOperationsInput?);
  Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput? get guest =>
      (_$data['guest']
          as Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput?);
  Input$UserUpdateOneWithoutScannedQrsNestedInput? get scannedBy =>
      (_$data['scannedBy'] as Input$UserUpdateOneWithoutScannedQrsNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateInput<Input$QrCodeUpdateInput> get copyWith =>
      CopyWith$Input$QrCodeUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guest = guest;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('guest') ? l$guest : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateInput(
    Input$QrCodeUpdateInput instance,
    TRes Function(Input$QrCodeUpdateInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateInput;

  factory CopyWith$Input$QrCodeUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput? guest,
    Input$UserUpdateOneWithoutScannedQrsNestedInput? scannedBy,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get scannedAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue;
  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes> get guest;
  CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeUpdateInput<TRes>
    implements CopyWith$Input$QrCodeUpdateInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateInput _instance;

  final TRes Function(Input$QrCodeUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guest = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeUpdateInput._({
        ..._instance._$data,
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (scannedAt != _undefined)
          'scannedAt':
              (scannedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (raceConditionValue != _undefined)
          'raceConditionValue':
              (raceConditionValue as Input$IntFieldUpdateOperationsInput?),
        if (guest != _undefined)
          'guest':
              (guest as Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput?),
        if (scannedBy != _undefined)
          'scannedBy':
              (scannedBy as Input$UserUpdateOneWithoutScannedQrsNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue {
    final local$raceConditionValue = _instance.raceConditionValue;
    return local$raceConditionValue == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$raceConditionValue, (e) => call(raceConditionValue: e));
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput(
            local$guest, (e) => call(guest: e));
  }

  CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateInput<TRes>
    implements CopyWith$Input$QrCodeUpdateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput? guest,
    Input$UserUpdateOneWithoutScannedQrsNestedInput? scannedBy,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes>
      get guest =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput.stub(
              _res);
  CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes>
      get scannedBy =>
          CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput.stub(_res);
}

class Input$QrCodeUpdateManyMutationInput {
  factory Input$QrCodeUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
  }) =>
      Input$QrCodeUpdateManyMutationInput._({
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
      });

  Input$QrCodeUpdateManyMutationInput._(this._$data);

  factory Input$QrCodeUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$raceConditionValue as Map<String, dynamic>));
    }
    return Input$QrCodeUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get scannedAt =>
      (_$data['scannedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get raceConditionValue =>
      (_$data['raceConditionValue'] as Input$IntFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateManyMutationInput<
          Input$QrCodeUpdateManyMutationInput>
      get copyWith => CopyWith$Input$QrCodeUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    return Object.hashAll([
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateManyMutationInput(
    Input$QrCodeUpdateManyMutationInput instance,
    TRes Function(Input$QrCodeUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateManyMutationInput;

  factory CopyWith$Input$QrCodeUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get scannedAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue;
}

class _CopyWithImpl$Input$QrCodeUpdateManyMutationInput<TRes>
    implements CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateManyMutationInput _instance;

  final TRes Function(Input$QrCodeUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
  }) =>
      _then(Input$QrCodeUpdateManyMutationInput._({
        ..._instance._$data,
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (scannedAt != _undefined)
          'scannedAt':
              (scannedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (raceConditionValue != _undefined)
          'raceConditionValue':
              (raceConditionValue as Input$IntFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue {
    final local$raceConditionValue = _instance.raceConditionValue;
    return local$raceConditionValue == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$raceConditionValue, (e) => call(raceConditionValue: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateManyMutationInput<TRes>
    implements CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
}

class Input$QrCodeUpdateManyWithoutScannedByNestedInput {
  factory Input$QrCodeUpdateManyWithoutScannedByNestedInput({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? upsert,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  }) =>
      Input$QrCodeUpdateManyWithoutScannedByNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (createMany != null) r'createMany': createMany,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$QrCodeUpdateManyWithoutScannedByNestedInput._(this._$data);

  factory Input$QrCodeUpdateManyWithoutScannedByNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$QrCodeCreateWithoutScannedByInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeCreateOrConnectWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$QrCodeCreateManyScannedByInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpdateManyWithWhereWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$QrCodeUpdateManyWithoutScannedByNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateWithoutScannedByInput>? get create =>
      (_$data['create'] as List<Input$QrCodeCreateWithoutScannedByInput>?);
  List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$QrCodeCreateOrConnectWithoutScannedByInput>?);
  List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? get upsert =>
      (_$data['upsert']
          as List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>?);
  Input$QrCodeCreateManyScannedByInputEnvelope? get createMany =>
      (_$data['createMany'] as Input$QrCodeCreateManyScannedByInputEnvelope?);
  List<Input$QrCodeWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? get update =>
      (_$data['update']
          as List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>?);
  List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? get updateMany =>
      (_$data['updateMany']
          as List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>?);
  List<Input$QrCodeScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$QrCodeScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<
          Input$QrCodeUpdateManyWithoutScannedByNestedInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateManyWithoutScannedByNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
    Input$QrCodeUpdateManyWithoutScannedByNestedInput instance,
    TRes Function(Input$QrCodeUpdateManyWithoutScannedByNestedInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput;

  factory CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput;

  TRes call({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? upsert,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$QrCodeCreateWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateWithoutScannedByInput<
                      Input$QrCodeCreateWithoutScannedByInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$QrCodeCreateOrConnectWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
                      Input$QrCodeCreateOrConnectWithoutScannedByInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
                      Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>>?)
          _fn);
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany;
  TRes $set(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
                      Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
                      Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateManyWithoutScannedByNestedInput _instance;

  final TRes Function(Input$QrCodeUpdateManyWithoutScannedByNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? createMany = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$QrCodeUpdateManyWithoutScannedByNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$QrCodeCreateWithoutScannedByInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$QrCodeCreateOrConnectWithoutScannedByInput>?),
        if (upsert != _undefined)
          'upsert': (upsert
              as List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$QrCodeCreateManyScannedByInputEnvelope?),
        if ($set != _undefined)
          'set': ($set as List<Input$QrCodeWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as List<Input$QrCodeWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$QrCodeWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$QrCodeWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update
              as List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany
              as List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>?),
        if (deleteMany != _undefined)
          'deleteMany': (deleteMany as List<Input$QrCodeScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$QrCodeCreateWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateWithoutScannedByInput<
                          Input$QrCodeCreateWithoutScannedByInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$QrCodeCreateWithoutScannedByInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$QrCodeCreateOrConnectWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
                          Input$QrCodeCreateOrConnectWithoutScannedByInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes upsert(
          Iterable<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
                          Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes $set(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(
              _instance.$set?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
                          Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
                          Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? upsert,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany =>
      CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(_res);
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$QrCodeUpdateManyWithWhereWithoutScannedByInput {
  factory Input$QrCodeUpdateManyWithWhereWithoutScannedByInput({
    required Input$QrCodeScalarWhereInput where,
    required Input$QrCodeUpdateManyMutationInput data,
  }) =>
      Input$QrCodeUpdateManyWithWhereWithoutScannedByInput._({
        r'where': where,
        r'data': data,
      });

  Input$QrCodeUpdateManyWithWhereWithoutScannedByInput._(this._$data);

  factory Input$QrCodeUpdateManyWithWhereWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$QrCodeUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$QrCodeUpdateManyWithWhereWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeScalarWhereInput get where =>
      (_$data['where'] as Input$QrCodeScalarWhereInput);
  Input$QrCodeUpdateManyMutationInput get data =>
      (_$data['data'] as Input$QrCodeUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
          Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateManyWithWhereWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
    Input$QrCodeUpdateManyWithWhereWithoutScannedByInput instance,
    TRes Function(Input$QrCodeUpdateManyWithWhereWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput;

  factory CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput;

  TRes call({
    Input$QrCodeScalarWhereInput? where,
    Input$QrCodeUpdateManyMutationInput? data,
  });
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateManyWithWhereWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeUpdateManyWithWhereWithoutScannedByInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$QrCodeUpdateManyWithWhereWithoutScannedByInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$QrCodeUpdateManyMutationInput),
      }));
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$QrCodeUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
        TRes>
    implements
        CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeScalarWhereInput? where,
    Input$QrCodeUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where =>
      CopyWith$Input$QrCodeScalarWhereInput.stub(_res);
  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$QrCodeUpdateManyMutationInput.stub(_res);
}

class Input$QrCodeUpdateOneWithoutGuestNestedInput {
  factory Input$QrCodeUpdateOneWithoutGuestNestedInput({
    Input$QrCodeCreateWithoutGuestInput? create,
    Input$QrCodeCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$QrCodeUpsertWithoutGuestInput? upsert,
    Input$QrCodeWhereInput? disconnect,
    Input$QrCodeWhereInput? delete,
    Input$QrCodeWhereUniqueInput? connect,
    Input$QrCodeUpdateToOneWithWhereWithoutGuestInput? update,
  }) =>
      Input$QrCodeUpdateOneWithoutGuestNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$QrCodeUpdateOneWithoutGuestNestedInput._(this._$data);

  factory Input$QrCodeUpdateOneWithoutGuestNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$QrCodeCreateWithoutGuestInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$QrCodeCreateOrConnectWithoutGuestInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$QrCodeUpsertWithoutGuestInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$QrCodeWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$QrCodeWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$QrCodeUpdateToOneWithWhereWithoutGuestInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$QrCodeUpdateOneWithoutGuestNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeCreateWithoutGuestInput? get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutGuestInput?);
  Input$QrCodeCreateOrConnectWithoutGuestInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$QrCodeCreateOrConnectWithoutGuestInput?);
  Input$QrCodeUpsertWithoutGuestInput? get upsert =>
      (_$data['upsert'] as Input$QrCodeUpsertWithoutGuestInput?);
  Input$QrCodeWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$QrCodeWhereInput?);
  Input$QrCodeWhereInput? get delete =>
      (_$data['delete'] as Input$QrCodeWhereInput?);
  Input$QrCodeWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$QrCodeWhereUniqueInput?);
  Input$QrCodeUpdateToOneWithWhereWithoutGuestInput? get update =>
      (_$data['update'] as Input$QrCodeUpdateToOneWithWhereWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<
          Input$QrCodeUpdateOneWithoutGuestNestedInput>
      get copyWith => CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateOneWithoutGuestNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput(
    Input$QrCodeUpdateOneWithoutGuestNestedInput instance,
    TRes Function(Input$QrCodeUpdateOneWithoutGuestNestedInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateOneWithoutGuestNestedInput;

  factory CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateOneWithoutGuestNestedInput;

  TRes call({
    Input$QrCodeCreateWithoutGuestInput? create,
    Input$QrCodeCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$QrCodeUpsertWithoutGuestInput? upsert,
    Input$QrCodeWhereInput? disconnect,
    Input$QrCodeWhereInput? delete,
    Input$QrCodeWhereUniqueInput? connect,
    Input$QrCodeUpdateToOneWithWhereWithoutGuestInput? update,
  });
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create;
  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate;
  CopyWith$Input$QrCodeUpsertWithoutGuestInput<TRes> get upsert;
  CopyWith$Input$QrCodeWhereInput<TRes> get disconnect;
  CopyWith$Input$QrCodeWhereInput<TRes> get delete;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get connect;
  CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<TRes> get update;
}

class _CopyWithImpl$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes>
    implements CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateOneWithoutGuestNestedInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateOneWithoutGuestNestedInput _instance;

  final TRes Function(Input$QrCodeUpdateOneWithoutGuestNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$QrCodeUpdateOneWithoutGuestNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$QrCodeCreateWithoutGuestInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$QrCodeCreateOrConnectWithoutGuestInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$QrCodeUpsertWithoutGuestInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$QrCodeWhereInput?),
        if (delete != _undefined) 'delete': (delete as Input$QrCodeWhereInput?),
        if (connect != _undefined)
          'connect': (connect as Input$QrCodeWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$QrCodeUpdateToOneWithWhereWithoutGuestInput?),
      }));
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeCreateWithoutGuestInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$QrCodeUpsertWithoutGuestInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$QrCodeUpsertWithoutGuestInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeUpsertWithoutGuestInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$QrCodeWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$QrCodeWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$QrCodeWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes>
    implements CopyWith$Input$QrCodeUpdateOneWithoutGuestNestedInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateOneWithoutGuestNestedInput(this._res);

  TRes _res;

  call({
    Input$QrCodeCreateWithoutGuestInput? create,
    Input$QrCodeCreateOrConnectWithoutGuestInput? connectOrCreate,
    Input$QrCodeUpsertWithoutGuestInput? upsert,
    Input$QrCodeWhereInput? disconnect,
    Input$QrCodeWhereInput? delete,
    Input$QrCodeWhereUniqueInput? connect,
    Input$QrCodeUpdateToOneWithWhereWithoutGuestInput? update,
  }) =>
      _res;
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(_res);
  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput.stub(_res);
  CopyWith$Input$QrCodeUpsertWithoutGuestInput<TRes> get upsert =>
      CopyWith$Input$QrCodeUpsertWithoutGuestInput.stub(_res);
  CopyWith$Input$QrCodeWhereInput<TRes> get disconnect =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
  CopyWith$Input$QrCodeWhereInput<TRes> get delete =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<TRes> get update =>
      CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput.stub(_res);
}

class Input$QrCodeUpdateToOneWithWhereWithoutGuestInput {
  factory Input$QrCodeUpdateToOneWithWhereWithoutGuestInput({
    Input$QrCodeWhereInput? where,
    required Input$QrCodeUpdateWithoutGuestInput data,
  }) =>
      Input$QrCodeUpdateToOneWithWhereWithoutGuestInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$QrCodeUpdateToOneWithWhereWithoutGuestInput._(this._$data);

  factory Input$QrCodeUpdateToOneWithWhereWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$QrCodeUpdateWithoutGuestInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$QrCodeUpdateToOneWithWhereWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereInput? get where =>
      (_$data['where'] as Input$QrCodeWhereInput?);
  Input$QrCodeUpdateWithoutGuestInput get data =>
      (_$data['data'] as Input$QrCodeUpdateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<
          Input$QrCodeUpdateToOneWithWhereWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateToOneWithWhereWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput(
    Input$QrCodeUpdateToOneWithWhereWithoutGuestInput instance,
    TRes Function(Input$QrCodeUpdateToOneWithWhereWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput;

  factory CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput;

  TRes call({
    Input$QrCodeWhereInput? where,
    Input$QrCodeUpdateWithoutGuestInput? data,
  });
  CopyWith$Input$QrCodeWhereInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get data;
}

class _CopyWithImpl$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateToOneWithWhereWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeUpdateToOneWithWhereWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$QrCodeUpdateToOneWithWhereWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$QrCodeWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$QrCodeUpdateWithoutGuestInput),
      }));
  CopyWith$Input$QrCodeWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$QrCodeUpdateWithoutGuestInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateToOneWithWhereWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeWhereInput? where,
    Input$QrCodeUpdateWithoutGuestInput? data,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get data =>
      CopyWith$Input$QrCodeUpdateWithoutGuestInput.stub(_res);
}

class Input$QrCodeUpdateWithoutGuestInput {
  factory Input$QrCodeUpdateWithoutGuestInput({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$UserUpdateOneWithoutScannedQrsNestedInput? scannedBy,
  }) =>
      Input$QrCodeUpdateWithoutGuestInput._({
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeUpdateWithoutGuestInput._(this._$data);

  factory Input$QrCodeUpdateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$raceConditionValue as Map<String, dynamic>));
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserUpdateOneWithoutScannedQrsNestedInput.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeUpdateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get scannedAt =>
      (_$data['scannedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get raceConditionValue =>
      (_$data['raceConditionValue'] as Input$IntFieldUpdateOperationsInput?);
  Input$UserUpdateOneWithoutScannedQrsNestedInput? get scannedBy =>
      (_$data['scannedBy'] as Input$UserUpdateOneWithoutScannedQrsNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue?.toJson();
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateWithoutGuestInput<
          Input$QrCodeUpdateWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeUpdateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateWithoutGuestInput(
    Input$QrCodeUpdateWithoutGuestInput instance,
    TRes Function(Input$QrCodeUpdateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateWithoutGuestInput;

  factory CopyWith$Input$QrCodeUpdateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateWithoutGuestInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$UserUpdateOneWithoutScannedQrsNestedInput? scannedBy,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get scannedAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue;
  CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeUpdateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeUpdateWithoutGuestInput._({
        ..._instance._$data,
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (scannedAt != _undefined)
          'scannedAt':
              (scannedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (raceConditionValue != _undefined)
          'raceConditionValue':
              (raceConditionValue as Input$IntFieldUpdateOperationsInput?),
        if (scannedBy != _undefined)
          'scannedBy':
              (scannedBy as Input$UserUpdateOneWithoutScannedQrsNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue {
    final local$raceConditionValue = _instance.raceConditionValue;
    return local$raceConditionValue == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$raceConditionValue, (e) => call(raceConditionValue: e));
  }

  CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$UserUpdateOneWithoutScannedQrsNestedInput? scannedBy,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes>
      get scannedBy =>
          CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput.stub(_res);
}

class Input$QrCodeUpdateWithoutScannedByInput {
  factory Input$QrCodeUpdateWithoutScannedByInput({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput? guest,
  }) =>
      Input$QrCodeUpdateWithoutScannedByInput._({
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (guest != null) r'guest': guest,
      });

  Input$QrCodeUpdateWithoutScannedByInput._(this._$data);

  factory Input$QrCodeUpdateWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$raceConditionValue as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$QrCodeUpdateWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get scannedAt =>
      (_$data['scannedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get raceConditionValue =>
      (_$data['raceConditionValue'] as Input$IntFieldUpdateOperationsInput?);
  Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput? get guest =>
      (_$data['guest']
          as Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<
          Input$QrCodeUpdateWithoutScannedByInput>
      get copyWith => CopyWith$Input$QrCodeUpdateWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateWithoutScannedByInput(
    Input$QrCodeUpdateWithoutScannedByInput instance,
    TRes Function(Input$QrCodeUpdateWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateWithoutScannedByInput;

  factory CopyWith$Input$QrCodeUpdateWithoutScannedByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateWithoutScannedByInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput? guest,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get scannedAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue;
  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes> get guest;
}

class _CopyWithImpl$Input$QrCodeUpdateWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeUpdateWithoutScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$QrCodeUpdateWithoutScannedByInput._({
        ..._instance._$data,
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (scannedAt != _undefined)
          'scannedAt':
              (scannedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (raceConditionValue != _undefined)
          'raceConditionValue':
              (raceConditionValue as Input$IntFieldUpdateOperationsInput?),
        if (guest != _undefined)
          'guest':
              (guest as Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue {
    final local$raceConditionValue = _instance.raceConditionValue;
    return local$raceConditionValue == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$raceConditionValue, (e) => call(raceConditionValue: e));
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateWithoutScannedByInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$IntFieldUpdateOperationsInput? raceConditionValue,
    Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput? guest,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get raceConditionValue =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput<TRes>
      get guest =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodeNestedInput.stub(
              _res);
}

class Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput {
  factory Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeUpdateWithoutScannedByInput data,
  }) =>
      Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput._({
        r'where': where,
        r'data': data,
      });

  Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput._(this._$data);

  factory Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$QrCodeUpdateWithoutScannedByInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeUpdateWithoutScannedByInput get data =>
      (_$data['data'] as Input$QrCodeUpdateWithoutScannedByInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
          Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
    Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput instance,
    TRes Function(Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput;

  factory CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutScannedByInput? data,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get data;
}

class _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$QrCodeUpdateWithoutScannedByInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$QrCodeUpdateWithoutScannedByInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
        TRes>
    implements
        CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutScannedByInput? data,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get data =>
      CopyWith$Input$QrCodeUpdateWithoutScannedByInput.stub(_res);
}

class Input$QrCodeUpsertWithoutGuestInput {
  factory Input$QrCodeUpsertWithoutGuestInput({
    required Input$QrCodeUpdateWithoutGuestInput update,
    required Input$QrCodeCreateWithoutGuestInput create,
    Input$QrCodeWhereInput? where,
  }) =>
      Input$QrCodeUpsertWithoutGuestInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$QrCodeUpsertWithoutGuestInput._(this._$data);

  factory Input$QrCodeUpsertWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$QrCodeUpdateWithoutGuestInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$QrCodeCreateWithoutGuestInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$QrCodeUpsertWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeUpdateWithoutGuestInput get update =>
      (_$data['update'] as Input$QrCodeUpdateWithoutGuestInput);
  Input$QrCodeCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutGuestInput);
  Input$QrCodeWhereInput? get where =>
      (_$data['where'] as Input$QrCodeWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpsertWithoutGuestInput<
          Input$QrCodeUpsertWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeUpsertWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpsertWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpsertWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeUpsertWithoutGuestInput(
    Input$QrCodeUpsertWithoutGuestInput instance,
    TRes Function(Input$QrCodeUpsertWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpsertWithoutGuestInput;

  factory CopyWith$Input$QrCodeUpsertWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpsertWithoutGuestInput;

  TRes call({
    Input$QrCodeUpdateWithoutGuestInput? update,
    Input$QrCodeCreateWithoutGuestInput? create,
    Input$QrCodeWhereInput? where,
  });
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get update;
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create;
  CopyWith$Input$QrCodeWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$QrCodeUpsertWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeUpsertWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpsertWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpsertWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeUpsertWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$QrCodeUpsertWithoutGuestInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$QrCodeUpdateWithoutGuestInput),
        if (create != _undefined && create != null)
          'create': (create as Input$QrCodeCreateWithoutGuestInput),
        if (where != _undefined) 'where': (where as Input$QrCodeWhereInput?),
      }));
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$QrCodeUpdateWithoutGuestInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$QrCodeCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$QrCodeWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpsertWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeUpsertWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpsertWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$QrCodeUpdateWithoutGuestInput? update,
    Input$QrCodeCreateWithoutGuestInput? create,
    Input$QrCodeWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get update =>
      CopyWith$Input$QrCodeUpdateWithoutGuestInput.stub(_res);
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(_res);
  CopyWith$Input$QrCodeWhereInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
}

class Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput {
  factory Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeUpdateWithoutScannedByInput update,
    required Input$QrCodeCreateWithoutScannedByInput create,
  }) =>
      Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput._(this._$data);

  factory Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$QrCodeUpdateWithoutScannedByInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$QrCodeCreateWithoutScannedByInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeUpdateWithoutScannedByInput get update =>
      (_$data['update'] as Input$QrCodeUpdateWithoutScannedByInput);
  Input$QrCodeCreateWithoutScannedByInput get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutScannedByInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
          Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
    Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput instance,
    TRes Function(Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput;

  factory CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutScannedByInput? update,
    Input$QrCodeCreateWithoutScannedByInput? create,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get update;
  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create;
}

class _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$QrCodeUpdateWithoutScannedByInput),
        if (create != _undefined && create != null)
          'create': (create as Input$QrCodeCreateWithoutScannedByInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$QrCodeUpdateWithoutScannedByInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$QrCodeCreateWithoutScannedByInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
        TRes>
    implements
        CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutScannedByInput? update,
    Input$QrCodeCreateWithoutScannedByInput? create,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get update =>
      CopyWith$Input$QrCodeUpdateWithoutScannedByInput.stub(_res);
  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutScannedByInput.stub(_res);
}

class Input$QrCodeWhereInput {
  factory Input$QrCodeWhereInput({
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  }) =>
      Input$QrCodeWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (guestId != null) r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
        if (guest != null) r'guest': guest,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeWhereInput._(this._$data);

  factory Input$QrCodeWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFilter.fromJson((l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : Input$IntFilter.fromJson(
              (l$raceConditionValue as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = l$scannedByUserId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$scannedByUserId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserNullableRelationFilter.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeWhereInput>? get AND =>
      (_$data['AND'] as List<Input$QrCodeWhereInput>?);
  List<Input$QrCodeWhereInput>? get OR =>
      (_$data['OR'] as List<Input$QrCodeWhereInput>?);
  List<Input$QrCodeWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$QrCodeWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$StringFilter? get path => (_$data['path'] as Input$StringFilter?);
  Input$DateTimeNullableFilter? get scannedAt =>
      (_$data['scannedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$IntFilter? get raceConditionValue =>
      (_$data['raceConditionValue'] as Input$IntFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$StringNullableFilter? get scannedByUserId =>
      (_$data['scannedByUserId'] as Input$StringNullableFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Input$UserNullableRelationFilter? get scannedBy =>
      (_$data['scannedBy'] as Input$UserNullableRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput> get copyWith =>
      CopyWith$Input$QrCodeWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    final l$guest = guest;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeWhereInput<TRes> {
  factory CopyWith$Input$QrCodeWhereInput(
    Input$QrCodeWhereInput instance,
    TRes Function(Input$QrCodeWhereInput) then,
  ) = _CopyWithImpl$Input$QrCodeWhereInput;

  factory CopyWith$Input$QrCodeWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeWhereInput;

  TRes call({
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  });
  TRes AND(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get path;
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$IntFilter<TRes> get raceConditionValue;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeWhereInput<TRes>
    implements CopyWith$Input$QrCodeWhereInput<TRes> {
  _CopyWithImpl$Input$QrCodeWhereInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeWhereInput _instance;

  final TRes Function(Input$QrCodeWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
    Object? guest = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$QrCodeWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$QrCodeWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$QrCodeWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (path != _undefined) 'path': (path as Input$StringFilter?),
        if (scannedAt != _undefined)
          'scannedAt': (scannedAt as Input$DateTimeNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as Input$IntFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as Input$StringNullableFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
        if (scannedBy != _undefined)
          'scannedBy': (scannedBy as Input$UserNullableRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IntFilter<TRes> get raceConditionValue {
    final local$raceConditionValue = _instance.raceConditionValue;
    return local$raceConditionValue == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$raceConditionValue, (e) => call(raceConditionValue: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId {
    final local$scannedByUserId = _instance.scannedByUserId;
    return local$scannedByUserId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$scannedByUserId, (e) => call(scannedByUserId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }

  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$UserNullableRelationFilter(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeWhereInput<TRes>
    implements CopyWith$Input$QrCodeWhereInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeWhereInput(this._res);

  TRes _res;

  call({
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get path =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get raceConditionValue =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy =>
      CopyWith$Input$UserNullableRelationFilter.stub(_res);
}

class Input$QrCodeWhereUniqueInput {
  factory Input$QrCodeWhereUniqueInput({
    int? id,
    String? guestId,
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  }) =>
      Input$QrCodeWhereUniqueInput._({
        if (id != null) r'id': id,
        if (guestId != null) r'guestId': guestId,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (raceConditionValue != null)
          r'raceConditionValue': raceConditionValue,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
        if (guest != null) r'guest': guest,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeWhereUniqueInput._(this._$data);

  factory Input$QrCodeWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as String?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFilter.fromJson((l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = data['raceConditionValue'];
      result$data['raceConditionValue'] = l$raceConditionValue == null
          ? null
          : Input$IntFilter.fromJson(
              (l$raceConditionValue as Map<String, dynamic>));
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = l$scannedByUserId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$scannedByUserId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserNullableRelationFilter.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String? get guestId => (_$data['guestId'] as String?);
  List<Input$QrCodeWhereInput>? get AND =>
      (_$data['AND'] as List<Input$QrCodeWhereInput>?);
  List<Input$QrCodeWhereInput>? get OR =>
      (_$data['OR'] as List<Input$QrCodeWhereInput>?);
  List<Input$QrCodeWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$QrCodeWhereInput>?);
  Input$StringFilter? get path => (_$data['path'] as Input$StringFilter?);
  Input$DateTimeNullableFilter? get scannedAt =>
      (_$data['scannedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$IntFilter? get raceConditionValue =>
      (_$data['raceConditionValue'] as Input$IntFilter?);
  Input$StringNullableFilter? get scannedByUserId =>
      (_$data['scannedByUserId'] as Input$StringNullableFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Input$UserNullableRelationFilter? get scannedBy =>
      (_$data['scannedBy'] as Input$UserNullableRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('raceConditionValue')) {
      final l$raceConditionValue = raceConditionValue;
      result$data['raceConditionValue'] = l$raceConditionValue?.toJson();
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeWhereUniqueInput<Input$QrCodeWhereUniqueInput>
      get copyWith => CopyWith$Input$QrCodeWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$raceConditionValue = raceConditionValue;
    final lOther$raceConditionValue = other.raceConditionValue;
    if (_$data.containsKey('raceConditionValue') !=
        other._$data.containsKey('raceConditionValue')) {
      return false;
    }
    if (l$raceConditionValue != lOther$raceConditionValue) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$guestId = guestId;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$raceConditionValue = raceConditionValue;
    final l$scannedByUserId = scannedByUserId;
    final l$guest = guest;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('raceConditionValue')
          ? l$raceConditionValue
          : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeWhereUniqueInput<TRes> {
  factory CopyWith$Input$QrCodeWhereUniqueInput(
    Input$QrCodeWhereUniqueInput instance,
    TRes Function(Input$QrCodeWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$QrCodeWhereUniqueInput;

  factory CopyWith$Input$QrCodeWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeWhereUniqueInput;

  TRes call({
    int? id,
    String? guestId,
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  });
  TRes AND(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get path;
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$IntFilter<TRes> get raceConditionValue;
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeWhereUniqueInput<TRes>
    implements CopyWith$Input$QrCodeWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$QrCodeWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeWhereUniqueInput _instance;

  final TRes Function(Input$QrCodeWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? guestId = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? raceConditionValue = _undefined,
    Object? scannedByUserId = _undefined,
    Object? guest = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (guestId != _undefined) 'guestId': (guestId as String?),
        if (AND != _undefined) 'AND': (AND as List<Input$QrCodeWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$QrCodeWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$QrCodeWhereInput>?),
        if (path != _undefined) 'path': (path as Input$StringFilter?),
        if (scannedAt != _undefined)
          'scannedAt': (scannedAt as Input$DateTimeNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (raceConditionValue != _undefined)
          'raceConditionValue': (raceConditionValue as Input$IntFilter?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as Input$StringNullableFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
        if (scannedBy != _undefined)
          'scannedBy': (scannedBy as Input$UserNullableRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$IntFilter<TRes> get raceConditionValue {
    final local$raceConditionValue = _instance.raceConditionValue;
    return local$raceConditionValue == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$raceConditionValue, (e) => call(raceConditionValue: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId {
    final local$scannedByUserId = _instance.scannedByUserId;
    return local$scannedByUserId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$scannedByUserId, (e) => call(scannedByUserId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }

  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$UserNullableRelationFilter(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeWhereUniqueInput<TRes>
    implements CopyWith$Input$QrCodeWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeWhereUniqueInput(this._res);

  TRes _res;

  call({
    int? id,
    String? guestId,
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$IntFilter? raceConditionValue,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get path =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get raceConditionValue =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy =>
      CopyWith$Input$UserNullableRelationFilter.stub(_res);
}

class Input$SortOrderInput {
  factory Input$SortOrderInput({
    required Enum$SortOrder sort,
    Enum$NullsOrder? nulls,
  }) =>
      Input$SortOrderInput._({
        r'sort': sort,
        if (nulls != null) r'nulls': nulls,
      });

  Input$SortOrderInput._(this._$data);

  factory Input$SortOrderInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$sort = data['sort'];
    result$data['sort'] = fromJson$Enum$SortOrder((l$sort as String));
    if (data.containsKey('nulls')) {
      final l$nulls = data['nulls'];
      result$data['nulls'] = l$nulls == null
          ? null
          : fromJson$Enum$NullsOrder((l$nulls as String));
    }
    return Input$SortOrderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder get sort => (_$data['sort'] as Enum$SortOrder);
  Enum$NullsOrder? get nulls => (_$data['nulls'] as Enum$NullsOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$sort = sort;
    result$data['sort'] = toJson$Enum$SortOrder(l$sort);
    if (_$data.containsKey('nulls')) {
      final l$nulls = nulls;
      result$data['nulls'] =
          l$nulls == null ? null : toJson$Enum$NullsOrder(l$nulls);
    }
    return result$data;
  }

  CopyWith$Input$SortOrderInput<Input$SortOrderInput> get copyWith =>
      CopyWith$Input$SortOrderInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SortOrderInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$sort = sort;
    final lOther$sort = other.sort;
    if (l$sort != lOther$sort) {
      return false;
    }
    final l$nulls = nulls;
    final lOther$nulls = other.nulls;
    if (_$data.containsKey('nulls') != other._$data.containsKey('nulls')) {
      return false;
    }
    if (l$nulls != lOther$nulls) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sort = sort;
    final l$nulls = nulls;
    return Object.hashAll([
      l$sort,
      _$data.containsKey('nulls') ? l$nulls : const {},
    ]);
  }
}

abstract class CopyWith$Input$SortOrderInput<TRes> {
  factory CopyWith$Input$SortOrderInput(
    Input$SortOrderInput instance,
    TRes Function(Input$SortOrderInput) then,
  ) = _CopyWithImpl$Input$SortOrderInput;

  factory CopyWith$Input$SortOrderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SortOrderInput;

  TRes call({
    Enum$SortOrder? sort,
    Enum$NullsOrder? nulls,
  });
}

class _CopyWithImpl$Input$SortOrderInput<TRes>
    implements CopyWith$Input$SortOrderInput<TRes> {
  _CopyWithImpl$Input$SortOrderInput(
    this._instance,
    this._then,
  );

  final Input$SortOrderInput _instance;

  final TRes Function(Input$SortOrderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? sort = _undefined,
    Object? nulls = _undefined,
  }) =>
      _then(Input$SortOrderInput._({
        ..._instance._$data,
        if (sort != _undefined && sort != null)
          'sort': (sort as Enum$SortOrder),
        if (nulls != _undefined) 'nulls': (nulls as Enum$NullsOrder?),
      }));
}

class _CopyWithStubImpl$Input$SortOrderInput<TRes>
    implements CopyWith$Input$SortOrderInput<TRes> {
  _CopyWithStubImpl$Input$SortOrderInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? sort,
    Enum$NullsOrder? nulls,
  }) =>
      _res;
}

class Input$StringFieldUpdateOperationsInput {
  factory Input$StringFieldUpdateOperationsInput({String? $set}) =>
      Input$StringFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$StringFieldUpdateOperationsInput._(this._$data);

  factory Input$StringFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$StringFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<
          Input$StringFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$StringFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$StringFieldUpdateOperationsInput(
    Input$StringFieldUpdateOperationsInput instance,
    TRes Function(Input$StringFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$StringFieldUpdateOperationsInput;

  factory CopyWith$Input$StringFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$StringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$StringFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$StringFieldUpdateOperationsInput _instance;

  final TRes Function(Input$StringFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$StringFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$StringFilter {
  factory Input$StringFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      Input$StringFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$StringFilter._(this._$data);

  factory Input$StringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$StringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringFilter? get not =>
      (_$data['not'] as Input$NestedStringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$StringFilter<Input$StringFilter> get copyWith =>
      CopyWith$Input$StringFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringFilter<TRes> {
  factory CopyWith$Input$StringFilter(
    Input$StringFilter instance,
    TRes Function(Input$StringFilter) then,
  ) = _CopyWithImpl$Input$StringFilter;

  factory CopyWith$Input$StringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  });
  CopyWith$Input$NestedStringFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithImpl$Input$StringFilter(
    this._instance,
    this._then,
  );

  final Input$StringFilter _instance;

  final TRes Function(Input$StringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$StringFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined) 'not': (not as Input$NestedStringFilter?),
      }));
  CopyWith$Input$NestedStringFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithStubImpl$Input$StringFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringFilter<TRes> get not =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$StringNullableFilter {
  factory Input$StringNullableFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  }) =>
      Input$StringNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$StringNullableFilter._(this._$data);

  factory Input$StringNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$StringNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringNullableFilter? get not =>
      (_$data['not'] as Input$NestedStringNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$StringNullableFilter<Input$StringNullableFilter>
      get copyWith => CopyWith$Input$StringNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringNullableFilter<TRes> {
  factory CopyWith$Input$StringNullableFilter(
    Input$StringNullableFilter instance,
    TRes Function(Input$StringNullableFilter) then,
  ) = _CopyWithImpl$Input$StringNullableFilter;

  factory CopyWith$Input$StringNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringNullableFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  });
  CopyWith$Input$NestedStringNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringNullableFilter<TRes>
    implements CopyWith$Input$StringNullableFilter<TRes> {
  _CopyWithImpl$Input$StringNullableFilter(
    this._instance,
    this._then,
  );

  final Input$StringNullableFilter _instance;

  final TRes Function(Input$StringNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$StringNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringNullableFilter?),
      }));
  CopyWith$Input$NestedStringNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringNullableFilter<TRes>
    implements CopyWith$Input$StringNullableFilter<TRes> {
  _CopyWithStubImpl$Input$StringNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringNullableFilter<TRes> get not =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);
}

class Input$UserCountAggregateInput {
  factory Input$UserCountAggregateInput({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? $_all,
  }) =>
      Input$UserCountAggregateInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if ($_all != null) r'_all': $_all,
      });

  Input$UserCountAggregateInput._(this._$data);

  factory Input$UserCountAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = (l$fullName as bool?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as bool?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$UserCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get fullName => (_$data['fullName'] as bool?);
  bool? get email => (_$data['email'] as bool?);
  bool? get password => (_$data['password'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get role => (_$data['role'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$UserCountAggregateInput<Input$UserCountAggregateInput>
      get copyWith => CopyWith$Input$UserCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCountAggregateInput<TRes> {
  factory CopyWith$Input$UserCountAggregateInput(
    Input$UserCountAggregateInput instance,
    TRes Function(Input$UserCountAggregateInput) then,
  ) = _CopyWithImpl$Input$UserCountAggregateInput;

  factory CopyWith$Input$UserCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCountAggregateInput;

  TRes call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$UserCountAggregateInput<TRes>
    implements CopyWith$Input$UserCountAggregateInput<TRes> {
  _CopyWithImpl$Input$UserCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$UserCountAggregateInput _instance;

  final TRes Function(Input$UserCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$UserCountAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (fullName != _undefined) 'fullName': (fullName as bool?),
        if (email != _undefined) 'email': (email as bool?),
        if (password != _undefined) 'password': (password as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (role != _undefined) 'role': (role as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$UserCountAggregateInput<TRes>
    implements CopyWith$Input$UserCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$UserCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? $_all,
  }) =>
      _res;
}

class Input$UserCreateInput {
  factory Input$UserCreateInput({
    String? id,
    required String fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    required Enum$UserRole role,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? scannedQrs,
  }) =>
      Input$UserCreateInput._({
        if (id != null) r'id': id,
        r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        r'role': role,
        if (scannedQrs != null) r'scannedQrs': scannedQrs,
      });

  Input$UserCreateInput._(this._$data);

  factory Input$UserCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$UserRole((l$role as String));
    if (data.containsKey('scannedQrs')) {
      final l$scannedQrs = data['scannedQrs'];
      result$data['scannedQrs'] = l$scannedQrs == null
          ? null
          : Input$QrCodeCreateNestedManyWithoutScannedByInput.fromJson(
              (l$scannedQrs as Map<String, dynamic>));
    }
    return Input$UserCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get fullName => (_$data['fullName'] as String);
  String? get email => (_$data['email'] as String?);
  String? get password => (_$data['password'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$UserRole get role => (_$data['role'] as Enum$UserRole);
  Input$QrCodeCreateNestedManyWithoutScannedByInput? get scannedQrs =>
      (_$data['scannedQrs']
          as Input$QrCodeCreateNestedManyWithoutScannedByInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    final l$role = role;
    result$data['role'] = toJson$Enum$UserRole(l$role);
    if (_$data.containsKey('scannedQrs')) {
      final l$scannedQrs = scannedQrs;
      result$data['scannedQrs'] = l$scannedQrs?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserCreateInput<Input$UserCreateInput> get copyWith =>
      CopyWith$Input$UserCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    final l$scannedQrs = scannedQrs;
    final lOther$scannedQrs = other.scannedQrs;
    if (_$data.containsKey('scannedQrs') !=
        other._$data.containsKey('scannedQrs')) {
      return false;
    }
    if (l$scannedQrs != lOther$scannedQrs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$scannedQrs = scannedQrs;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$fullName,
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      l$role,
      _$data.containsKey('scannedQrs') ? l$scannedQrs : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateInput<TRes> {
  factory CopyWith$Input$UserCreateInput(
    Input$UserCreateInput instance,
    TRes Function(Input$UserCreateInput) then,
  ) = _CopyWithImpl$Input$UserCreateInput;

  factory CopyWith$Input$UserCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateInput;

  TRes call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? scannedQrs,
  });
  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes>
      get scannedQrs;
}

class _CopyWithImpl$Input$UserCreateInput<TRes>
    implements CopyWith$Input$UserCreateInput<TRes> {
  _CopyWithImpl$Input$UserCreateInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateInput _instance;

  final TRes Function(Input$UserCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? scannedQrs = _undefined,
  }) =>
      _then(Input$UserCreateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (fullName != _undefined && fullName != null)
          'fullName': (fullName as String),
        if (email != _undefined) 'email': (email as String?),
        if (password != _undefined) 'password': (password as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (role != _undefined && role != null) 'role': (role as Enum$UserRole),
        if (scannedQrs != _undefined)
          'scannedQrs': (scannedQrs
              as Input$QrCodeCreateNestedManyWithoutScannedByInput?),
      }));
  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes>
      get scannedQrs {
    final local$scannedQrs = _instance.scannedQrs;
    return local$scannedQrs == null
        ? CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput(
            local$scannedQrs, (e) => call(scannedQrs: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateInput<TRes>
    implements CopyWith$Input$UserCreateInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? scannedQrs,
  }) =>
      _res;
  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes>
      get scannedQrs =>
          CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput.stub(_res);
}

class Input$UserCreateManyInput {
  factory Input$UserCreateManyInput({
    String? id,
    required String fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    required Enum$UserRole role,
  }) =>
      Input$UserCreateManyInput._({
        if (id != null) r'id': id,
        r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        r'role': role,
      });

  Input$UserCreateManyInput._(this._$data);

  factory Input$UserCreateManyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$UserRole((l$role as String));
    return Input$UserCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get fullName => (_$data['fullName'] as String);
  String? get email => (_$data['email'] as String?);
  String? get password => (_$data['password'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$UserRole get role => (_$data['role'] as Enum$UserRole);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    final l$role = role;
    result$data['role'] = toJson$Enum$UserRole(l$role);
    return result$data;
  }

  CopyWith$Input$UserCreateManyInput<Input$UserCreateManyInput> get copyWith =>
      CopyWith$Input$UserCreateManyInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$fullName,
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      l$role,
    ]);
  }
}

abstract class CopyWith$Input$UserCreateManyInput<TRes> {
  factory CopyWith$Input$UserCreateManyInput(
    Input$UserCreateManyInput instance,
    TRes Function(Input$UserCreateManyInput) then,
  ) = _CopyWithImpl$Input$UserCreateManyInput;

  factory CopyWith$Input$UserCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateManyInput;

  TRes call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
  });
}

class _CopyWithImpl$Input$UserCreateManyInput<TRes>
    implements CopyWith$Input$UserCreateManyInput<TRes> {
  _CopyWithImpl$Input$UserCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateManyInput _instance;

  final TRes Function(Input$UserCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$UserCreateManyInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (fullName != _undefined && fullName != null)
          'fullName': (fullName as String),
        if (email != _undefined) 'email': (email as String?),
        if (password != _undefined) 'password': (password as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (role != _undefined && role != null) 'role': (role as Enum$UserRole),
      }));
}

class _CopyWithStubImpl$Input$UserCreateManyInput<TRes>
    implements CopyWith$Input$UserCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateManyInput(this._res);

  TRes _res;

  call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
  }) =>
      _res;
}

class Input$UserCreateNestedOneWithoutScannedQrsInput {
  factory Input$UserCreateNestedOneWithoutScannedQrsInput({
    Input$UserCreateWithoutScannedQrsInput? create,
    Input$UserCreateOrConnectWithoutScannedQrsInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  }) =>
      Input$UserCreateNestedOneWithoutScannedQrsInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$UserCreateNestedOneWithoutScannedQrsInput._(this._$data);

  factory Input$UserCreateNestedOneWithoutScannedQrsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$UserCreateWithoutScannedQrsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$UserCreateOrConnectWithoutScannedQrsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$UserWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$UserCreateNestedOneWithoutScannedQrsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserCreateWithoutScannedQrsInput? get create =>
      (_$data['create'] as Input$UserCreateWithoutScannedQrsInput?);
  Input$UserCreateOrConnectWithoutScannedQrsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$UserCreateOrConnectWithoutScannedQrsInput?);
  Input$UserWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$UserWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<
          Input$UserCreateNestedOneWithoutScannedQrsInput>
      get copyWith => CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateNestedOneWithoutScannedQrsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes> {
  factory CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput(
    Input$UserCreateNestedOneWithoutScannedQrsInput instance,
    TRes Function(Input$UserCreateNestedOneWithoutScannedQrsInput) then,
  ) = _CopyWithImpl$Input$UserCreateNestedOneWithoutScannedQrsInput;

  factory CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserCreateNestedOneWithoutScannedQrsInput;

  TRes call({
    Input$UserCreateWithoutScannedQrsInput? create,
    Input$UserCreateOrConnectWithoutScannedQrsInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  });
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create;
  CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes> {
  _CopyWithImpl$Input$UserCreateNestedOneWithoutScannedQrsInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateNestedOneWithoutScannedQrsInput _instance;

  final TRes Function(Input$UserCreateNestedOneWithoutScannedQrsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$UserCreateNestedOneWithoutScannedQrsInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$UserCreateWithoutScannedQrsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$UserCreateOrConnectWithoutScannedQrsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$UserWhereUniqueInput?),
      }));
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$UserCreateWithoutScannedQrsInput.stub(_then(_instance))
        : CopyWith$Input$UserCreateWithoutScannedQrsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$UserWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$UserWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserCreateNestedOneWithoutScannedQrsInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateNestedOneWithoutScannedQrsInput(this._res);

  TRes _res;

  call({
    Input$UserCreateWithoutScannedQrsInput? create,
    Input$UserCreateOrConnectWithoutScannedQrsInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutScannedQrsInput.stub(_res);
  CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput.stub(_res);
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
}

class Input$UserCreateOrConnectWithoutScannedQrsInput {
  factory Input$UserCreateOrConnectWithoutScannedQrsInput({
    required Input$UserWhereUniqueInput where,
    required Input$UserCreateWithoutScannedQrsInput create,
  }) =>
      Input$UserCreateOrConnectWithoutScannedQrsInput._({
        r'where': where,
        r'create': create,
      });

  Input$UserCreateOrConnectWithoutScannedQrsInput._(this._$data);

  factory Input$UserCreateOrConnectWithoutScannedQrsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$UserWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$UserCreateWithoutScannedQrsInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$UserCreateOrConnectWithoutScannedQrsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereUniqueInput get where =>
      (_$data['where'] as Input$UserWhereUniqueInput);
  Input$UserCreateWithoutScannedQrsInput get create =>
      (_$data['create'] as Input$UserCreateWithoutScannedQrsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<
          Input$UserCreateOrConnectWithoutScannedQrsInput>
      get copyWith => CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateOrConnectWithoutScannedQrsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes> {
  factory CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput(
    Input$UserCreateOrConnectWithoutScannedQrsInput instance,
    TRes Function(Input$UserCreateOrConnectWithoutScannedQrsInput) then,
  ) = _CopyWithImpl$Input$UserCreateOrConnectWithoutScannedQrsInput;

  factory CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserCreateOrConnectWithoutScannedQrsInput;

  TRes call({
    Input$UserWhereUniqueInput? where,
    Input$UserCreateWithoutScannedQrsInput? create,
  });
  CopyWith$Input$UserWhereUniqueInput<TRes> get where;
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create;
}

class _CopyWithImpl$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes> {
  _CopyWithImpl$Input$UserCreateOrConnectWithoutScannedQrsInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateOrConnectWithoutScannedQrsInput _instance;

  final TRes Function(Input$UserCreateOrConnectWithoutScannedQrsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$UserCreateOrConnectWithoutScannedQrsInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$UserWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$UserCreateWithoutScannedQrsInput),
      }));
  CopyWith$Input$UserWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$UserWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$UserCreateWithoutScannedQrsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateOrConnectWithoutScannedQrsInput(this._res);

  TRes _res;

  call({
    Input$UserWhereUniqueInput? where,
    Input$UserCreateWithoutScannedQrsInput? create,
  }) =>
      _res;
  CopyWith$Input$UserWhereUniqueInput<TRes> get where =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutScannedQrsInput.stub(_res);
}

class Input$UserCreateWithoutScannedQrsInput {
  factory Input$UserCreateWithoutScannedQrsInput({
    String? id,
    required String fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    required Enum$UserRole role,
  }) =>
      Input$UserCreateWithoutScannedQrsInput._({
        if (id != null) r'id': id,
        r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        r'role': role,
      });

  Input$UserCreateWithoutScannedQrsInput._(this._$data);

  factory Input$UserCreateWithoutScannedQrsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$UserRole((l$role as String));
    return Input$UserCreateWithoutScannedQrsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get fullName => (_$data['fullName'] as String);
  String? get email => (_$data['email'] as String?);
  String? get password => (_$data['password'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$UserRole get role => (_$data['role'] as Enum$UserRole);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    final l$role = role;
    result$data['role'] = toJson$Enum$UserRole(l$role);
    return result$data;
  }

  CopyWith$Input$UserCreateWithoutScannedQrsInput<
          Input$UserCreateWithoutScannedQrsInput>
      get copyWith => CopyWith$Input$UserCreateWithoutScannedQrsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateWithoutScannedQrsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$fullName,
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      l$role,
    ]);
  }
}

abstract class CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> {
  factory CopyWith$Input$UserCreateWithoutScannedQrsInput(
    Input$UserCreateWithoutScannedQrsInput instance,
    TRes Function(Input$UserCreateWithoutScannedQrsInput) then,
  ) = _CopyWithImpl$Input$UserCreateWithoutScannedQrsInput;

  factory CopyWith$Input$UserCreateWithoutScannedQrsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateWithoutScannedQrsInput;

  TRes call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
  });
}

class _CopyWithImpl$Input$UserCreateWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> {
  _CopyWithImpl$Input$UserCreateWithoutScannedQrsInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateWithoutScannedQrsInput _instance;

  final TRes Function(Input$UserCreateWithoutScannedQrsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$UserCreateWithoutScannedQrsInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (fullName != _undefined && fullName != null)
          'fullName': (fullName as String),
        if (email != _undefined) 'email': (email as String?),
        if (password != _undefined) 'password': (password as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (role != _undefined && role != null) 'role': (role as Enum$UserRole),
      }));
}

class _CopyWithStubImpl$Input$UserCreateWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateWithoutScannedQrsInput(this._res);

  TRes _res;

  call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
  }) =>
      _res;
}

class Input$UserMaxAggregateInput {
  factory Input$UserMaxAggregateInput({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
  }) =>
      Input$UserMaxAggregateInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
      });

  Input$UserMaxAggregateInput._(this._$data);

  factory Input$UserMaxAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = (l$fullName as bool?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as bool?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as bool?);
    }
    return Input$UserMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get fullName => (_$data['fullName'] as bool?);
  bool? get email => (_$data['email'] as bool?);
  bool? get password => (_$data['password'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get role => (_$data['role'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    return result$data;
  }

  CopyWith$Input$UserMaxAggregateInput<Input$UserMaxAggregateInput>
      get copyWith => CopyWith$Input$UserMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserMaxAggregateInput<TRes> {
  factory CopyWith$Input$UserMaxAggregateInput(
    Input$UserMaxAggregateInput instance,
    TRes Function(Input$UserMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$UserMaxAggregateInput;

  factory CopyWith$Input$UserMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserMaxAggregateInput;

  TRes call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
  });
}

class _CopyWithImpl$Input$UserMaxAggregateInput<TRes>
    implements CopyWith$Input$UserMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$UserMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$UserMaxAggregateInput _instance;

  final TRes Function(Input$UserMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$UserMaxAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (fullName != _undefined) 'fullName': (fullName as bool?),
        if (email != _undefined) 'email': (email as bool?),
        if (password != _undefined) 'password': (password as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (role != _undefined) 'role': (role as bool?),
      }));
}

class _CopyWithStubImpl$Input$UserMaxAggregateInput<TRes>
    implements CopyWith$Input$UserMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$UserMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
  }) =>
      _res;
}

class Input$UserMinAggregateInput {
  factory Input$UserMinAggregateInput({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
  }) =>
      Input$UserMinAggregateInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
      });

  Input$UserMinAggregateInput._(this._$data);

  factory Input$UserMinAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = (l$fullName as bool?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as bool?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as bool?);
    }
    return Input$UserMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get fullName => (_$data['fullName'] as bool?);
  bool? get email => (_$data['email'] as bool?);
  bool? get password => (_$data['password'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get role => (_$data['role'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    return result$data;
  }

  CopyWith$Input$UserMinAggregateInput<Input$UserMinAggregateInput>
      get copyWith => CopyWith$Input$UserMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserMinAggregateInput<TRes> {
  factory CopyWith$Input$UserMinAggregateInput(
    Input$UserMinAggregateInput instance,
    TRes Function(Input$UserMinAggregateInput) then,
  ) = _CopyWithImpl$Input$UserMinAggregateInput;

  factory CopyWith$Input$UserMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserMinAggregateInput;

  TRes call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
  });
}

class _CopyWithImpl$Input$UserMinAggregateInput<TRes>
    implements CopyWith$Input$UserMinAggregateInput<TRes> {
  _CopyWithImpl$Input$UserMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$UserMinAggregateInput _instance;

  final TRes Function(Input$UserMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$UserMinAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (fullName != _undefined) 'fullName': (fullName as bool?),
        if (email != _undefined) 'email': (email as bool?),
        if (password != _undefined) 'password': (password as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (role != _undefined) 'role': (role as bool?),
      }));
}

class _CopyWithStubImpl$Input$UserMinAggregateInput<TRes>
    implements CopyWith$Input$UserMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$UserMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
  }) =>
      _res;
}

class Input$UserNullableRelationFilter {
  factory Input$UserNullableRelationFilter({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  }) =>
      Input$UserNullableRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$UserNullableRelationFilter._(this._$data);

  factory Input$UserNullableRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$UserWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$UserWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$UserNullableRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereInput? get $is => (_$data['is'] as Input$UserWhereInput?);
  Input$UserWhereInput? get isNot => (_$data['isNot'] as Input$UserWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserNullableRelationFilter<Input$UserNullableRelationFilter>
      get copyWith => CopyWith$Input$UserNullableRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserNullableRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserNullableRelationFilter<TRes> {
  factory CopyWith$Input$UserNullableRelationFilter(
    Input$UserNullableRelationFilter instance,
    TRes Function(Input$UserNullableRelationFilter) then,
  ) = _CopyWithImpl$Input$UserNullableRelationFilter;

  factory CopyWith$Input$UserNullableRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserNullableRelationFilter;

  TRes call({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  });
  CopyWith$Input$UserWhereInput<TRes> get $is;
  CopyWith$Input$UserWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$UserNullableRelationFilter<TRes>
    implements CopyWith$Input$UserNullableRelationFilter<TRes> {
  _CopyWithImpl$Input$UserNullableRelationFilter(
    this._instance,
    this._then,
  );

  final Input$UserNullableRelationFilter _instance;

  final TRes Function(Input$UserNullableRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$UserNullableRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$UserWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$UserWhereInput?),
      }));
  CopyWith$Input$UserWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$UserNullableRelationFilter<TRes>
    implements CopyWith$Input$UserNullableRelationFilter<TRes> {
  _CopyWithStubImpl$Input$UserNullableRelationFilter(this._res);

  TRes _res;

  call({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$UserWhereInput<TRes> get $is =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get isNot =>
      CopyWith$Input$UserWhereInput.stub(_res);
}

class Input$UserOrderByWithRelationInput {
  factory Input$UserOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? fullName,
    Input$SortOrderInput? email,
    Input$SortOrderInput? password,
    Enum$SortOrder? createdAt,
    Input$SortOrderInput? updatedAt,
    Input$SortOrderInput? deletedAt,
    Enum$SortOrder? role,
    Input$QrCodeOrderByRelationAggregateInput? scannedQrs,
  }) =>
      Input$UserOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (scannedQrs != null) r'scannedQrs': scannedQrs,
      });

  Input$UserOrderByWithRelationInput._(this._$data);

  factory Input$UserOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : fromJson$Enum$SortOrder((l$fullName as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$SortOrderInput.fromJson((l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$SortOrderInput.fromJson((l$password as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] =
          l$role == null ? null : fromJson$Enum$SortOrder((l$role as String));
    }
    if (data.containsKey('scannedQrs')) {
      final l$scannedQrs = data['scannedQrs'];
      result$data['scannedQrs'] = l$scannedQrs == null
          ? null
          : Input$QrCodeOrderByRelationAggregateInput.fromJson(
              (l$scannedQrs as Map<String, dynamic>));
    }
    return Input$UserOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get fullName => (_$data['fullName'] as Enum$SortOrder?);
  Input$SortOrderInput? get email => (_$data['email'] as Input$SortOrderInput?);
  Input$SortOrderInput? get password =>
      (_$data['password'] as Input$SortOrderInput?);
  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);
  Input$SortOrderInput? get updatedAt =>
      (_$data['updatedAt'] as Input$SortOrderInput?);
  Input$SortOrderInput? get deletedAt =>
      (_$data['deletedAt'] as Input$SortOrderInput?);
  Enum$SortOrder? get role => (_$data['role'] as Enum$SortOrder?);
  Input$QrCodeOrderByRelationAggregateInput? get scannedQrs =>
      (_$data['scannedQrs'] as Input$QrCodeOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] =
          l$fullName == null ? null : toJson$Enum$SortOrder(l$fullName);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] =
          l$role == null ? null : toJson$Enum$SortOrder(l$role);
    }
    if (_$data.containsKey('scannedQrs')) {
      final l$scannedQrs = scannedQrs;
      result$data['scannedQrs'] = l$scannedQrs?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserOrderByWithRelationInput<
          Input$UserOrderByWithRelationInput>
      get copyWith => CopyWith$Input$UserOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$scannedQrs = scannedQrs;
    final lOther$scannedQrs = other.scannedQrs;
    if (_$data.containsKey('scannedQrs') !=
        other._$data.containsKey('scannedQrs')) {
      return false;
    }
    if (l$scannedQrs != lOther$scannedQrs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$scannedQrs = scannedQrs;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('scannedQrs') ? l$scannedQrs : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$UserOrderByWithRelationInput(
    Input$UserOrderByWithRelationInput instance,
    TRes Function(Input$UserOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$UserOrderByWithRelationInput;

  factory CopyWith$Input$UserOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? fullName,
    Input$SortOrderInput? email,
    Input$SortOrderInput? password,
    Enum$SortOrder? createdAt,
    Input$SortOrderInput? updatedAt,
    Input$SortOrderInput? deletedAt,
    Enum$SortOrder? role,
    Input$QrCodeOrderByRelationAggregateInput? scannedQrs,
  });
  CopyWith$Input$SortOrderInput<TRes> get email;
  CopyWith$Input$SortOrderInput<TRes> get password;
  CopyWith$Input$SortOrderInput<TRes> get updatedAt;
  CopyWith$Input$SortOrderInput<TRes> get deletedAt;
  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get scannedQrs;
}

class _CopyWithImpl$Input$UserOrderByWithRelationInput<TRes>
    implements CopyWith$Input$UserOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$UserOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$UserOrderByWithRelationInput _instance;

  final TRes Function(Input$UserOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? scannedQrs = _undefined,
  }) =>
      _then(Input$UserOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (fullName != _undefined) 'fullName': (fullName as Enum$SortOrder?),
        if (email != _undefined) 'email': (email as Input$SortOrderInput?),
        if (password != _undefined)
          'password': (password as Input$SortOrderInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$SortOrderInput?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$SortOrderInput?),
        if (role != _undefined) 'role': (role as Enum$SortOrder?),
        if (scannedQrs != _undefined)
          'scannedQrs':
              (scannedQrs as Input$QrCodeOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$SortOrderInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$email, (e) => call(email: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get scannedQrs {
    final local$scannedQrs = _instance.scannedQrs;
    return local$scannedQrs == null
        ? CopyWith$Input$QrCodeOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeOrderByRelationAggregateInput(
            local$scannedQrs, (e) => call(scannedQrs: e));
  }
}

class _CopyWithStubImpl$Input$UserOrderByWithRelationInput<TRes>
    implements CopyWith$Input$UserOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$UserOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? fullName,
    Input$SortOrderInput? email,
    Input$SortOrderInput? password,
    Enum$SortOrder? createdAt,
    Input$SortOrderInput? updatedAt,
    Input$SortOrderInput? deletedAt,
    Enum$SortOrder? role,
    Input$QrCodeOrderByRelationAggregateInput? scannedQrs,
  }) =>
      _res;
  CopyWith$Input$SortOrderInput<TRes> get email =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get password =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get updatedAt =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get deletedAt =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get scannedQrs =>
      CopyWith$Input$QrCodeOrderByRelationAggregateInput.stub(_res);
}

class Input$UserUpdateInput {
  factory Input$UserUpdateInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? scannedQrs,
  }) =>
      Input$UserUpdateInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (scannedQrs != null) r'scannedQrs': scannedQrs,
      });

  Input$UserUpdateInput._(this._$data);

  factory Input$UserUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('scannedQrs')) {
      final l$scannedQrs = data['scannedQrs'];
      result$data['scannedQrs'] = l$scannedQrs == null
          ? null
          : Input$QrCodeUpdateManyWithoutScannedByNestedInput.fromJson(
              (l$scannedQrs as Map<String, dynamic>));
    }
    return Input$UserUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get fullName =>
      (_$data['fullName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get email =>
      (_$data['email'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get password =>
      (_$data['password'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$EnumUserRoleFieldUpdateOperationsInput? get role =>
      (_$data['role'] as Input$EnumUserRoleFieldUpdateOperationsInput?);
  Input$QrCodeUpdateManyWithoutScannedByNestedInput? get scannedQrs =>
      (_$data['scannedQrs']
          as Input$QrCodeUpdateManyWithoutScannedByNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('scannedQrs')) {
      final l$scannedQrs = scannedQrs;
      result$data['scannedQrs'] = l$scannedQrs?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateInput<Input$UserUpdateInput> get copyWith =>
      CopyWith$Input$UserUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$scannedQrs = scannedQrs;
    final lOther$scannedQrs = other.scannedQrs;
    if (_$data.containsKey('scannedQrs') !=
        other._$data.containsKey('scannedQrs')) {
      return false;
    }
    if (l$scannedQrs != lOther$scannedQrs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$scannedQrs = scannedQrs;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('scannedQrs') ? l$scannedQrs : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateInput<TRes> {
  factory CopyWith$Input$UserUpdateInput(
    Input$UserUpdateInput instance,
    TRes Function(Input$UserUpdateInput) then,
  ) = _CopyWithImpl$Input$UserUpdateInput;

  factory CopyWith$Input$UserUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? scannedQrs,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role;
  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes>
      get scannedQrs;
}

class _CopyWithImpl$Input$UserUpdateInput<TRes>
    implements CopyWith$Input$UserUpdateInput<TRes> {
  _CopyWithImpl$Input$UserUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateInput _instance;

  final TRes Function(Input$UserUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? scannedQrs = _undefined,
  }) =>
      _then(Input$UserUpdateInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFieldUpdateOperationsInput?),
        if (email != _undefined)
          'email': (email as Input$NullableStringFieldUpdateOperationsInput?),
        if (password != _undefined)
          'password':
              (password as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (role != _undefined)
          'role': (role as Input$EnumUserRoleFieldUpdateOperationsInput?),
        if (scannedQrs != _undefined)
          'scannedQrs': (scannedQrs
              as Input$QrCodeUpdateManyWithoutScannedByNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes>
      get scannedQrs {
    final local$scannedQrs = _instance.scannedQrs;
    return local$scannedQrs == null
        ? CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
            local$scannedQrs, (e) => call(scannedQrs: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateInput<TRes>
    implements CopyWith$Input$UserUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? scannedQrs,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role =>
      CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes>
      get scannedQrs =>
          CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput.stub(_res);
}

class Input$UserUpdateManyMutationInput {
  factory Input$UserUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
  }) =>
      Input$UserUpdateManyMutationInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
      });

  Input$UserUpdateManyMutationInput._(this._$data);

  factory Input$UserUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    return Input$UserUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get fullName =>
      (_$data['fullName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get email =>
      (_$data['email'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get password =>
      (_$data['password'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$EnumUserRoleFieldUpdateOperationsInput? get role =>
      (_$data['role'] as Input$EnumUserRoleFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateManyMutationInput<Input$UserUpdateManyMutationInput>
      get copyWith => CopyWith$Input$UserUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$UserUpdateManyMutationInput(
    Input$UserUpdateManyMutationInput instance,
    TRes Function(Input$UserUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$UserUpdateManyMutationInput;

  factory CopyWith$Input$UserUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role;
}

class _CopyWithImpl$Input$UserUpdateManyMutationInput<TRes>
    implements CopyWith$Input$UserUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$UserUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateManyMutationInput _instance;

  final TRes Function(Input$UserUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$UserUpdateManyMutationInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFieldUpdateOperationsInput?),
        if (email != _undefined)
          'email': (email as Input$NullableStringFieldUpdateOperationsInput?),
        if (password != _undefined)
          'password':
              (password as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (role != _undefined)
          'role': (role as Input$EnumUserRoleFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            local$role, (e) => call(role: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateManyMutationInput<TRes>
    implements CopyWith$Input$UserUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role =>
      CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(_res);
}

class Input$UserUpdateOneWithoutScannedQrsNestedInput {
  factory Input$UserUpdateOneWithoutScannedQrsNestedInput({
    Input$UserCreateWithoutScannedQrsInput? create,
    Input$UserCreateOrConnectWithoutScannedQrsInput? connectOrCreate,
    Input$UserUpsertWithoutScannedQrsInput? upsert,
    Input$UserWhereInput? disconnect,
    Input$UserWhereInput? delete,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutScannedQrsInput? update,
  }) =>
      Input$UserUpdateOneWithoutScannedQrsNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$UserUpdateOneWithoutScannedQrsNestedInput._(this._$data);

  factory Input$UserUpdateOneWithoutScannedQrsNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$UserCreateWithoutScannedQrsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$UserCreateOrConnectWithoutScannedQrsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$UserUpsertWithoutScannedQrsInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$UserWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$UserWhereInput.fromJson((l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$UserWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$UserUpdateToOneWithWhereWithoutScannedQrsInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$UserUpdateOneWithoutScannedQrsNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserCreateWithoutScannedQrsInput? get create =>
      (_$data['create'] as Input$UserCreateWithoutScannedQrsInput?);
  Input$UserCreateOrConnectWithoutScannedQrsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$UserCreateOrConnectWithoutScannedQrsInput?);
  Input$UserUpsertWithoutScannedQrsInput? get upsert =>
      (_$data['upsert'] as Input$UserUpsertWithoutScannedQrsInput?);
  Input$UserWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$UserWhereInput?);
  Input$UserWhereInput? get delete =>
      (_$data['delete'] as Input$UserWhereInput?);
  Input$UserWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$UserWhereUniqueInput?);
  Input$UserUpdateToOneWithWhereWithoutScannedQrsInput? get update =>
      (_$data['update']
          as Input$UserUpdateToOneWithWhereWithoutScannedQrsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<
          Input$UserUpdateOneWithoutScannedQrsNestedInput>
      get copyWith => CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateOneWithoutScannedQrsNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes> {
  factory CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput(
    Input$UserUpdateOneWithoutScannedQrsNestedInput instance,
    TRes Function(Input$UserUpdateOneWithoutScannedQrsNestedInput) then,
  ) = _CopyWithImpl$Input$UserUpdateOneWithoutScannedQrsNestedInput;

  factory CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserUpdateOneWithoutScannedQrsNestedInput;

  TRes call({
    Input$UserCreateWithoutScannedQrsInput? create,
    Input$UserCreateOrConnectWithoutScannedQrsInput? connectOrCreate,
    Input$UserUpsertWithoutScannedQrsInput? upsert,
    Input$UserWhereInput? disconnect,
    Input$UserWhereInput? delete,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutScannedQrsInput? update,
  });
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create;
  CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$UserUpsertWithoutScannedQrsInput<TRes> get upsert;
  CopyWith$Input$UserWhereInput<TRes> get disconnect;
  CopyWith$Input$UserWhereInput<TRes> get delete;
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect;
  CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<TRes>
      get update;
}

class _CopyWithImpl$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes>
    implements CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes> {
  _CopyWithImpl$Input$UserUpdateOneWithoutScannedQrsNestedInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateOneWithoutScannedQrsNestedInput _instance;

  final TRes Function(Input$UserUpdateOneWithoutScannedQrsNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$UserUpdateOneWithoutScannedQrsNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$UserCreateWithoutScannedQrsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$UserCreateOrConnectWithoutScannedQrsInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$UserUpsertWithoutScannedQrsInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$UserWhereInput?),
        if (delete != _undefined) 'delete': (delete as Input$UserWhereInput?),
        if (connect != _undefined)
          'connect': (connect as Input$UserWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$UserUpdateToOneWithWhereWithoutScannedQrsInput?),
      }));
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$UserCreateWithoutScannedQrsInput.stub(_then(_instance))
        : CopyWith$Input$UserCreateWithoutScannedQrsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$UserUpsertWithoutScannedQrsInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$UserUpsertWithoutScannedQrsInput.stub(_then(_instance))
        : CopyWith$Input$UserUpsertWithoutScannedQrsInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$UserWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$UserWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes>
    implements CopyWith$Input$UserUpdateOneWithoutScannedQrsNestedInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateOneWithoutScannedQrsNestedInput(this._res);

  TRes _res;

  call({
    Input$UserCreateWithoutScannedQrsInput? create,
    Input$UserCreateOrConnectWithoutScannedQrsInput? connectOrCreate,
    Input$UserUpsertWithoutScannedQrsInput? upsert,
    Input$UserWhereInput? disconnect,
    Input$UserWhereInput? delete,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutScannedQrsInput? update,
  }) =>
      _res;
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutScannedQrsInput.stub(_res);
  CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$UserCreateOrConnectWithoutScannedQrsInput.stub(_res);
  CopyWith$Input$UserUpsertWithoutScannedQrsInput<TRes> get upsert =>
      CopyWith$Input$UserUpsertWithoutScannedQrsInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get disconnect =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get delete =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
  CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<TRes>
      get update =>
          CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput.stub(
              _res);
}

class Input$UserUpdateToOneWithWhereWithoutScannedQrsInput {
  factory Input$UserUpdateToOneWithWhereWithoutScannedQrsInput({
    Input$UserWhereInput? where,
    required Input$UserUpdateWithoutScannedQrsInput data,
  }) =>
      Input$UserUpdateToOneWithWhereWithoutScannedQrsInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$UserUpdateToOneWithWhereWithoutScannedQrsInput._(this._$data);

  factory Input$UserUpdateToOneWithWhereWithoutScannedQrsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$UserWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$UserUpdateWithoutScannedQrsInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$UserUpdateToOneWithWhereWithoutScannedQrsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereInput? get where => (_$data['where'] as Input$UserWhereInput?);
  Input$UserUpdateWithoutScannedQrsInput get data =>
      (_$data['data'] as Input$UserUpdateWithoutScannedQrsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<
          Input$UserUpdateToOneWithWhereWithoutScannedQrsInput>
      get copyWith =>
          CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateToOneWithWhereWithoutScannedQrsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<
    TRes> {
  factory CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput(
    Input$UserUpdateToOneWithWhereWithoutScannedQrsInput instance,
    TRes Function(Input$UserUpdateToOneWithWhereWithoutScannedQrsInput) then,
  ) = _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput;

  factory CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput;

  TRes call({
    Input$UserWhereInput? where,
    Input$UserUpdateWithoutScannedQrsInput? data,
  });
  CopyWith$Input$UserWhereInput<TRes> get where;
  CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> get data;
}

class _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<TRes>
    implements
        CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<TRes> {
  _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateToOneWithWhereWithoutScannedQrsInput _instance;

  final TRes Function(Input$UserUpdateToOneWithWhereWithoutScannedQrsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserUpdateToOneWithWhereWithoutScannedQrsInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$UserWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$UserUpdateWithoutScannedQrsInput),
      }));
  CopyWith$Input$UserWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$UserUpdateWithoutScannedQrsInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<
        TRes>
    implements
        CopyWith$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutScannedQrsInput(
      this._res);

  TRes _res;

  call({
    Input$UserWhereInput? where,
    Input$UserUpdateWithoutScannedQrsInput? data,
  }) =>
      _res;
  CopyWith$Input$UserWhereInput<TRes> get where =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> get data =>
      CopyWith$Input$UserUpdateWithoutScannedQrsInput.stub(_res);
}

class Input$UserUpdateWithoutScannedQrsInput {
  factory Input$UserUpdateWithoutScannedQrsInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
  }) =>
      Input$UserUpdateWithoutScannedQrsInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
      });

  Input$UserUpdateWithoutScannedQrsInput._(this._$data);

  factory Input$UserUpdateWithoutScannedQrsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    return Input$UserUpdateWithoutScannedQrsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get fullName =>
      (_$data['fullName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get email =>
      (_$data['email'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get password =>
      (_$data['password'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$EnumUserRoleFieldUpdateOperationsInput? get role =>
      (_$data['role'] as Input$EnumUserRoleFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateWithoutScannedQrsInput<
          Input$UserUpdateWithoutScannedQrsInput>
      get copyWith => CopyWith$Input$UserUpdateWithoutScannedQrsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateWithoutScannedQrsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> {
  factory CopyWith$Input$UserUpdateWithoutScannedQrsInput(
    Input$UserUpdateWithoutScannedQrsInput instance,
    TRes Function(Input$UserUpdateWithoutScannedQrsInput) then,
  ) = _CopyWithImpl$Input$UserUpdateWithoutScannedQrsInput;

  factory CopyWith$Input$UserUpdateWithoutScannedQrsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateWithoutScannedQrsInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role;
}

class _CopyWithImpl$Input$UserUpdateWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> {
  _CopyWithImpl$Input$UserUpdateWithoutScannedQrsInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateWithoutScannedQrsInput _instance;

  final TRes Function(Input$UserUpdateWithoutScannedQrsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$UserUpdateWithoutScannedQrsInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFieldUpdateOperationsInput?),
        if (email != _undefined)
          'email': (email as Input$NullableStringFieldUpdateOperationsInput?),
        if (password != _undefined)
          'password':
              (password as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt':
              (updatedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (role != _undefined)
          'role': (role as Input$EnumUserRoleFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            local$role, (e) => call(role: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateWithoutScannedQrsInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$NullableStringFieldUpdateOperationsInput? password,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get password =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get updatedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role =>
      CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(_res);
}

class Input$UserUpsertWithoutScannedQrsInput {
  factory Input$UserUpsertWithoutScannedQrsInput({
    required Input$UserUpdateWithoutScannedQrsInput update,
    required Input$UserCreateWithoutScannedQrsInput create,
    Input$UserWhereInput? where,
  }) =>
      Input$UserUpsertWithoutScannedQrsInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$UserUpsertWithoutScannedQrsInput._(this._$data);

  factory Input$UserUpsertWithoutScannedQrsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$UserUpdateWithoutScannedQrsInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$UserCreateWithoutScannedQrsInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$UserWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$UserUpsertWithoutScannedQrsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserUpdateWithoutScannedQrsInput get update =>
      (_$data['update'] as Input$UserUpdateWithoutScannedQrsInput);
  Input$UserCreateWithoutScannedQrsInput get create =>
      (_$data['create'] as Input$UserCreateWithoutScannedQrsInput);
  Input$UserWhereInput? get where => (_$data['where'] as Input$UserWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpsertWithoutScannedQrsInput<
          Input$UserUpsertWithoutScannedQrsInput>
      get copyWith => CopyWith$Input$UserUpsertWithoutScannedQrsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpsertWithoutScannedQrsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpsertWithoutScannedQrsInput<TRes> {
  factory CopyWith$Input$UserUpsertWithoutScannedQrsInput(
    Input$UserUpsertWithoutScannedQrsInput instance,
    TRes Function(Input$UserUpsertWithoutScannedQrsInput) then,
  ) = _CopyWithImpl$Input$UserUpsertWithoutScannedQrsInput;

  factory CopyWith$Input$UserUpsertWithoutScannedQrsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpsertWithoutScannedQrsInput;

  TRes call({
    Input$UserUpdateWithoutScannedQrsInput? update,
    Input$UserCreateWithoutScannedQrsInput? create,
    Input$UserWhereInput? where,
  });
  CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> get update;
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create;
  CopyWith$Input$UserWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$UserUpsertWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserUpsertWithoutScannedQrsInput<TRes> {
  _CopyWithImpl$Input$UserUpsertWithoutScannedQrsInput(
    this._instance,
    this._then,
  );

  final Input$UserUpsertWithoutScannedQrsInput _instance;

  final TRes Function(Input$UserUpsertWithoutScannedQrsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$UserUpsertWithoutScannedQrsInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$UserUpdateWithoutScannedQrsInput),
        if (create != _undefined && create != null)
          'create': (create as Input$UserCreateWithoutScannedQrsInput),
        if (where != _undefined) 'where': (where as Input$UserWhereInput?),
      }));
  CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$UserUpdateWithoutScannedQrsInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$UserCreateWithoutScannedQrsInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$UserUpsertWithoutScannedQrsInput<TRes>
    implements CopyWith$Input$UserUpsertWithoutScannedQrsInput<TRes> {
  _CopyWithStubImpl$Input$UserUpsertWithoutScannedQrsInput(this._res);

  TRes _res;

  call({
    Input$UserUpdateWithoutScannedQrsInput? update,
    Input$UserCreateWithoutScannedQrsInput? create,
    Input$UserWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$UserUpdateWithoutScannedQrsInput<TRes> get update =>
      CopyWith$Input$UserUpdateWithoutScannedQrsInput.stub(_res);
  CopyWith$Input$UserCreateWithoutScannedQrsInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutScannedQrsInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get where =>
      CopyWith$Input$UserWhereInput.stub(_res);
}

class Input$UserWhereInput {
  factory Input$UserWhereInput({
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? email,
    Input$StringNullableFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$QrCodeListRelationFilter? scannedQrs,
  }) =>
      Input$UserWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (scannedQrs != null) r'scannedQrs': scannedQrs,
      });

  Input$UserWhereInput._(this._$data);

  factory Input$UserWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFilter.fromJson((l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFilter.fromJson((l$role as Map<String, dynamic>));
    }
    if (data.containsKey('scannedQrs')) {
      final l$scannedQrs = data['scannedQrs'];
      result$data['scannedQrs'] = l$scannedQrs == null
          ? null
          : Input$QrCodeListRelationFilter.fromJson(
              (l$scannedQrs as Map<String, dynamic>));
    }
    return Input$UserWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UserWhereInput>? get AND =>
      (_$data['AND'] as List<Input$UserWhereInput>?);
  List<Input$UserWhereInput>? get OR =>
      (_$data['OR'] as List<Input$UserWhereInput>?);
  List<Input$UserWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$UserWhereInput>?);
  Input$StringFilter? get id => (_$data['id'] as Input$StringFilter?);
  Input$StringFilter? get fullName =>
      (_$data['fullName'] as Input$StringFilter?);
  Input$StringNullableFilter? get email =>
      (_$data['email'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get password =>
      (_$data['password'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$DateTimeNullableFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeNullableFilter? get deletedAt =>
      (_$data['deletedAt'] as Input$DateTimeNullableFilter?);
  Input$EnumUserRoleFilter? get role =>
      (_$data['role'] as Input$EnumUserRoleFilter?);
  Input$QrCodeListRelationFilter? get scannedQrs =>
      (_$data['scannedQrs'] as Input$QrCodeListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('scannedQrs')) {
      final l$scannedQrs = scannedQrs;
      result$data['scannedQrs'] = l$scannedQrs?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserWhereInput<Input$UserWhereInput> get copyWith =>
      CopyWith$Input$UserWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserWhereInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$scannedQrs = scannedQrs;
    final lOther$scannedQrs = other.scannedQrs;
    if (_$data.containsKey('scannedQrs') !=
        other._$data.containsKey('scannedQrs')) {
      return false;
    }
    if (l$scannedQrs != lOther$scannedQrs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$scannedQrs = scannedQrs;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('scannedQrs') ? l$scannedQrs : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserWhereInput<TRes> {
  factory CopyWith$Input$UserWhereInput(
    Input$UserWhereInput instance,
    TRes Function(Input$UserWhereInput) then,
  ) = _CopyWithImpl$Input$UserWhereInput;

  factory CopyWith$Input$UserWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserWhereInput;

  TRes call({
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? email,
    Input$StringNullableFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$QrCodeListRelationFilter? scannedQrs,
  });
  TRes AND(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get fullName;
  CopyWith$Input$StringNullableFilter<TRes> get email;
  CopyWith$Input$StringNullableFilter<TRes> get password;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFilter<TRes> get role;
  CopyWith$Input$QrCodeListRelationFilter<TRes> get scannedQrs;
}

class _CopyWithImpl$Input$UserWhereInput<TRes>
    implements CopyWith$Input$UserWhereInput<TRes> {
  _CopyWithImpl$Input$UserWhereInput(
    this._instance,
    this._then,
  );

  final Input$UserWhereInput _instance;

  final TRes Function(Input$UserWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? scannedQrs = _undefined,
  }) =>
      _then(Input$UserWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$UserWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$UserWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$UserWhereInput>?),
        if (id != _undefined) 'id': (id as Input$StringFilter?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFilter?),
        if (email != _undefined)
          'email': (email as Input$StringNullableFilter?),
        if (password != _undefined)
          'password': (password as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeNullableFilter?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$DateTimeNullableFilter?),
        if (role != _undefined) 'role': (role as Input$EnumUserRoleFilter?),
        if (scannedQrs != _undefined)
          'scannedQrs': (scannedQrs as Input$QrCodeListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFilter<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$EnumUserRoleFilter(local$role, (e) => call(role: e));
  }

  CopyWith$Input$QrCodeListRelationFilter<TRes> get scannedQrs {
    final local$scannedQrs = _instance.scannedQrs;
    return local$scannedQrs == null
        ? CopyWith$Input$QrCodeListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$QrCodeListRelationFilter(
            local$scannedQrs, (e) => call(scannedQrs: e));
  }
}

class _CopyWithStubImpl$Input$UserWhereInput<TRes>
    implements CopyWith$Input$UserWhereInput<TRes> {
  _CopyWithStubImpl$Input$UserWhereInput(this._res);

  TRes _res;

  call({
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? email,
    Input$StringNullableFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$QrCodeListRelationFilter? scannedQrs,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get id =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get fullName =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get email =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get password =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$EnumUserRoleFilter<TRes> get role =>
      CopyWith$Input$EnumUserRoleFilter.stub(_res);
  CopyWith$Input$QrCodeListRelationFilter<TRes> get scannedQrs =>
      CopyWith$Input$QrCodeListRelationFilter.stub(_res);
}

class Input$UserWhereUniqueInput {
  factory Input$UserWhereUniqueInput({
    String? id,
    String? email,
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$QrCodeListRelationFilter? scannedQrs,
  }) =>
      Input$UserWhereUniqueInput._({
        if (id != null) r'id': id,
        if (email != null) r'email': email,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (fullName != null) r'fullName': fullName,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (scannedQrs != null) r'scannedQrs': scannedQrs,
      });

  Input$UserWhereUniqueInput._(this._$data);

  factory Input$UserWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFilter.fromJson((l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFilter.fromJson((l$role as Map<String, dynamic>));
    }
    if (data.containsKey('scannedQrs')) {
      final l$scannedQrs = data['scannedQrs'];
      result$data['scannedQrs'] = l$scannedQrs == null
          ? null
          : Input$QrCodeListRelationFilter.fromJson(
              (l$scannedQrs as Map<String, dynamic>));
    }
    return Input$UserWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get email => (_$data['email'] as String?);
  List<Input$UserWhereInput>? get AND =>
      (_$data['AND'] as List<Input$UserWhereInput>?);
  List<Input$UserWhereInput>? get OR =>
      (_$data['OR'] as List<Input$UserWhereInput>?);
  List<Input$UserWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$UserWhereInput>?);
  Input$StringFilter? get fullName =>
      (_$data['fullName'] as Input$StringFilter?);
  Input$StringNullableFilter? get password =>
      (_$data['password'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$DateTimeNullableFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeNullableFilter? get deletedAt =>
      (_$data['deletedAt'] as Input$DateTimeNullableFilter?);
  Input$EnumUserRoleFilter? get role =>
      (_$data['role'] as Input$EnumUserRoleFilter?);
  Input$QrCodeListRelationFilter? get scannedQrs =>
      (_$data['scannedQrs'] as Input$QrCodeListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('scannedQrs')) {
      final l$scannedQrs = scannedQrs;
      result$data['scannedQrs'] = l$scannedQrs?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserWhereUniqueInput<Input$UserWhereUniqueInput>
      get copyWith => CopyWith$Input$UserWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$scannedQrs = scannedQrs;
    final lOther$scannedQrs = other.scannedQrs;
    if (_$data.containsKey('scannedQrs') !=
        other._$data.containsKey('scannedQrs')) {
      return false;
    }
    if (l$scannedQrs != lOther$scannedQrs) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$fullName = fullName;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$scannedQrs = scannedQrs;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('scannedQrs') ? l$scannedQrs : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserWhereUniqueInput<TRes> {
  factory CopyWith$Input$UserWhereUniqueInput(
    Input$UserWhereUniqueInput instance,
    TRes Function(Input$UserWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$UserWhereUniqueInput;

  factory CopyWith$Input$UserWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserWhereUniqueInput;

  TRes call({
    String? id,
    String? email,
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$QrCodeListRelationFilter? scannedQrs,
  });
  TRes AND(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get fullName;
  CopyWith$Input$StringNullableFilter<TRes> get password;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFilter<TRes> get role;
  CopyWith$Input$QrCodeListRelationFilter<TRes> get scannedQrs;
}

class _CopyWithImpl$Input$UserWhereUniqueInput<TRes>
    implements CopyWith$Input$UserWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$UserWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$UserWhereUniqueInput _instance;

  final TRes Function(Input$UserWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? email = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? fullName = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? scannedQrs = _undefined,
  }) =>
      _then(Input$UserWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (email != _undefined) 'email': (email as String?),
        if (AND != _undefined) 'AND': (AND as List<Input$UserWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$UserWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$UserWhereInput>?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFilter?),
        if (password != _undefined)
          'password': (password as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeNullableFilter?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$DateTimeNullableFilter?),
        if (role != _undefined) 'role': (role as Input$EnumUserRoleFilter?),
        if (scannedQrs != _undefined)
          'scannedQrs': (scannedQrs as Input$QrCodeListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFilter<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$EnumUserRoleFilter(local$role, (e) => call(role: e));
  }

  CopyWith$Input$QrCodeListRelationFilter<TRes> get scannedQrs {
    final local$scannedQrs = _instance.scannedQrs;
    return local$scannedQrs == null
        ? CopyWith$Input$QrCodeListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$QrCodeListRelationFilter(
            local$scannedQrs, (e) => call(scannedQrs: e));
  }
}

class _CopyWithStubImpl$Input$UserWhereUniqueInput<TRes>
    implements CopyWith$Input$UserWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$UserWhereUniqueInput(this._res);

  TRes _res;

  call({
    String? id,
    String? email,
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeNullableFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$QrCodeListRelationFilter? scannedQrs,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get fullName =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get password =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$EnumUserRoleFilter<TRes> get role =>
      CopyWith$Input$EnumUserRoleFilter.stub(_res);
  CopyWith$Input$QrCodeListRelationFilter<TRes> get scannedQrs =>
      CopyWith$Input$QrCodeListRelationFilter.stub(_res);
}

class Input$WhatsappStatusAvgAggregateInput {
  factory Input$WhatsappStatusAvgAggregateInput({bool? id}) =>
      Input$WhatsappStatusAvgAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$WhatsappStatusAvgAggregateInput._(this._$data);

  factory Input$WhatsappStatusAvgAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    return Input$WhatsappStatusAvgAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusAvgAggregateInput<
          Input$WhatsappStatusAvgAggregateInput>
      get copyWith => CopyWith$Input$WhatsappStatusAvgAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusAvgAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$WhatsappStatusAvgAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappStatusAvgAggregateInput(
    Input$WhatsappStatusAvgAggregateInput instance,
    TRes Function(Input$WhatsappStatusAvgAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusAvgAggregateInput;

  factory CopyWith$Input$WhatsappStatusAvgAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusAvgAggregateInput;

  TRes call({bool? id});
}

class _CopyWithImpl$Input$WhatsappStatusAvgAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusAvgAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusAvgAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusAvgAggregateInput _instance;

  final TRes Function(Input$WhatsappStatusAvgAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$WhatsappStatusAvgAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusAvgAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusAvgAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusAvgAggregateInput(this._res);

  TRes _res;

  call({bool? id}) => _res;
}

class Input$WhatsappStatusCountAggregateInput {
  factory Input$WhatsappStatusCountAggregateInput({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  }) =>
      Input$WhatsappStatusCountAggregateInput._({
        if (id != null) r'id': id,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if ($_all != null) r'_all': $_all,
      });

  Input$WhatsappStatusCountAggregateInput._(this._$data);

  factory Input$WhatsappStatusCountAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = (l$refId as bool?);
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = (l$messageId as bool?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$WhatsappStatusCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get refId => (_$data['refId'] as bool?);
  bool? get messageId => (_$data['messageId'] as bool?);
  bool? get message => (_$data['message'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId;
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusCountAggregateInput<
          Input$WhatsappStatusCountAggregateInput>
      get copyWith => CopyWith$Input$WhatsappStatusCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusCountAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappStatusCountAggregateInput(
    Input$WhatsappStatusCountAggregateInput instance,
    TRes Function(Input$WhatsappStatusCountAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusCountAggregateInput;

  factory CopyWith$Input$WhatsappStatusCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusCountAggregateInput;

  TRes call({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$WhatsappStatusCountAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusCountAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusCountAggregateInput _instance;

  final TRes Function(Input$WhatsappStatusCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$WhatsappStatusCountAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (refId != _undefined) 'refId': (refId as bool?),
        if (messageId != _undefined) 'messageId': (messageId as bool?),
        if (message != _undefined) 'message': (message as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusCountAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  }) =>
      _res;
}

class Input$WhatsappStatusCreateInput {
  factory Input$WhatsappStatusCreateInput({
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
    required Input$GuestCreateNestedOneWithoutWhatsappStatusesInput guest,
  }) =>
      Input$WhatsappStatusCreateInput._({
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        r'guest': guest,
      });

  Input$WhatsappStatusCreateInput._(this._$data);

  factory Input$WhatsappStatusCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = (l$refId as String?);
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = (l$messageId as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    final l$guest = data['guest'];
    result$data['guest'] =
        Input$GuestCreateNestedOneWithoutWhatsappStatusesInput.fromJson(
            (l$guest as Map<String, dynamic>));
    return Input$WhatsappStatusCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get refId => (_$data['refId'] as String?);
  String? get messageId => (_$data['messageId'] as String?);
  String? get message => (_$data['message'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Input$GuestCreateNestedOneWithoutWhatsappStatusesInput get guest =>
      (_$data['guest']
          as Input$GuestCreateNestedOneWithoutWhatsappStatusesInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId;
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    final l$guest = guest;
    result$data['guest'] = l$guest.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappStatusCreateInput<Input$WhatsappStatusCreateInput>
      get copyWith => CopyWith$Input$WhatsappStatusCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      l$guest,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusCreateInput<TRes> {
  factory CopyWith$Input$WhatsappStatusCreateInput(
    Input$WhatsappStatusCreateInput instance,
    TRes Function(Input$WhatsappStatusCreateInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusCreateInput;

  factory CopyWith$Input$WhatsappStatusCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusCreateInput;

  TRes call({
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
    Input$GuestCreateNestedOneWithoutWhatsappStatusesInput? guest,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<TRes>
      get guest;
}

class _CopyWithImpl$Input$WhatsappStatusCreateInput<TRes>
    implements CopyWith$Input$WhatsappStatusCreateInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusCreateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusCreateInput _instance;

  final TRes Function(Input$WhatsappStatusCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappStatusCreateInput._({
        ..._instance._$data,
        if (refId != _undefined) 'refId': (refId as String?),
        if (messageId != _undefined) 'messageId': (messageId as String?),
        if (message != _undefined) 'message': (message as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
        if (guest != _undefined && guest != null)
          'guest':
              (guest as Input$GuestCreateNestedOneWithoutWhatsappStatusesInput),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput(
        local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusCreateInput<TRes>
    implements CopyWith$Input$WhatsappStatusCreateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusCreateInput(this._res);

  TRes _res;

  call({
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
    Input$GuestCreateNestedOneWithoutWhatsappStatusesInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput<TRes>
      get guest =>
          CopyWith$Input$GuestCreateNestedOneWithoutWhatsappStatusesInput.stub(
              _res);
}

class Input$WhatsappStatusCreateManyGuestInput {
  factory Input$WhatsappStatusCreateManyGuestInput({
    int? id,
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      Input$WhatsappStatusCreateManyGuestInput._({
        if (id != null) r'id': id,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$WhatsappStatusCreateManyGuestInput._(this._$data);

  factory Input$WhatsappStatusCreateManyGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = (l$refId as String?);
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = (l$messageId as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    return Input$WhatsappStatusCreateManyGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String? get refId => (_$data['refId'] as String?);
  String? get messageId => (_$data['messageId'] as String?);
  String? get message => (_$data['message'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId;
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusCreateManyGuestInput<
          Input$WhatsappStatusCreateManyGuestInput>
      get copyWith => CopyWith$Input$WhatsappStatusCreateManyGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusCreateManyGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusCreateManyGuestInput<TRes> {
  factory CopyWith$Input$WhatsappStatusCreateManyGuestInput(
    Input$WhatsappStatusCreateManyGuestInput instance,
    TRes Function(Input$WhatsappStatusCreateManyGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusCreateManyGuestInput;

  factory CopyWith$Input$WhatsappStatusCreateManyGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusCreateManyGuestInput;

  TRes call({
    int? id,
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
  });
}

class _CopyWithImpl$Input$WhatsappStatusCreateManyGuestInput<TRes>
    implements CopyWith$Input$WhatsappStatusCreateManyGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusCreateManyGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusCreateManyGuestInput _instance;

  final TRes Function(Input$WhatsappStatusCreateManyGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$WhatsappStatusCreateManyGuestInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (refId != _undefined) 'refId': (refId as String?),
        if (messageId != _undefined) 'messageId': (messageId as String?),
        if (message != _undefined) 'message': (message as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusCreateManyGuestInput<TRes>
    implements CopyWith$Input$WhatsappStatusCreateManyGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusCreateManyGuestInput(this._res);

  TRes _res;

  call({
    int? id,
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      _res;
}

class Input$WhatsappStatusCreateManyGuestInputEnvelope {
  factory Input$WhatsappStatusCreateManyGuestInputEnvelope({
    required List<Input$WhatsappStatusCreateManyGuestInput> data,
    bool? skipDuplicates,
  }) =>
      Input$WhatsappStatusCreateManyGuestInputEnvelope._({
        r'data': data,
        if (skipDuplicates != null) r'skipDuplicates': skipDuplicates,
      });

  Input$WhatsappStatusCreateManyGuestInputEnvelope._(this._$data);

  factory Input$WhatsappStatusCreateManyGuestInputEnvelope.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => Input$WhatsappStatusCreateManyGuestInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = data['skipDuplicates'];
      result$data['skipDuplicates'] = (l$skipDuplicates as bool?);
    }
    return Input$WhatsappStatusCreateManyGuestInputEnvelope._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappStatusCreateManyGuestInput> get data =>
      (_$data['data'] as List<Input$WhatsappStatusCreateManyGuestInput>);
  bool? get skipDuplicates => (_$data['skipDuplicates'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = skipDuplicates;
      result$data['skipDuplicates'] = l$skipDuplicates;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<
          Input$WhatsappStatusCreateManyGuestInputEnvelope>
      get copyWith => CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusCreateManyGuestInputEnvelope) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (_$data.containsKey('skipDuplicates') !=
        other._$data.containsKey('skipDuplicates')) {
      return false;
    }
    if (l$skipDuplicates != lOther$skipDuplicates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('skipDuplicates') ? l$skipDuplicates : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes> {
  factory CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope(
    Input$WhatsappStatusCreateManyGuestInputEnvelope instance,
    TRes Function(Input$WhatsappStatusCreateManyGuestInputEnvelope) then,
  ) = _CopyWithImpl$Input$WhatsappStatusCreateManyGuestInputEnvelope;

  factory CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusCreateManyGuestInputEnvelope;

  TRes call({
    List<Input$WhatsappStatusCreateManyGuestInput>? data,
    bool? skipDuplicates,
  });
  TRes data(
      Iterable<Input$WhatsappStatusCreateManyGuestInput> Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusCreateManyGuestInput<
                      Input$WhatsappStatusCreateManyGuestInput>>)
          _fn);
}

class _CopyWithImpl$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes>
    implements CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes> {
  _CopyWithImpl$Input$WhatsappStatusCreateManyGuestInputEnvelope(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusCreateManyGuestInputEnvelope _instance;

  final TRes Function(Input$WhatsappStatusCreateManyGuestInputEnvelope) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? skipDuplicates = _undefined,
  }) =>
      _then(Input$WhatsappStatusCreateManyGuestInputEnvelope._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<Input$WhatsappStatusCreateManyGuestInput>),
        if (skipDuplicates != _undefined)
          'skipDuplicates': (skipDuplicates as bool?),
      }));
  TRes data(
          Iterable<Input$WhatsappStatusCreateManyGuestInput> Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusCreateManyGuestInput<
                          Input$WhatsappStatusCreateManyGuestInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$Input$WhatsappStatusCreateManyGuestInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes>
    implements CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusCreateManyGuestInputEnvelope(this._res);

  TRes _res;

  call({
    List<Input$WhatsappStatusCreateManyGuestInput>? data,
    bool? skipDuplicates,
  }) =>
      _res;
  data(_fn) => _res;
}

class Input$WhatsappStatusCreateManyInput {
  factory Input$WhatsappStatusCreateManyInput({
    int? id,
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
    required String guestId,
  }) =>
      Input$WhatsappStatusCreateManyInput._({
        if (id != null) r'id': id,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        r'guestId': guestId,
      });

  Input$WhatsappStatusCreateManyInput._(this._$data);

  factory Input$WhatsappStatusCreateManyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = (l$refId as String?);
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = (l$messageId as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    final l$guestId = data['guestId'];
    result$data['guestId'] = (l$guestId as String);
    return Input$WhatsappStatusCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String? get refId => (_$data['refId'] as String?);
  String? get messageId => (_$data['messageId'] as String?);
  String? get message => (_$data['message'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  String get guestId => (_$data['guestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId;
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    final l$guestId = guestId;
    result$data['guestId'] = l$guestId;
    return result$data;
  }

  CopyWith$Input$WhatsappStatusCreateManyInput<
          Input$WhatsappStatusCreateManyInput>
      get copyWith => CopyWith$Input$WhatsappStatusCreateManyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      l$guestId,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusCreateManyInput<TRes> {
  factory CopyWith$Input$WhatsappStatusCreateManyInput(
    Input$WhatsappStatusCreateManyInput instance,
    TRes Function(Input$WhatsappStatusCreateManyInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusCreateManyInput;

  factory CopyWith$Input$WhatsappStatusCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusCreateManyInput;

  TRes call({
    int? id,
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
    String? guestId,
  });
}

class _CopyWithImpl$Input$WhatsappStatusCreateManyInput<TRes>
    implements CopyWith$Input$WhatsappStatusCreateManyInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusCreateManyInput _instance;

  final TRes Function(Input$WhatsappStatusCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$WhatsappStatusCreateManyInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (refId != _undefined) 'refId': (refId as String?),
        if (messageId != _undefined) 'messageId': (messageId as String?),
        if (message != _undefined) 'message': (message as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
        if (guestId != _undefined && guestId != null)
          'guestId': (guestId as String),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusCreateManyInput<TRes>
    implements CopyWith$Input$WhatsappStatusCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusCreateManyInput(this._res);

  TRes _res;

  call({
    int? id,
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
    String? guestId,
  }) =>
      _res;
}

class Input$WhatsappStatusCreateNestedManyWithoutGuestInput {
  factory Input$WhatsappStatusCreateNestedManyWithoutGuestInput({
    List<Input$WhatsappStatusCreateWithoutGuestInput>? create,
    List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$WhatsappStatusCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappStatusWhereUniqueInput>? connect,
  }) =>
      Input$WhatsappStatusCreateNestedManyWithoutGuestInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (createMany != null) r'createMany': createMany,
        if (connect != null) r'connect': connect,
      });

  Input$WhatsappStatusCreateNestedManyWithoutGuestInput._(this._$data);

  factory Input$WhatsappStatusCreateNestedManyWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusCreateWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$WhatsappStatusCreateOrConnectWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$WhatsappStatusCreateManyGuestInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$WhatsappStatusCreateNestedManyWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappStatusCreateWithoutGuestInput>? get create =>
      (_$data['create'] as List<Input$WhatsappStatusCreateWithoutGuestInput>?);
  List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>?);
  Input$WhatsappStatusCreateManyGuestInputEnvelope? get createMany =>
      (_$data['createMany']
          as Input$WhatsappStatusCreateManyGuestInputEnvelope?);
  List<Input$WhatsappStatusWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$WhatsappStatusWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<
          Input$WhatsappStatusCreateNestedManyWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusCreateNestedManyWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
    Input$WhatsappStatusCreateNestedManyWithoutGuestInput instance,
    TRes Function(Input$WhatsappStatusCreateNestedManyWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusCreateNestedManyWithoutGuestInput;

  factory CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusCreateNestedManyWithoutGuestInput;

  TRes call({
    List<Input$WhatsappStatusCreateWithoutGuestInput>? create,
    List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$WhatsappStatusCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappStatusWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$WhatsappStatusCreateWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<
                      Input$WhatsappStatusCreateWithoutGuestInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<
                      Input$WhatsappStatusCreateOrConnectWithoutGuestInput>>?)
          _fn);
  CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes>
      get createMany;
  TRes connect(
      Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereUniqueInput<
                      Input$WhatsappStatusWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes>
    implements
        CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusCreateNestedManyWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappStatusCreateNestedManyWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? createMany = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$WhatsappStatusCreateNestedManyWithoutGuestInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$WhatsappStatusCreateWithoutGuestInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$WhatsappStatusCreateManyGuestInputEnvelope?),
        if (connect != _undefined)
          'connect': (connect as List<Input$WhatsappStatusWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$WhatsappStatusCreateWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<
                          Input$WhatsappStatusCreateWithoutGuestInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$WhatsappStatusCreateWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<
                          Input$WhatsappStatusCreateOrConnectWithoutGuestInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes>
      get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes connect(
          Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereUniqueInput<
                          Input$WhatsappStatusWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$WhatsappStatusWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusCreateNestedManyWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusCreateNestedManyWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    List<Input$WhatsappStatusCreateWithoutGuestInput>? create,
    List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$WhatsappStatusCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappStatusWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes>
      get createMany =>
          CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope.stub(_res);
  connect(_fn) => _res;
}

class Input$WhatsappStatusCreateOrConnectWithoutGuestInput {
  factory Input$WhatsappStatusCreateOrConnectWithoutGuestInput({
    required Input$WhatsappStatusWhereUniqueInput where,
    required Input$WhatsappStatusCreateWithoutGuestInput create,
  }) =>
      Input$WhatsappStatusCreateOrConnectWithoutGuestInput._({
        r'where': where,
        r'create': create,
      });

  Input$WhatsappStatusCreateOrConnectWithoutGuestInput._(this._$data);

  factory Input$WhatsappStatusCreateOrConnectWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$WhatsappStatusWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$WhatsappStatusCreateWithoutGuestInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$WhatsappStatusCreateOrConnectWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappStatusWhereUniqueInput get where =>
      (_$data['where'] as Input$WhatsappStatusWhereUniqueInput);
  Input$WhatsappStatusCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$WhatsappStatusCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<
          Input$WhatsappStatusCreateOrConnectWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusCreateOrConnectWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput(
    Input$WhatsappStatusCreateOrConnectWithoutGuestInput instance,
    TRes Function(Input$WhatsappStatusCreateOrConnectWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusCreateOrConnectWithoutGuestInput;

  factory CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusCreateOrConnectWithoutGuestInput;

  TRes call({
    Input$WhatsappStatusWhereUniqueInput? where,
    Input$WhatsappStatusCreateWithoutGuestInput? create,
  });
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where;
  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<TRes>
    implements
        CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusCreateOrConnectWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusCreateOrConnectWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappStatusCreateOrConnectWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$WhatsappStatusCreateOrConnectWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$WhatsappStatusWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$WhatsappStatusCreateWithoutGuestInput),
      }));
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$WhatsappStatusWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$WhatsappStatusCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusCreateOrConnectWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$WhatsappStatusWhereUniqueInput? where,
    Input$WhatsappStatusCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where =>
      CopyWith$Input$WhatsappStatusWhereUniqueInput.stub(_res);
  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$WhatsappStatusCreateWithoutGuestInput.stub(_res);
}

class Input$WhatsappStatusCreateWithoutGuestInput {
  factory Input$WhatsappStatusCreateWithoutGuestInput({
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      Input$WhatsappStatusCreateWithoutGuestInput._({
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$WhatsappStatusCreateWithoutGuestInput._(this._$data);

  factory Input$WhatsappStatusCreateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = (l$refId as String?);
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = (l$messageId as String?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    return Input$WhatsappStatusCreateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get refId => (_$data['refId'] as String?);
  String? get messageId => (_$data['messageId'] as String?);
  String? get message => (_$data['message'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId;
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<
          Input$WhatsappStatusCreateWithoutGuestInput>
      get copyWith => CopyWith$Input$WhatsappStatusCreateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusCreateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> {
  factory CopyWith$Input$WhatsappStatusCreateWithoutGuestInput(
    Input$WhatsappStatusCreateWithoutGuestInput instance,
    TRes Function(Input$WhatsappStatusCreateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusCreateWithoutGuestInput;

  factory CopyWith$Input$WhatsappStatusCreateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusCreateWithoutGuestInput;

  TRes call({
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
  });
}

class _CopyWithImpl$Input$WhatsappStatusCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusCreateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusCreateWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappStatusCreateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$WhatsappStatusCreateWithoutGuestInput._({
        ..._instance._$data,
        if (refId != _undefined) 'refId': (refId as String?),
        if (messageId != _undefined) 'messageId': (messageId as String?),
        if (message != _undefined) 'message': (message as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusCreateWithoutGuestInput(this._res);

  TRes _res;

  call({
    String? refId,
    String? messageId,
    String? message,
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      _res;
}

class Input$WhatsappStatusListRelationFilter {
  factory Input$WhatsappStatusListRelationFilter({
    Input$WhatsappStatusWhereInput? every,
    Input$WhatsappStatusWhereInput? some,
    Input$WhatsappStatusWhereInput? none,
  }) =>
      Input$WhatsappStatusListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$WhatsappStatusListRelationFilter._(this._$data);

  factory Input$WhatsappStatusListRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$WhatsappStatusWhereInput.fromJson(
              (l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$WhatsappStatusWhereInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$WhatsappStatusWhereInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    return Input$WhatsappStatusListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappStatusWhereInput? get every =>
      (_$data['every'] as Input$WhatsappStatusWhereInput?);
  Input$WhatsappStatusWhereInput? get some =>
      (_$data['some'] as Input$WhatsappStatusWhereInput?);
  Input$WhatsappStatusWhereInput? get none =>
      (_$data['none'] as Input$WhatsappStatusWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusListRelationFilter<
          Input$WhatsappStatusListRelationFilter>
      get copyWith => CopyWith$Input$WhatsappStatusListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusListRelationFilter<TRes> {
  factory CopyWith$Input$WhatsappStatusListRelationFilter(
    Input$WhatsappStatusListRelationFilter instance,
    TRes Function(Input$WhatsappStatusListRelationFilter) then,
  ) = _CopyWithImpl$Input$WhatsappStatusListRelationFilter;

  factory CopyWith$Input$WhatsappStatusListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusListRelationFilter;

  TRes call({
    Input$WhatsappStatusWhereInput? every,
    Input$WhatsappStatusWhereInput? some,
    Input$WhatsappStatusWhereInput? none,
  });
  CopyWith$Input$WhatsappStatusWhereInput<TRes> get every;
  CopyWith$Input$WhatsappStatusWhereInput<TRes> get some;
  CopyWith$Input$WhatsappStatusWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$WhatsappStatusListRelationFilter<TRes>
    implements CopyWith$Input$WhatsappStatusListRelationFilter<TRes> {
  _CopyWithImpl$Input$WhatsappStatusListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusListRelationFilter _instance;

  final TRes Function(Input$WhatsappStatusListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$WhatsappStatusListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined)
          'every': (every as Input$WhatsappStatusWhereInput?),
        if (some != _undefined)
          'some': (some as Input$WhatsappStatusWhereInput?),
        if (none != _undefined)
          'none': (none as Input$WhatsappStatusWhereInput?),
      }));
  CopyWith$Input$WhatsappStatusWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$WhatsappStatusWhereInput.stub(_then(_instance))
        : CopyWith$Input$WhatsappStatusWhereInput(
            local$every, (e) => call(every: e));
  }

  CopyWith$Input$WhatsappStatusWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$WhatsappStatusWhereInput.stub(_then(_instance))
        : CopyWith$Input$WhatsappStatusWhereInput(
            local$some, (e) => call(some: e));
  }

  CopyWith$Input$WhatsappStatusWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$WhatsappStatusWhereInput.stub(_then(_instance))
        : CopyWith$Input$WhatsappStatusWhereInput(
            local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusListRelationFilter<TRes>
    implements CopyWith$Input$WhatsappStatusListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusListRelationFilter(this._res);

  TRes _res;

  call({
    Input$WhatsappStatusWhereInput? every,
    Input$WhatsappStatusWhereInput? some,
    Input$WhatsappStatusWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$WhatsappStatusWhereInput<TRes> get every =>
      CopyWith$Input$WhatsappStatusWhereInput.stub(_res);
  CopyWith$Input$WhatsappStatusWhereInput<TRes> get some =>
      CopyWith$Input$WhatsappStatusWhereInput.stub(_res);
  CopyWith$Input$WhatsappStatusWhereInput<TRes> get none =>
      CopyWith$Input$WhatsappStatusWhereInput.stub(_res);
}

class Input$WhatsappStatusMaxAggregateInput {
  factory Input$WhatsappStatusMaxAggregateInput({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      Input$WhatsappStatusMaxAggregateInput._({
        if (id != null) r'id': id,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$WhatsappStatusMaxAggregateInput._(this._$data);

  factory Input$WhatsappStatusMaxAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = (l$refId as bool?);
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = (l$messageId as bool?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    return Input$WhatsappStatusMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get refId => (_$data['refId'] as bool?);
  bool? get messageId => (_$data['messageId'] as bool?);
  bool? get message => (_$data['message'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId;
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusMaxAggregateInput<
          Input$WhatsappStatusMaxAggregateInput>
      get copyWith => CopyWith$Input$WhatsappStatusMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusMaxAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappStatusMaxAggregateInput(
    Input$WhatsappStatusMaxAggregateInput instance,
    TRes Function(Input$WhatsappStatusMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusMaxAggregateInput;

  factory CopyWith$Input$WhatsappStatusMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusMaxAggregateInput;

  TRes call({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
  });
}

class _CopyWithImpl$Input$WhatsappStatusMaxAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusMaxAggregateInput _instance;

  final TRes Function(Input$WhatsappStatusMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$WhatsappStatusMaxAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (refId != _undefined) 'refId': (refId as bool?),
        if (messageId != _undefined) 'messageId': (messageId as bool?),
        if (message != _undefined) 'message': (message as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusMaxAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      _res;
}

class Input$WhatsappStatusMinAggregateInput {
  factory Input$WhatsappStatusMinAggregateInput({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      Input$WhatsappStatusMinAggregateInput._({
        if (id != null) r'id': id,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$WhatsappStatusMinAggregateInput._(this._$data);

  factory Input$WhatsappStatusMinAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = (l$refId as bool?);
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = (l$messageId as bool?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    return Input$WhatsappStatusMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get refId => (_$data['refId'] as bool?);
  bool? get messageId => (_$data['messageId'] as bool?);
  bool? get message => (_$data['message'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId;
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusMinAggregateInput<
          Input$WhatsappStatusMinAggregateInput>
      get copyWith => CopyWith$Input$WhatsappStatusMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusMinAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappStatusMinAggregateInput(
    Input$WhatsappStatusMinAggregateInput instance,
    TRes Function(Input$WhatsappStatusMinAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusMinAggregateInput;

  factory CopyWith$Input$WhatsappStatusMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusMinAggregateInput;

  TRes call({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
  });
}

class _CopyWithImpl$Input$WhatsappStatusMinAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusMinAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusMinAggregateInput _instance;

  final TRes Function(Input$WhatsappStatusMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$WhatsappStatusMinAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (refId != _undefined) 'refId': (refId as bool?),
        if (messageId != _undefined) 'messageId': (messageId as bool?),
        if (message != _undefined) 'message': (message as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusMinAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? refId,
    bool? messageId,
    bool? message,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      _res;
}

class Input$WhatsappStatusOrderByRelationAggregateInput {
  factory Input$WhatsappStatusOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$WhatsappStatusOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$WhatsappStatusOrderByRelationAggregateInput._(this._$data);

  factory Input$WhatsappStatusOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$WhatsappStatusOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput<
          Input$WhatsappStatusOrderByRelationAggregateInput>
      get copyWith =>
          CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput<
    TRes> {
  factory CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput(
    Input$WhatsappStatusOrderByRelationAggregateInput instance,
    TRes Function(Input$WhatsappStatusOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusOrderByRelationAggregateInput;

  factory CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$WhatsappStatusOrderByRelationAggregateInput<TRes>
    implements
        CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusOrderByRelationAggregateInput _instance;

  final TRes Function(Input$WhatsappStatusOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$WhatsappStatusOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusOrderByRelationAggregateInput<TRes>
    implements
        CopyWith$Input$WhatsappStatusOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusOrderByRelationAggregateInput(
      this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$WhatsappStatusOrderByWithRelationInput {
  factory Input$WhatsappStatusOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? refId,
    Input$SortOrderInput? messageId,
    Input$SortOrderInput? message,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  }) =>
      Input$WhatsappStatusOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$WhatsappStatusOrderByWithRelationInput._(this._$data);

  factory Input$WhatsappStatusOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] =
          l$refId == null ? null : fromJson$Enum$SortOrder((l$refId as String));
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = l$messageId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$messageId as Map<String, dynamic>));
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = l$message == null
          ? null
          : Input$SortOrderInput.fromJson((l$message as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortOrder((l$status as String));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : fromJson$Enum$SortOrder((l$guestId as String));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestOrderByWithRelationInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$WhatsappStatusOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get refId => (_$data['refId'] as Enum$SortOrder?);
  Input$SortOrderInput? get messageId =>
      (_$data['messageId'] as Input$SortOrderInput?);
  Input$SortOrderInput? get message =>
      (_$data['message'] as Input$SortOrderInput?);
  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);
  Enum$SortOrder? get status => (_$data['status'] as Enum$SortOrder?);
  Enum$SortOrder? get guestId => (_$data['guestId'] as Enum$SortOrder?);
  Input$GuestOrderByWithRelationInput? get guest =>
      (_$data['guest'] as Input$GuestOrderByWithRelationInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] =
          l$refId == null ? null : toJson$Enum$SortOrder(l$refId);
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId?.toJson();
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$SortOrder(l$status);
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] =
          l$guestId == null ? null : toJson$Enum$SortOrder(l$guestId);
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusOrderByWithRelationInput<
          Input$WhatsappStatusOrderByWithRelationInput>
      get copyWith => CopyWith$Input$WhatsappStatusOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$WhatsappStatusOrderByWithRelationInput(
    Input$WhatsappStatusOrderByWithRelationInput instance,
    TRes Function(Input$WhatsappStatusOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusOrderByWithRelationInput;

  factory CopyWith$Input$WhatsappStatusOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? refId,
    Input$SortOrderInput? messageId,
    Input$SortOrderInput? message,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  });
  CopyWith$Input$SortOrderInput<TRes> get messageId;
  CopyWith$Input$SortOrderInput<TRes> get message;
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest;
}

class _CopyWithImpl$Input$WhatsappStatusOrderByWithRelationInput<TRes>
    implements CopyWith$Input$WhatsappStatusOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusOrderByWithRelationInput _instance;

  final TRes Function(Input$WhatsappStatusOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappStatusOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (refId != _undefined) 'refId': (refId as Enum$SortOrder?),
        if (messageId != _undefined)
          'messageId': (messageId as Input$SortOrderInput?),
        if (message != _undefined)
          'message': (message as Input$SortOrderInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (status != _undefined) 'status': (status as Enum$SortOrder?),
        if (guestId != _undefined) 'guestId': (guestId as Enum$SortOrder?),
        if (guest != _undefined)
          'guest': (guest as Input$GuestOrderByWithRelationInput?),
      }));
  CopyWith$Input$SortOrderInput<TRes> get messageId {
    final local$messageId = _instance.messageId;
    return local$messageId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$messageId, (e) => call(messageId: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get message {
    final local$message = _instance.message;
    return local$message == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$message, (e) => call(message: e));
  }

  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$GuestOrderByWithRelationInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusOrderByWithRelationInput<TRes>
    implements CopyWith$Input$WhatsappStatusOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? refId,
    Input$SortOrderInput? messageId,
    Input$SortOrderInput? message,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  }) =>
      _res;
  CopyWith$Input$SortOrderInput<TRes> get messageId =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get message =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest =>
      CopyWith$Input$GuestOrderByWithRelationInput.stub(_res);
}

class Input$WhatsappStatusScalarWhereInput {
  factory Input$WhatsappStatusScalarWhereInput({
    List<Input$WhatsappStatusScalarWhereInput>? AND,
    List<Input$WhatsappStatusScalarWhereInput>? OR,
    List<Input$WhatsappStatusScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  }) =>
      Input$WhatsappStatusScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$WhatsappStatusScalarWhereInput._(this._$data);

  factory Input$WhatsappStatusScalarWhereInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = l$refId == null
          ? null
          : Input$StringFilter.fromJson((l$refId as Map<String, dynamic>));
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = l$messageId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$messageId as Map<String, dynamic>));
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = l$message == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$message as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    return Input$WhatsappStatusScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappStatusScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$WhatsappStatusScalarWhereInput>?);
  List<Input$WhatsappStatusScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$WhatsappStatusScalarWhereInput>?);
  List<Input$WhatsappStatusScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$WhatsappStatusScalarWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$StringFilter? get refId => (_$data['refId'] as Input$StringFilter?);
  Input$StringNullableFilter? get messageId =>
      (_$data['messageId'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get message =>
      (_$data['message'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId?.toJson();
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId?.toJson();
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusScalarWhereInput<
          Input$WhatsappStatusScalarWhereInput>
      get copyWith => CopyWith$Input$WhatsappStatusScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusScalarWhereInput<TRes> {
  factory CopyWith$Input$WhatsappStatusScalarWhereInput(
    Input$WhatsappStatusScalarWhereInput instance,
    TRes Function(Input$WhatsappStatusScalarWhereInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusScalarWhereInput;

  factory CopyWith$Input$WhatsappStatusScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusScalarWhereInput;

  TRes call({
    List<Input$WhatsappStatusScalarWhereInput>? AND,
    List<Input$WhatsappStatusScalarWhereInput>? OR,
    List<Input$WhatsappStatusScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  });
  TRes AND(
      Iterable<Input$WhatsappStatusScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusScalarWhereInput<
                      Input$WhatsappStatusScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$WhatsappStatusScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusScalarWhereInput<
                      Input$WhatsappStatusScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$WhatsappStatusScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusScalarWhereInput<
                      Input$WhatsappStatusScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get refId;
  CopyWith$Input$StringNullableFilter<TRes> get messageId;
  CopyWith$Input$StringNullableFilter<TRes> get message;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
}

class _CopyWithImpl$Input$WhatsappStatusScalarWhereInput<TRes>
    implements CopyWith$Input$WhatsappStatusScalarWhereInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusScalarWhereInput _instance;

  final TRes Function(Input$WhatsappStatusScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$WhatsappStatusScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$WhatsappStatusScalarWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$WhatsappStatusScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$WhatsappStatusScalarWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (refId != _undefined) 'refId': (refId as Input$StringFilter?),
        if (messageId != _undefined)
          'messageId': (messageId as Input$StringNullableFilter?),
        if (message != _undefined)
          'message': (message as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
      }));
  TRes AND(
          Iterable<Input$WhatsappStatusScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusScalarWhereInput<
                          Input$WhatsappStatusScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$WhatsappStatusScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$WhatsappStatusScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusScalarWhereInput<
                          Input$WhatsappStatusScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$WhatsappStatusScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$WhatsappStatusScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusScalarWhereInput<
                          Input$WhatsappStatusScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$WhatsappStatusScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get refId {
    final local$refId = _instance.refId;
    return local$refId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$refId, (e) => call(refId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get messageId {
    final local$messageId = _instance.messageId;
    return local$messageId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$messageId, (e) => call(messageId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get message {
    final local$message = _instance.message;
    return local$message == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$message, (e) => call(message: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusScalarWhereInput<TRes>
    implements CopyWith$Input$WhatsappStatusScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$WhatsappStatusScalarWhereInput>? AND,
    List<Input$WhatsappStatusScalarWhereInput>? OR,
    List<Input$WhatsappStatusScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get refId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get messageId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get message =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
}

class Input$WhatsappStatusSumAggregateInput {
  factory Input$WhatsappStatusSumAggregateInput({bool? id}) =>
      Input$WhatsappStatusSumAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$WhatsappStatusSumAggregateInput._(this._$data);

  factory Input$WhatsappStatusSumAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    return Input$WhatsappStatusSumAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusSumAggregateInput<
          Input$WhatsappStatusSumAggregateInput>
      get copyWith => CopyWith$Input$WhatsappStatusSumAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusSumAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$WhatsappStatusSumAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappStatusSumAggregateInput(
    Input$WhatsappStatusSumAggregateInput instance,
    TRes Function(Input$WhatsappStatusSumAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusSumAggregateInput;

  factory CopyWith$Input$WhatsappStatusSumAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusSumAggregateInput;

  TRes call({bool? id});
}

class _CopyWithImpl$Input$WhatsappStatusSumAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusSumAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusSumAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusSumAggregateInput _instance;

  final TRes Function(Input$WhatsappStatusSumAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$WhatsappStatusSumAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappStatusSumAggregateInput<TRes>
    implements CopyWith$Input$WhatsappStatusSumAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusSumAggregateInput(this._res);

  TRes _res;

  call({bool? id}) => _res;
}

class Input$WhatsappStatusUpdateInput {
  factory Input$WhatsappStatusUpdateInput({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput? guest,
  }) =>
      Input$WhatsappStatusUpdateInput._({
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guest != null) r'guest': guest,
      });

  Input$WhatsappStatusUpdateInput._(this._$data);

  factory Input$WhatsappStatusUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = l$refId == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$refId as Map<String, dynamic>));
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = l$messageId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$messageId as Map<String, dynamic>));
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = l$message == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$message as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput
              .fromJson((l$guest as Map<String, dynamic>));
    }
    return Input$WhatsappStatusUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get refId =>
      (_$data['refId'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get messageId =>
      (_$data['messageId'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get message =>
      (_$data['message'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput? get guest =>
      (_$data['guest']
          as Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId?.toJson();
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId?.toJson();
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusUpdateInput<Input$WhatsappStatusUpdateInput>
      get copyWith => CopyWith$Input$WhatsappStatusUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusUpdateInput<TRes> {
  factory CopyWith$Input$WhatsappStatusUpdateInput(
    Input$WhatsappStatusUpdateInput instance,
    TRes Function(Input$WhatsappStatusUpdateInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusUpdateInput;

  factory CopyWith$Input$WhatsappStatusUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput? guest,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
  CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<TRes>
      get guest;
}

class _CopyWithImpl$Input$WhatsappStatusUpdateInput<TRes>
    implements CopyWith$Input$WhatsappStatusUpdateInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusUpdateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusUpdateInput _instance;

  final TRes Function(Input$WhatsappStatusUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappStatusUpdateInput._({
        ..._instance._$data,
        if (refId != _undefined)
          'refId': (refId as Input$StringFieldUpdateOperationsInput?),
        if (messageId != _undefined)
          'messageId':
              (messageId as Input$NullableStringFieldUpdateOperationsInput?),
        if (message != _undefined)
          'message':
              (message as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
        if (guest != _undefined)
          'guest': (guest
              as Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId {
    final local$refId = _instance.refId;
    return local$refId == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$refId, (e) => call(refId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId {
    final local$messageId = _instance.messageId;
    return local$messageId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$messageId, (e) => call(messageId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message {
    final local$message = _instance.message;
    return local$message == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$message, (e) => call(message: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusUpdateInput<TRes>
    implements CopyWith$Input$WhatsappStatusUpdateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput? guest,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput<TRes>
      get guest =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappStatusesNestedInput
              .stub(_res);
}

class Input$WhatsappStatusUpdateManyMutationInput {
  factory Input$WhatsappStatusUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      Input$WhatsappStatusUpdateManyMutationInput._({
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$WhatsappStatusUpdateManyMutationInput._(this._$data);

  factory Input$WhatsappStatusUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = l$refId == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$refId as Map<String, dynamic>));
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = l$messageId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$messageId as Map<String, dynamic>));
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = l$message == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$message as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    return Input$WhatsappStatusUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get refId =>
      (_$data['refId'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get messageId =>
      (_$data['messageId'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get message =>
      (_$data['message'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId?.toJson();
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId?.toJson();
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusUpdateManyMutationInput<
          Input$WhatsappStatusUpdateManyMutationInput>
      get copyWith => CopyWith$Input$WhatsappStatusUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$WhatsappStatusUpdateManyMutationInput(
    Input$WhatsappStatusUpdateManyMutationInput instance,
    TRes Function(Input$WhatsappStatusUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusUpdateManyMutationInput;

  factory CopyWith$Input$WhatsappStatusUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
}

class _CopyWithImpl$Input$WhatsappStatusUpdateManyMutationInput<TRes>
    implements CopyWith$Input$WhatsappStatusUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusUpdateManyMutationInput _instance;

  final TRes Function(Input$WhatsappStatusUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$WhatsappStatusUpdateManyMutationInput._({
        ..._instance._$data,
        if (refId != _undefined)
          'refId': (refId as Input$StringFieldUpdateOperationsInput?),
        if (messageId != _undefined)
          'messageId':
              (messageId as Input$NullableStringFieldUpdateOperationsInput?),
        if (message != _undefined)
          'message':
              (message as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId {
    final local$refId = _instance.refId;
    return local$refId == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$refId, (e) => call(refId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId {
    final local$messageId = _instance.messageId;
    return local$messageId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$messageId, (e) => call(messageId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message {
    final local$message = _instance.message;
    return local$message == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$message, (e) => call(message: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusUpdateManyMutationInput<TRes>
    implements CopyWith$Input$WhatsappStatusUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
}

class Input$WhatsappStatusUpdateManyWithoutGuestNestedInput {
  factory Input$WhatsappStatusUpdateManyWithoutGuestNestedInput({
    List<Input$WhatsappStatusCreateWithoutGuestInput>? create,
    List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$WhatsappStatusCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappStatusWhereUniqueInput>? $set,
    List<Input$WhatsappStatusWhereUniqueInput>? disconnect,
    List<Input$WhatsappStatusWhereUniqueInput>? delete,
    List<Input$WhatsappStatusWhereUniqueInput>? connect,
    List<Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$WhatsappStatusScalarWhereInput>? deleteMany,
  }) =>
      Input$WhatsappStatusUpdateManyWithoutGuestNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (createMany != null) r'createMany': createMany,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$WhatsappStatusUpdateManyWithoutGuestNestedInput._(this._$data);

  factory Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusCreateWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$WhatsappStatusCreateOrConnectWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$WhatsappStatusCreateManyGuestInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$WhatsappStatusUpdateManyWithoutGuestNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappStatusCreateWithoutGuestInput>? get create =>
      (_$data['create'] as List<Input$WhatsappStatusCreateWithoutGuestInput>?);
  List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>?);
  List<Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>?
      get upsert => (_$data['upsert']
          as List<Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>?);
  Input$WhatsappStatusCreateManyGuestInputEnvelope? get createMany =>
      (_$data['createMany']
          as Input$WhatsappStatusCreateManyGuestInputEnvelope?);
  List<Input$WhatsappStatusWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$WhatsappStatusWhereUniqueInput>?);
  List<Input$WhatsappStatusWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$WhatsappStatusWhereUniqueInput>?);
  List<Input$WhatsappStatusWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$WhatsappStatusWhereUniqueInput>?);
  List<Input$WhatsappStatusWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$WhatsappStatusWhereUniqueInput>?);
  List<Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>?
      get update => (_$data['update']
          as List<Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>?);
  List<Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>?
      get updateMany => (_$data['updateMany']
          as List<Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>?);
  List<Input$WhatsappStatusScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$WhatsappStatusScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<
          Input$WhatsappStatusUpdateManyWithoutGuestNestedInput>
      get copyWith =>
          CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusUpdateManyWithoutGuestNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<
    TRes> {
  factory CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
    Input$WhatsappStatusUpdateManyWithoutGuestNestedInput instance,
    TRes Function(Input$WhatsappStatusUpdateManyWithoutGuestNestedInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput;

  factory CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput;

  TRes call({
    List<Input$WhatsappStatusCreateWithoutGuestInput>? create,
    List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$WhatsappStatusCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappStatusWhereUniqueInput>? $set,
    List<Input$WhatsappStatusWhereUniqueInput>? disconnect,
    List<Input$WhatsappStatusWhereUniqueInput>? delete,
    List<Input$WhatsappStatusWhereUniqueInput>? connect,
    List<Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$WhatsappStatusScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$WhatsappStatusCreateWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<
                      Input$WhatsappStatusCreateWithoutGuestInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<
                      Input$WhatsappStatusCreateOrConnectWithoutGuestInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput<
                      Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>>?)
          _fn);
  CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes>
      get createMany;
  TRes $set(
      Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereUniqueInput<
                      Input$WhatsappStatusWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereUniqueInput<
                      Input$WhatsappStatusWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereUniqueInput<
                      Input$WhatsappStatusWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereUniqueInput<
                      Input$WhatsappStatusWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput<
                      Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput<
                      Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$WhatsappStatusScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusScalarWhereInput<
                      Input$WhatsappStatusScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes>
    implements
        CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusUpdateManyWithoutGuestNestedInput _instance;

  final TRes Function(Input$WhatsappStatusUpdateManyWithoutGuestNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? createMany = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$WhatsappStatusUpdateManyWithoutGuestNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$WhatsappStatusCreateWithoutGuestInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$WhatsappStatusCreateManyGuestInputEnvelope?),
        if ($set != _undefined)
          'set': ($set as List<Input$WhatsappStatusWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$WhatsappStatusWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$WhatsappStatusWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$WhatsappStatusWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$WhatsappStatusScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$WhatsappStatusCreateWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<
                          Input$WhatsappStatusCreateWithoutGuestInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$WhatsappStatusCreateWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput<
                          Input$WhatsappStatusCreateOrConnectWithoutGuestInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$WhatsappStatusCreateOrConnectWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput<
                          Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes>
      get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes $set(
          Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereUniqueInput<
                          Input$WhatsappStatusWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$WhatsappStatusWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereUniqueInput<
                          Input$WhatsappStatusWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$WhatsappStatusWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereUniqueInput<
                          Input$WhatsappStatusWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$WhatsappStatusWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$WhatsappStatusWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereUniqueInput<
                          Input$WhatsappStatusWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$WhatsappStatusWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput<
                          Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput<
                          Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$WhatsappStatusScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusScalarWhereInput<
                          Input$WhatsappStatusScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$WhatsappStatusScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusUpdateManyWithoutGuestNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$WhatsappStatusCreateWithoutGuestInput>? create,
    List<Input$WhatsappStatusCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$WhatsappStatusCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappStatusWhereUniqueInput>? $set,
    List<Input$WhatsappStatusWhereUniqueInput>? disconnect,
    List<Input$WhatsappStatusWhereUniqueInput>? delete,
    List<Input$WhatsappStatusWhereUniqueInput>? connect,
    List<Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$WhatsappStatusScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope<TRes>
      get createMany =>
          CopyWith$Input$WhatsappStatusCreateManyGuestInputEnvelope.stub(_res);
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput {
  factory Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput({
    required Input$WhatsappStatusScalarWhereInput where,
    required Input$WhatsappStatusUpdateManyMutationInput data,
  }) =>
      Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput._({
        r'where': where,
        r'data': data,
      });

  Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput._(this._$data);

  factory Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$WhatsappStatusScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$WhatsappStatusUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappStatusScalarWhereInput get where =>
      (_$data['where'] as Input$WhatsappStatusScalarWhereInput);
  Input$WhatsappStatusUpdateManyMutationInput get data =>
      (_$data['data'] as Input$WhatsappStatusUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput<
          Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput(
    Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput instance,
    TRes Function(Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput)
        then,
  ) = _CopyWithImpl$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput;

  factory CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput;

  TRes call({
    Input$WhatsappStatusScalarWhereInput? where,
    Input$WhatsappStatusUpdateManyMutationInput? data,
  });
  CopyWith$Input$WhatsappStatusScalarWhereInput<TRes> get where;
  CopyWith$Input$WhatsappStatusUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput<
            TRes> {
  _CopyWithImpl$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$WhatsappStatusScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$WhatsappStatusUpdateManyMutationInput),
      }));
  CopyWith$Input$WhatsappStatusScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$WhatsappStatusScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$WhatsappStatusUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$WhatsappStatusUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput<
            TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusUpdateManyWithWhereWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$WhatsappStatusScalarWhereInput? where,
    Input$WhatsappStatusUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$WhatsappStatusScalarWhereInput<TRes> get where =>
      CopyWith$Input$WhatsappStatusScalarWhereInput.stub(_res);
  CopyWith$Input$WhatsappStatusUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$WhatsappStatusUpdateManyMutationInput.stub(_res);
}

class Input$WhatsappStatusUpdateWithoutGuestInput {
  factory Input$WhatsappStatusUpdateWithoutGuestInput({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      Input$WhatsappStatusUpdateWithoutGuestInput._({
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$WhatsappStatusUpdateWithoutGuestInput._(this._$data);

  factory Input$WhatsappStatusUpdateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = l$refId == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$refId as Map<String, dynamic>));
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = l$messageId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$messageId as Map<String, dynamic>));
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = l$message == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$message as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    return Input$WhatsappStatusUpdateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get refId =>
      (_$data['refId'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get messageId =>
      (_$data['messageId'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get message =>
      (_$data['message'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId?.toJson();
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId?.toJson();
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<
          Input$WhatsappStatusUpdateWithoutGuestInput>
      get copyWith => CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusUpdateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> {
  factory CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput(
    Input$WhatsappStatusUpdateWithoutGuestInput instance,
    TRes Function(Input$WhatsappStatusUpdateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusUpdateWithoutGuestInput;

  factory CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusUpdateWithoutGuestInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
}

class _CopyWithImpl$Input$WhatsappStatusUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusUpdateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusUpdateWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappStatusUpdateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$WhatsappStatusUpdateWithoutGuestInput._({
        ..._instance._$data,
        if (refId != _undefined)
          'refId': (refId as Input$StringFieldUpdateOperationsInput?),
        if (messageId != _undefined)
          'messageId':
              (messageId as Input$NullableStringFieldUpdateOperationsInput?),
        if (message != _undefined)
          'message':
              (message as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId {
    final local$refId = _instance.refId;
    return local$refId == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$refId, (e) => call(refId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId {
    final local$messageId = _instance.messageId;
    return local$messageId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$messageId, (e) => call(messageId: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message {
    final local$message = _instance.message;
    return local$message == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$message, (e) => call(message: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusUpdateWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? refId,
    Input$NullableStringFieldUpdateOperationsInput? messageId,
    Input$NullableStringFieldUpdateOperationsInput? message,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get refId =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get messageId =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get message =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
}

class Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput {
  factory Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput({
    required Input$WhatsappStatusWhereUniqueInput where,
    required Input$WhatsappStatusUpdateWithoutGuestInput data,
  }) =>
      Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput._({
        r'where': where,
        r'data': data,
      });

  Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput._(this._$data);

  factory Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$WhatsappStatusWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$WhatsappStatusUpdateWithoutGuestInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappStatusWhereUniqueInput get where =>
      (_$data['where'] as Input$WhatsappStatusWhereUniqueInput);
  Input$WhatsappStatusUpdateWithoutGuestInput get data =>
      (_$data['data'] as Input$WhatsappStatusUpdateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput<
          Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput(
    Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput instance,
    TRes Function(Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput)
        then,
  ) = _CopyWithImpl$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput;

  factory CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput;

  TRes call({
    Input$WhatsappStatusWhereUniqueInput? where,
    Input$WhatsappStatusUpdateWithoutGuestInput? data,
  });
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where;
  CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> get data;
}

class _CopyWithImpl$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput<
            TRes> {
  _CopyWithImpl$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput _instance;

  final TRes Function(
      Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$WhatsappStatusWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$WhatsappStatusUpdateWithoutGuestInput),
      }));
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$WhatsappStatusWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput<
            TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusUpdateWithWhereUniqueWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$WhatsappStatusWhereUniqueInput? where,
    Input$WhatsappStatusUpdateWithoutGuestInput? data,
  }) =>
      _res;
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where =>
      CopyWith$Input$WhatsappStatusWhereUniqueInput.stub(_res);
  CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> get data =>
      CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput.stub(_res);
}

class Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput {
  factory Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput({
    required Input$WhatsappStatusWhereUniqueInput where,
    required Input$WhatsappStatusUpdateWithoutGuestInput update,
    required Input$WhatsappStatusCreateWithoutGuestInput create,
  }) =>
      Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput._(this._$data);

  factory Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$WhatsappStatusWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] =
        Input$WhatsappStatusUpdateWithoutGuestInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$WhatsappStatusCreateWithoutGuestInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappStatusWhereUniqueInput get where =>
      (_$data['where'] as Input$WhatsappStatusWhereUniqueInput);
  Input$WhatsappStatusUpdateWithoutGuestInput get update =>
      (_$data['update'] as Input$WhatsappStatusUpdateWithoutGuestInput);
  Input$WhatsappStatusCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$WhatsappStatusCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput<
          Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput(
    Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput instance,
    TRes Function(Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput)
        then,
  ) = _CopyWithImpl$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput;

  factory CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput;

  TRes call({
    Input$WhatsappStatusWhereUniqueInput? where,
    Input$WhatsappStatusUpdateWithoutGuestInput? update,
    Input$WhatsappStatusCreateWithoutGuestInput? create,
  });
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where;
  CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> get update;
  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput<
            TRes> {
  _CopyWithImpl$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput _instance;

  final TRes Function(
      Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$WhatsappStatusWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$WhatsappStatusUpdateWithoutGuestInput),
        if (create != _undefined && create != null)
          'create': (create as Input$WhatsappStatusCreateWithoutGuestInput),
      }));
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$WhatsappStatusWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$WhatsappStatusCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput<
            TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusUpsertWithWhereUniqueWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$WhatsappStatusWhereUniqueInput? where,
    Input$WhatsappStatusUpdateWithoutGuestInput? update,
    Input$WhatsappStatusCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> get where =>
      CopyWith$Input$WhatsappStatusWhereUniqueInput.stub(_res);
  CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput<TRes> get update =>
      CopyWith$Input$WhatsappStatusUpdateWithoutGuestInput.stub(_res);
  CopyWith$Input$WhatsappStatusCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$WhatsappStatusCreateWithoutGuestInput.stub(_res);
}

class Input$WhatsappStatusWhereInput {
  factory Input$WhatsappStatusWhereInput({
    List<Input$WhatsappStatusWhereInput>? AND,
    List<Input$WhatsappStatusWhereInput>? OR,
    List<Input$WhatsappStatusWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      Input$WhatsappStatusWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$WhatsappStatusWhereInput._(this._$data);

  factory Input$WhatsappStatusWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = l$refId == null
          ? null
          : Input$StringFilter.fromJson((l$refId as Map<String, dynamic>));
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = l$messageId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$messageId as Map<String, dynamic>));
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = l$message == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$message as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$WhatsappStatusWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappStatusWhereInput>? get AND =>
      (_$data['AND'] as List<Input$WhatsappStatusWhereInput>?);
  List<Input$WhatsappStatusWhereInput>? get OR =>
      (_$data['OR'] as List<Input$WhatsappStatusWhereInput>?);
  List<Input$WhatsappStatusWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$WhatsappStatusWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$StringFilter? get refId => (_$data['refId'] as Input$StringFilter?);
  Input$StringNullableFilter? get messageId =>
      (_$data['messageId'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get message =>
      (_$data['message'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId?.toJson();
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId?.toJson();
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusWhereInput<Input$WhatsappStatusWhereInput>
      get copyWith => CopyWith$Input$WhatsappStatusWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusWhereInput<TRes> {
  factory CopyWith$Input$WhatsappStatusWhereInput(
    Input$WhatsappStatusWhereInput instance,
    TRes Function(Input$WhatsappStatusWhereInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusWhereInput;

  factory CopyWith$Input$WhatsappStatusWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusWhereInput;

  TRes call({
    List<Input$WhatsappStatusWhereInput>? AND,
    List<Input$WhatsappStatusWhereInput>? OR,
    List<Input$WhatsappStatusWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  });
  TRes AND(
      Iterable<Input$WhatsappStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereInput<
                      Input$WhatsappStatusWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$WhatsappStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereInput<
                      Input$WhatsappStatusWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$WhatsappStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereInput<
                      Input$WhatsappStatusWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get refId;
  CopyWith$Input$StringNullableFilter<TRes> get messageId;
  CopyWith$Input$StringNullableFilter<TRes> get message;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
}

class _CopyWithImpl$Input$WhatsappStatusWhereInput<TRes>
    implements CopyWith$Input$WhatsappStatusWhereInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusWhereInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusWhereInput _instance;

  final TRes Function(Input$WhatsappStatusWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappStatusWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$WhatsappStatusWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$WhatsappStatusWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$WhatsappStatusWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (refId != _undefined) 'refId': (refId as Input$StringFilter?),
        if (messageId != _undefined)
          'messageId': (messageId as Input$StringNullableFilter?),
        if (message != _undefined)
          'message': (message as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$WhatsappStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereInput<
                          Input$WhatsappStatusWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$WhatsappStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$WhatsappStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereInput<
                          Input$WhatsappStatusWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$WhatsappStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$WhatsappStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereInput<
                          Input$WhatsappStatusWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$WhatsappStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get refId {
    final local$refId = _instance.refId;
    return local$refId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$refId, (e) => call(refId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get messageId {
    final local$messageId = _instance.messageId;
    return local$messageId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$messageId, (e) => call(messageId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get message {
    final local$message = _instance.message;
    return local$message == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$message, (e) => call(message: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusWhereInput<TRes>
    implements CopyWith$Input$WhatsappStatusWhereInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusWhereInput(this._res);

  TRes _res;

  call({
    List<Input$WhatsappStatusWhereInput>? AND,
    List<Input$WhatsappStatusWhereInput>? OR,
    List<Input$WhatsappStatusWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get refId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get messageId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get message =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
}

class Input$WhatsappStatusWhereUniqueInput {
  factory Input$WhatsappStatusWhereUniqueInput({
    int? id,
    List<Input$WhatsappStatusWhereInput>? AND,
    List<Input$WhatsappStatusWhereInput>? OR,
    List<Input$WhatsappStatusWhereInput>? NOT,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      Input$WhatsappStatusWhereUniqueInput._({
        if (id != null) r'id': id,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (refId != null) r'refId': refId,
        if (messageId != null) r'messageId': messageId,
        if (message != null) r'message': message,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$WhatsappStatusWhereUniqueInput._(this._$data);

  factory Input$WhatsappStatusWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$WhatsappStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('refId')) {
      final l$refId = data['refId'];
      result$data['refId'] = l$refId == null
          ? null
          : Input$StringFilter.fromJson((l$refId as Map<String, dynamic>));
    }
    if (data.containsKey('messageId')) {
      final l$messageId = data['messageId'];
      result$data['messageId'] = l$messageId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$messageId as Map<String, dynamic>));
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = l$message == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$message as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$WhatsappStatusWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  List<Input$WhatsappStatusWhereInput>? get AND =>
      (_$data['AND'] as List<Input$WhatsappStatusWhereInput>?);
  List<Input$WhatsappStatusWhereInput>? get OR =>
      (_$data['OR'] as List<Input$WhatsappStatusWhereInput>?);
  List<Input$WhatsappStatusWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$WhatsappStatusWhereInput>?);
  Input$StringFilter? get refId => (_$data['refId'] as Input$StringFilter?);
  Input$StringNullableFilter? get messageId =>
      (_$data['messageId'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get message =>
      (_$data['message'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('refId')) {
      final l$refId = refId;
      result$data['refId'] = l$refId?.toJson();
    }
    if (_$data.containsKey('messageId')) {
      final l$messageId = messageId;
      result$data['messageId'] = l$messageId?.toJson();
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappStatusWhereUniqueInput<
          Input$WhatsappStatusWhereUniqueInput>
      get copyWith => CopyWith$Input$WhatsappStatusWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappStatusWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (_$data.containsKey('refId') != other._$data.containsKey('refId')) {
      return false;
    }
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$messageId = messageId;
    final lOther$messageId = other.messageId;
    if (_$data.containsKey('messageId') !=
        other._$data.containsKey('messageId')) {
      return false;
    }
    if (l$messageId != lOther$messageId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$refId = refId;
    final l$messageId = messageId;
    final l$message = message;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('refId') ? l$refId : const {},
      _$data.containsKey('messageId') ? l$messageId : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> {
  factory CopyWith$Input$WhatsappStatusWhereUniqueInput(
    Input$WhatsappStatusWhereUniqueInput instance,
    TRes Function(Input$WhatsappStatusWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$WhatsappStatusWhereUniqueInput;

  factory CopyWith$Input$WhatsappStatusWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappStatusWhereUniqueInput;

  TRes call({
    int? id,
    List<Input$WhatsappStatusWhereInput>? AND,
    List<Input$WhatsappStatusWhereInput>? OR,
    List<Input$WhatsappStatusWhereInput>? NOT,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  });
  TRes AND(
      Iterable<Input$WhatsappStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereInput<
                      Input$WhatsappStatusWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$WhatsappStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereInput<
                      Input$WhatsappStatusWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$WhatsappStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappStatusWhereInput<
                      Input$WhatsappStatusWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get refId;
  CopyWith$Input$StringNullableFilter<TRes> get messageId;
  CopyWith$Input$StringNullableFilter<TRes> get message;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
}

class _CopyWithImpl$Input$WhatsappStatusWhereUniqueInput<TRes>
    implements CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$WhatsappStatusWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappStatusWhereUniqueInput _instance;

  final TRes Function(Input$WhatsappStatusWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? refId = _undefined,
    Object? messageId = _undefined,
    Object? message = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappStatusWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (AND != _undefined)
          'AND': (AND as List<Input$WhatsappStatusWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$WhatsappStatusWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$WhatsappStatusWhereInput>?),
        if (refId != _undefined) 'refId': (refId as Input$StringFilter?),
        if (messageId != _undefined)
          'messageId': (messageId as Input$StringNullableFilter?),
        if (message != _undefined)
          'message': (message as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$WhatsappStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereInput<
                          Input$WhatsappStatusWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$WhatsappStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$WhatsappStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereInput<
                          Input$WhatsappStatusWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$WhatsappStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$WhatsappStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappStatusWhereInput<
                          Input$WhatsappStatusWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$WhatsappStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$StringFilter<TRes> get refId {
    final local$refId = _instance.refId;
    return local$refId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$refId, (e) => call(refId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get messageId {
    final local$messageId = _instance.messageId;
    return local$messageId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$messageId, (e) => call(messageId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get message {
    final local$message = _instance.message;
    return local$message == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$message, (e) => call(message: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappStatusWhereUniqueInput<TRes>
    implements CopyWith$Input$WhatsappStatusWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappStatusWhereUniqueInput(this._res);

  TRes _res;

  call({
    int? id,
    List<Input$WhatsappStatusWhereInput>? AND,
    List<Input$WhatsappStatusWhereInput>? OR,
    List<Input$WhatsappStatusWhereInput>? NOT,
    Input$StringFilter? refId,
    Input$StringNullableFilter? messageId,
    Input$StringNullableFilter? message,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get refId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get messageId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get message =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
}

enum Enum$ConfirmationStatus { UNCONFIRMED, CONFIRMED, REJECTED, $unknown }

String toJson$Enum$ConfirmationStatus(Enum$ConfirmationStatus e) {
  switch (e) {
    case Enum$ConfirmationStatus.UNCONFIRMED:
      return r'UNCONFIRMED';
    case Enum$ConfirmationStatus.CONFIRMED:
      return r'CONFIRMED';
    case Enum$ConfirmationStatus.REJECTED:
      return r'REJECTED';
    case Enum$ConfirmationStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ConfirmationStatus fromJson$Enum$ConfirmationStatus(String value) {
  switch (value) {
    case r'UNCONFIRMED':
      return Enum$ConfirmationStatus.UNCONFIRMED;
    case r'CONFIRMED':
      return Enum$ConfirmationStatus.CONFIRMED;
    case r'REJECTED':
      return Enum$ConfirmationStatus.REJECTED;
    default:
      return Enum$ConfirmationStatus.$unknown;
  }
}

enum Enum$GuestScalarFieldEnum {
  id,
  source,
  invitationName,
  contactList,
  whatsapp,
  category,
  $class,
  seat,
  studio,
  showTime,
  rejectionReason,
  createdAt,
  updatedAt,
  deletedAt,
  groupMemberOfId,
  confirmationStatus,
  $unknown
}

String toJson$Enum$GuestScalarFieldEnum(Enum$GuestScalarFieldEnum e) {
  switch (e) {
    case Enum$GuestScalarFieldEnum.id:
      return r'id';
    case Enum$GuestScalarFieldEnum.source:
      return r'source';
    case Enum$GuestScalarFieldEnum.invitationName:
      return r'invitationName';
    case Enum$GuestScalarFieldEnum.contactList:
      return r'contactList';
    case Enum$GuestScalarFieldEnum.whatsapp:
      return r'whatsapp';
    case Enum$GuestScalarFieldEnum.category:
      return r'category';
    case Enum$GuestScalarFieldEnum.$class:
      return r'class';
    case Enum$GuestScalarFieldEnum.seat:
      return r'seat';
    case Enum$GuestScalarFieldEnum.studio:
      return r'studio';
    case Enum$GuestScalarFieldEnum.showTime:
      return r'showTime';
    case Enum$GuestScalarFieldEnum.rejectionReason:
      return r'rejectionReason';
    case Enum$GuestScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$GuestScalarFieldEnum.updatedAt:
      return r'updatedAt';
    case Enum$GuestScalarFieldEnum.deletedAt:
      return r'deletedAt';
    case Enum$GuestScalarFieldEnum.groupMemberOfId:
      return r'groupMemberOfId';
    case Enum$GuestScalarFieldEnum.confirmationStatus:
      return r'confirmationStatus';
    case Enum$GuestScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$GuestScalarFieldEnum fromJson$Enum$GuestScalarFieldEnum(String value) {
  switch (value) {
    case r'id':
      return Enum$GuestScalarFieldEnum.id;
    case r'source':
      return Enum$GuestScalarFieldEnum.source;
    case r'invitationName':
      return Enum$GuestScalarFieldEnum.invitationName;
    case r'contactList':
      return Enum$GuestScalarFieldEnum.contactList;
    case r'whatsapp':
      return Enum$GuestScalarFieldEnum.whatsapp;
    case r'category':
      return Enum$GuestScalarFieldEnum.category;
    case r'class':
      return Enum$GuestScalarFieldEnum.$class;
    case r'seat':
      return Enum$GuestScalarFieldEnum.seat;
    case r'studio':
      return Enum$GuestScalarFieldEnum.studio;
    case r'showTime':
      return Enum$GuestScalarFieldEnum.showTime;
    case r'rejectionReason':
      return Enum$GuestScalarFieldEnum.rejectionReason;
    case r'createdAt':
      return Enum$GuestScalarFieldEnum.createdAt;
    case r'updatedAt':
      return Enum$GuestScalarFieldEnum.updatedAt;
    case r'deletedAt':
      return Enum$GuestScalarFieldEnum.deletedAt;
    case r'groupMemberOfId':
      return Enum$GuestScalarFieldEnum.groupMemberOfId;
    case r'confirmationStatus':
      return Enum$GuestScalarFieldEnum.confirmationStatus;
    default:
      return Enum$GuestScalarFieldEnum.$unknown;
  }
}

enum Enum$InvitationImageScalarFieldEnum {
  id,
  path,
  createdAt,
  guestId,
  $unknown
}

String toJson$Enum$InvitationImageScalarFieldEnum(
    Enum$InvitationImageScalarFieldEnum e) {
  switch (e) {
    case Enum$InvitationImageScalarFieldEnum.id:
      return r'id';
    case Enum$InvitationImageScalarFieldEnum.path:
      return r'path';
    case Enum$InvitationImageScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$InvitationImageScalarFieldEnum.guestId:
      return r'guestId';
    case Enum$InvitationImageScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$InvitationImageScalarFieldEnum
    fromJson$Enum$InvitationImageScalarFieldEnum(String value) {
  switch (value) {
    case r'id':
      return Enum$InvitationImageScalarFieldEnum.id;
    case r'path':
      return Enum$InvitationImageScalarFieldEnum.path;
    case r'createdAt':
      return Enum$InvitationImageScalarFieldEnum.createdAt;
    case r'guestId':
      return Enum$InvitationImageScalarFieldEnum.guestId;
    default:
      return Enum$InvitationImageScalarFieldEnum.$unknown;
  }
}

enum Enum$NullsOrder { first, last, $unknown }

String toJson$Enum$NullsOrder(Enum$NullsOrder e) {
  switch (e) {
    case Enum$NullsOrder.first:
      return r'first';
    case Enum$NullsOrder.last:
      return r'last';
    case Enum$NullsOrder.$unknown:
      return r'$unknown';
  }
}

Enum$NullsOrder fromJson$Enum$NullsOrder(String value) {
  switch (value) {
    case r'first':
      return Enum$NullsOrder.first;
    case r'last':
      return Enum$NullsOrder.last;
    default:
      return Enum$NullsOrder.$unknown;
  }
}

enum Enum$QrCodeScalarFieldEnum {
  id,
  path,
  scannedAt,
  createdAt,
  raceConditionValue,
  guestId,
  scannedByUserId,
  $unknown
}

String toJson$Enum$QrCodeScalarFieldEnum(Enum$QrCodeScalarFieldEnum e) {
  switch (e) {
    case Enum$QrCodeScalarFieldEnum.id:
      return r'id';
    case Enum$QrCodeScalarFieldEnum.path:
      return r'path';
    case Enum$QrCodeScalarFieldEnum.scannedAt:
      return r'scannedAt';
    case Enum$QrCodeScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$QrCodeScalarFieldEnum.raceConditionValue:
      return r'raceConditionValue';
    case Enum$QrCodeScalarFieldEnum.guestId:
      return r'guestId';
    case Enum$QrCodeScalarFieldEnum.scannedByUserId:
      return r'scannedByUserId';
    case Enum$QrCodeScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$QrCodeScalarFieldEnum fromJson$Enum$QrCodeScalarFieldEnum(String value) {
  switch (value) {
    case r'id':
      return Enum$QrCodeScalarFieldEnum.id;
    case r'path':
      return Enum$QrCodeScalarFieldEnum.path;
    case r'scannedAt':
      return Enum$QrCodeScalarFieldEnum.scannedAt;
    case r'createdAt':
      return Enum$QrCodeScalarFieldEnum.createdAt;
    case r'raceConditionValue':
      return Enum$QrCodeScalarFieldEnum.raceConditionValue;
    case r'guestId':
      return Enum$QrCodeScalarFieldEnum.guestId;
    case r'scannedByUserId':
      return Enum$QrCodeScalarFieldEnum.scannedByUserId;
    default:
      return Enum$QrCodeScalarFieldEnum.$unknown;
  }
}

enum Enum$QueueStatus { QUEUE, SENT, DELIVERED, READ, ABORT, FAILED, $unknown }

String toJson$Enum$QueueStatus(Enum$QueueStatus e) {
  switch (e) {
    case Enum$QueueStatus.QUEUE:
      return r'QUEUE';
    case Enum$QueueStatus.SENT:
      return r'SENT';
    case Enum$QueueStatus.DELIVERED:
      return r'DELIVERED';
    case Enum$QueueStatus.READ:
      return r'READ';
    case Enum$QueueStatus.ABORT:
      return r'ABORT';
    case Enum$QueueStatus.FAILED:
      return r'FAILED';
    case Enum$QueueStatus.$unknown:
      return r'$unknown';
  }
}

Enum$QueueStatus fromJson$Enum$QueueStatus(String value) {
  switch (value) {
    case r'QUEUE':
      return Enum$QueueStatus.QUEUE;
    case r'SENT':
      return Enum$QueueStatus.SENT;
    case r'DELIVERED':
      return Enum$QueueStatus.DELIVERED;
    case r'READ':
      return Enum$QueueStatus.READ;
    case r'ABORT':
      return Enum$QueueStatus.ABORT;
    case r'FAILED':
      return Enum$QueueStatus.FAILED;
    default:
      return Enum$QueueStatus.$unknown;
  }
}

enum Enum$SortOrder { asc, desc, $unknown }

String toJson$Enum$SortOrder(Enum$SortOrder e) {
  switch (e) {
    case Enum$SortOrder.asc:
      return r'asc';
    case Enum$SortOrder.desc:
      return r'desc';
    case Enum$SortOrder.$unknown:
      return r'$unknown';
  }
}

Enum$SortOrder fromJson$Enum$SortOrder(String value) {
  switch (value) {
    case r'asc':
      return Enum$SortOrder.asc;
    case r'desc':
      return Enum$SortOrder.desc;
    default:
      return Enum$SortOrder.$unknown;
  }
}

enum Enum$UserRole { ADMIN, SUPERUSER, GUEST, $unknown }

String toJson$Enum$UserRole(Enum$UserRole e) {
  switch (e) {
    case Enum$UserRole.ADMIN:
      return r'ADMIN';
    case Enum$UserRole.SUPERUSER:
      return r'SUPERUSER';
    case Enum$UserRole.GUEST:
      return r'GUEST';
    case Enum$UserRole.$unknown:
      return r'$unknown';
  }
}

Enum$UserRole fromJson$Enum$UserRole(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$UserRole.ADMIN;
    case r'SUPERUSER':
      return Enum$UserRole.SUPERUSER;
    case r'GUEST':
      return Enum$UserRole.GUEST;
    default:
      return Enum$UserRole.$unknown;
  }
}

enum Enum$UserScalarFieldEnum {
  id,
  fullName,
  email,
  password,
  createdAt,
  updatedAt,
  deletedAt,
  role,
  $unknown
}

String toJson$Enum$UserScalarFieldEnum(Enum$UserScalarFieldEnum e) {
  switch (e) {
    case Enum$UserScalarFieldEnum.id:
      return r'id';
    case Enum$UserScalarFieldEnum.fullName:
      return r'fullName';
    case Enum$UserScalarFieldEnum.email:
      return r'email';
    case Enum$UserScalarFieldEnum.password:
      return r'password';
    case Enum$UserScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$UserScalarFieldEnum.updatedAt:
      return r'updatedAt';
    case Enum$UserScalarFieldEnum.deletedAt:
      return r'deletedAt';
    case Enum$UserScalarFieldEnum.role:
      return r'role';
    case Enum$UserScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$UserScalarFieldEnum fromJson$Enum$UserScalarFieldEnum(String value) {
  switch (value) {
    case r'id':
      return Enum$UserScalarFieldEnum.id;
    case r'fullName':
      return Enum$UserScalarFieldEnum.fullName;
    case r'email':
      return Enum$UserScalarFieldEnum.email;
    case r'password':
      return Enum$UserScalarFieldEnum.password;
    case r'createdAt':
      return Enum$UserScalarFieldEnum.createdAt;
    case r'updatedAt':
      return Enum$UserScalarFieldEnum.updatedAt;
    case r'deletedAt':
      return Enum$UserScalarFieldEnum.deletedAt;
    case r'role':
      return Enum$UserScalarFieldEnum.role;
    default:
      return Enum$UserScalarFieldEnum.$unknown;
  }
}

enum Enum$WhatsappStatusScalarFieldEnum {
  id,
  refId,
  messageId,
  message,
  createdAt,
  status,
  guestId,
  $unknown
}

String toJson$Enum$WhatsappStatusScalarFieldEnum(
    Enum$WhatsappStatusScalarFieldEnum e) {
  switch (e) {
    case Enum$WhatsappStatusScalarFieldEnum.id:
      return r'id';
    case Enum$WhatsappStatusScalarFieldEnum.refId:
      return r'refId';
    case Enum$WhatsappStatusScalarFieldEnum.messageId:
      return r'messageId';
    case Enum$WhatsappStatusScalarFieldEnum.message:
      return r'message';
    case Enum$WhatsappStatusScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$WhatsappStatusScalarFieldEnum.status:
      return r'status';
    case Enum$WhatsappStatusScalarFieldEnum.guestId:
      return r'guestId';
    case Enum$WhatsappStatusScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$WhatsappStatusScalarFieldEnum fromJson$Enum$WhatsappStatusScalarFieldEnum(
    String value) {
  switch (value) {
    case r'id':
      return Enum$WhatsappStatusScalarFieldEnum.id;
    case r'refId':
      return Enum$WhatsappStatusScalarFieldEnum.refId;
    case r'messageId':
      return Enum$WhatsappStatusScalarFieldEnum.messageId;
    case r'message':
      return Enum$WhatsappStatusScalarFieldEnum.message;
    case r'createdAt':
      return Enum$WhatsappStatusScalarFieldEnum.createdAt;
    case r'status':
      return Enum$WhatsappStatusScalarFieldEnum.status;
    case r'guestId':
      return Enum$WhatsappStatusScalarFieldEnum.guestId;
    default:
      return Enum$WhatsappStatusScalarFieldEnum.$unknown;
  }
}

enum Enum$__TypeKind {
  SCALAR,
  OBJECT,
  INTERFACE,
  UNION,
  ENUM,
  INPUT_OBJECT,
  LIST,
  NON_NULL,
  $unknown
}

String toJson$Enum$__TypeKind(Enum$__TypeKind e) {
  switch (e) {
    case Enum$__TypeKind.SCALAR:
      return r'SCALAR';
    case Enum$__TypeKind.OBJECT:
      return r'OBJECT';
    case Enum$__TypeKind.INTERFACE:
      return r'INTERFACE';
    case Enum$__TypeKind.UNION:
      return r'UNION';
    case Enum$__TypeKind.ENUM:
      return r'ENUM';
    case Enum$__TypeKind.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__TypeKind.LIST:
      return r'LIST';
    case Enum$__TypeKind.NON_NULL:
      return r'NON_NULL';
    case Enum$__TypeKind.$unknown:
      return r'$unknown';
  }
}

Enum$__TypeKind fromJson$Enum$__TypeKind(String value) {
  switch (value) {
    case r'SCALAR':
      return Enum$__TypeKind.SCALAR;
    case r'OBJECT':
      return Enum$__TypeKind.OBJECT;
    case r'INTERFACE':
      return Enum$__TypeKind.INTERFACE;
    case r'UNION':
      return Enum$__TypeKind.UNION;
    case r'ENUM':
      return Enum$__TypeKind.ENUM;
    case r'INPUT_OBJECT':
      return Enum$__TypeKind.INPUT_OBJECT;
    case r'LIST':
      return Enum$__TypeKind.LIST;
    case r'NON_NULL':
      return Enum$__TypeKind.NON_NULL;
    default:
      return Enum$__TypeKind.$unknown;
  }
}

enum Enum$__DirectiveLocation {
  QUERY,
  MUTATION,
  SUBSCRIPTION,
  FIELD,
  FRAGMENT_DEFINITION,
  FRAGMENT_SPREAD,
  INLINE_FRAGMENT,
  VARIABLE_DEFINITION,
  SCHEMA,
  SCALAR,
  OBJECT,
  FIELD_DEFINITION,
  ARGUMENT_DEFINITION,
  INTERFACE,
  UNION,
  ENUM,
  ENUM_VALUE,
  INPUT_OBJECT,
  INPUT_FIELD_DEFINITION,
  $unknown
}

String toJson$Enum$__DirectiveLocation(Enum$__DirectiveLocation e) {
  switch (e) {
    case Enum$__DirectiveLocation.QUERY:
      return r'QUERY';
    case Enum$__DirectiveLocation.MUTATION:
      return r'MUTATION';
    case Enum$__DirectiveLocation.SUBSCRIPTION:
      return r'SUBSCRIPTION';
    case Enum$__DirectiveLocation.FIELD:
      return r'FIELD';
    case Enum$__DirectiveLocation.FRAGMENT_DEFINITION:
      return r'FRAGMENT_DEFINITION';
    case Enum$__DirectiveLocation.FRAGMENT_SPREAD:
      return r'FRAGMENT_SPREAD';
    case Enum$__DirectiveLocation.INLINE_FRAGMENT:
      return r'INLINE_FRAGMENT';
    case Enum$__DirectiveLocation.VARIABLE_DEFINITION:
      return r'VARIABLE_DEFINITION';
    case Enum$__DirectiveLocation.SCHEMA:
      return r'SCHEMA';
    case Enum$__DirectiveLocation.SCALAR:
      return r'SCALAR';
    case Enum$__DirectiveLocation.OBJECT:
      return r'OBJECT';
    case Enum$__DirectiveLocation.FIELD_DEFINITION:
      return r'FIELD_DEFINITION';
    case Enum$__DirectiveLocation.ARGUMENT_DEFINITION:
      return r'ARGUMENT_DEFINITION';
    case Enum$__DirectiveLocation.INTERFACE:
      return r'INTERFACE';
    case Enum$__DirectiveLocation.UNION:
      return r'UNION';
    case Enum$__DirectiveLocation.ENUM:
      return r'ENUM';
    case Enum$__DirectiveLocation.ENUM_VALUE:
      return r'ENUM_VALUE';
    case Enum$__DirectiveLocation.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION:
      return r'INPUT_FIELD_DEFINITION';
    case Enum$__DirectiveLocation.$unknown:
      return r'$unknown';
  }
}

Enum$__DirectiveLocation fromJson$Enum$__DirectiveLocation(String value) {
  switch (value) {
    case r'QUERY':
      return Enum$__DirectiveLocation.QUERY;
    case r'MUTATION':
      return Enum$__DirectiveLocation.MUTATION;
    case r'SUBSCRIPTION':
      return Enum$__DirectiveLocation.SUBSCRIPTION;
    case r'FIELD':
      return Enum$__DirectiveLocation.FIELD;
    case r'FRAGMENT_DEFINITION':
      return Enum$__DirectiveLocation.FRAGMENT_DEFINITION;
    case r'FRAGMENT_SPREAD':
      return Enum$__DirectiveLocation.FRAGMENT_SPREAD;
    case r'INLINE_FRAGMENT':
      return Enum$__DirectiveLocation.INLINE_FRAGMENT;
    case r'VARIABLE_DEFINITION':
      return Enum$__DirectiveLocation.VARIABLE_DEFINITION;
    case r'SCHEMA':
      return Enum$__DirectiveLocation.SCHEMA;
    case r'SCALAR':
      return Enum$__DirectiveLocation.SCALAR;
    case r'OBJECT':
      return Enum$__DirectiveLocation.OBJECT;
    case r'FIELD_DEFINITION':
      return Enum$__DirectiveLocation.FIELD_DEFINITION;
    case r'ARGUMENT_DEFINITION':
      return Enum$__DirectiveLocation.ARGUMENT_DEFINITION;
    case r'INTERFACE':
      return Enum$__DirectiveLocation.INTERFACE;
    case r'UNION':
      return Enum$__DirectiveLocation.UNION;
    case r'ENUM':
      return Enum$__DirectiveLocation.ENUM;
    case r'ENUM_VALUE':
      return Enum$__DirectiveLocation.ENUM_VALUE;
    case r'INPUT_OBJECT':
      return Enum$__DirectiveLocation.INPUT_OBJECT;
    case r'INPUT_FIELD_DEFINITION':
      return Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION;
    default:
      return Enum$__DirectiveLocation.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{};
