class Input$DateTimeFieldUpdateOperationsInput {
  factory Input$DateTimeFieldUpdateOperationsInput({String? $set}) =>
      Input$DateTimeFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$DateTimeFieldUpdateOperationsInput._(this._$data);

  factory Input$DateTimeFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$DateTimeFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<
          Input$DateTimeFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$DateTimeFieldUpdateOperationsInput(
    Input$DateTimeFieldUpdateOperationsInput instance,
    TRes Function(Input$DateTimeFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput;

  factory CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$DateTimeFieldUpdateOperationsInput _instance;

  final TRes Function(Input$DateTimeFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$DateTimeFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$DateTimeFilter {
  factory Input$DateTimeFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      Input$DateTimeFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$DateTimeFilter._(this._$data);

  factory Input$DateTimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$DateTimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFilter<Input$DateTimeFilter> get copyWith =>
      CopyWith$Input$DateTimeFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeFilter<TRes> {
  factory CopyWith$Input$DateTimeFilter(
    Input$DateTimeFilter instance,
    TRes Function(Input$DateTimeFilter) then,
  ) = _CopyWithImpl$Input$DateTimeFilter;

  factory CopyWith$Input$DateTimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  });
  CopyWith$Input$NestedDateTimeFilter<TRes> get not;
}

class _CopyWithImpl$Input$DateTimeFilter<TRes>
    implements CopyWith$Input$DateTimeFilter<TRes> {
  _CopyWithImpl$Input$DateTimeFilter(
    this._instance,
    this._then,
  );

  final Input$DateTimeFilter _instance;

  final TRes Function(Input$DateTimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$DateTimeFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined) 'not': (not as Input$NestedDateTimeFilter?),
      }));
  CopyWith$Input$NestedDateTimeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeFilter<TRes>
    implements CopyWith$Input$DateTimeFilter<TRes> {
  _CopyWithStubImpl$Input$DateTimeFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$DateTimeNullableFilter {
  factory Input$DateTimeNullableFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  }) =>
      Input$DateTimeNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$DateTimeNullableFilter._(this._$data);

  factory Input$DateTimeNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$DateTimeNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeNullableFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeNullableFilter<Input$DateTimeNullableFilter>
      get copyWith => CopyWith$Input$DateTimeNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeNullableFilter<TRes> {
  factory CopyWith$Input$DateTimeNullableFilter(
    Input$DateTimeNullableFilter instance,
    TRes Function(Input$DateTimeNullableFilter) then,
  ) = _CopyWithImpl$Input$DateTimeNullableFilter;

  factory CopyWith$Input$DateTimeNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeNullableFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  });
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$DateTimeNullableFilter<TRes>
    implements CopyWith$Input$DateTimeNullableFilter<TRes> {
  _CopyWithImpl$Input$DateTimeNullableFilter(
    this._instance,
    this._then,
  );

  final Input$DateTimeNullableFilter _instance;

  final TRes Function(Input$DateTimeNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$DateTimeNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedDateTimeNullableFilter?),
      }));
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeNullableFilter<TRes>
    implements CopyWith$Input$DateTimeNullableFilter<TRes> {
  _CopyWithStubImpl$Input$DateTimeNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeNullableFilter.stub(_res);
}

class Input$EmailQueueAvgAggregateInput {
  factory Input$EmailQueueAvgAggregateInput({bool? id}) =>
      Input$EmailQueueAvgAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$EmailQueueAvgAggregateInput._(this._$data);

  factory Input$EmailQueueAvgAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    return Input$EmailQueueAvgAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueAvgAggregateInput<Input$EmailQueueAvgAggregateInput>
      get copyWith => CopyWith$Input$EmailQueueAvgAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueAvgAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$EmailQueueAvgAggregateInput<TRes> {
  factory CopyWith$Input$EmailQueueAvgAggregateInput(
    Input$EmailQueueAvgAggregateInput instance,
    TRes Function(Input$EmailQueueAvgAggregateInput) then,
  ) = _CopyWithImpl$Input$EmailQueueAvgAggregateInput;

  factory CopyWith$Input$EmailQueueAvgAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueAvgAggregateInput;

  TRes call({bool? id});
}

class _CopyWithImpl$Input$EmailQueueAvgAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueAvgAggregateInput<TRes> {
  _CopyWithImpl$Input$EmailQueueAvgAggregateInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueAvgAggregateInput _instance;

  final TRes Function(Input$EmailQueueAvgAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$EmailQueueAvgAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueAvgAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueAvgAggregateInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueAvgAggregateInput(this._res);

  TRes _res;

  call({bool? id}) => _res;
}

class Input$EmailQueueCountAggregateInput {
  factory Input$EmailQueueCountAggregateInput({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  }) =>
      Input$EmailQueueCountAggregateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if ($_all != null) r'_all': $_all,
      });

  Input$EmailQueueCountAggregateInput._(this._$data);

  factory Input$EmailQueueCountAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$EmailQueueCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueCountAggregateInput<
          Input$EmailQueueCountAggregateInput>
      get copyWith => CopyWith$Input$EmailQueueCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueCountAggregateInput<TRes> {
  factory CopyWith$Input$EmailQueueCountAggregateInput(
    Input$EmailQueueCountAggregateInput instance,
    TRes Function(Input$EmailQueueCountAggregateInput) then,
  ) = _CopyWithImpl$Input$EmailQueueCountAggregateInput;

  factory CopyWith$Input$EmailQueueCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueCountAggregateInput;

  TRes call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$EmailQueueCountAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueCountAggregateInput<TRes> {
  _CopyWithImpl$Input$EmailQueueCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueCountAggregateInput _instance;

  final TRes Function(Input$EmailQueueCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$EmailQueueCountAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueCountAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  }) =>
      _res;
}

class Input$EmailQueueCreateInput {
  factory Input$EmailQueueCreateInput({
    String? createdAt,
    Enum$QueueStatus? status,
    required Input$GuestCreateNestedOneWithoutEmailQueueInput guest,
  }) =>
      Input$EmailQueueCreateInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        r'guest': guest,
      });

  Input$EmailQueueCreateInput._(this._$data);

  factory Input$EmailQueueCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    final l$guest = data['guest'];
    result$data['guest'] =
        Input$GuestCreateNestedOneWithoutEmailQueueInput.fromJson(
            (l$guest as Map<String, dynamic>));
    return Input$EmailQueueCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Input$GuestCreateNestedOneWithoutEmailQueueInput get guest =>
      (_$data['guest'] as Input$GuestCreateNestedOneWithoutEmailQueueInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    final l$guest = guest;
    result$data['guest'] = l$guest.toJson();
    return result$data;
  }

  CopyWith$Input$EmailQueueCreateInput<Input$EmailQueueCreateInput>
      get copyWith => CopyWith$Input$EmailQueueCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      l$guest,
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueCreateInput<TRes> {
  factory CopyWith$Input$EmailQueueCreateInput(
    Input$EmailQueueCreateInput instance,
    TRes Function(Input$EmailQueueCreateInput) then,
  ) = _CopyWithImpl$Input$EmailQueueCreateInput;

  factory CopyWith$Input$EmailQueueCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueCreateInput;

  TRes call({
    String? createdAt,
    Enum$QueueStatus? status,
    Input$GuestCreateNestedOneWithoutEmailQueueInput? guest,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput<TRes> get guest;
}

class _CopyWithImpl$Input$EmailQueueCreateInput<TRes>
    implements CopyWith$Input$EmailQueueCreateInput<TRes> {
  _CopyWithImpl$Input$EmailQueueCreateInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueCreateInput _instance;

  final TRes Function(Input$EmailQueueCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$EmailQueueCreateInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
        if (guest != _undefined && guest != null)
          'guest': (guest as Input$GuestCreateNestedOneWithoutEmailQueueInput),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput<TRes> get guest {
    final local$guest = _instance.guest;
    return CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput(
        local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueCreateInput<TRes>
    implements CopyWith$Input$EmailQueueCreateInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueCreateInput(this._res);

  TRes _res;

  call({
    String? createdAt,
    Enum$QueueStatus? status,
    Input$GuestCreateNestedOneWithoutEmailQueueInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput<TRes> get guest =>
      CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput.stub(_res);
}

class Input$EmailQueueCreateManyGuestInput {
  factory Input$EmailQueueCreateManyGuestInput({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      Input$EmailQueueCreateManyGuestInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$EmailQueueCreateManyGuestInput._(this._$data);

  factory Input$EmailQueueCreateManyGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    return Input$EmailQueueCreateManyGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueCreateManyGuestInput<
          Input$EmailQueueCreateManyGuestInput>
      get copyWith => CopyWith$Input$EmailQueueCreateManyGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueCreateManyGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueCreateManyGuestInput<TRes> {
  factory CopyWith$Input$EmailQueueCreateManyGuestInput(
    Input$EmailQueueCreateManyGuestInput instance,
    TRes Function(Input$EmailQueueCreateManyGuestInput) then,
  ) = _CopyWithImpl$Input$EmailQueueCreateManyGuestInput;

  factory CopyWith$Input$EmailQueueCreateManyGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueCreateManyGuestInput;

  TRes call({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
  });
}

class _CopyWithImpl$Input$EmailQueueCreateManyGuestInput<TRes>
    implements CopyWith$Input$EmailQueueCreateManyGuestInput<TRes> {
  _CopyWithImpl$Input$EmailQueueCreateManyGuestInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueCreateManyGuestInput _instance;

  final TRes Function(Input$EmailQueueCreateManyGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$EmailQueueCreateManyGuestInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueCreateManyGuestInput<TRes>
    implements CopyWith$Input$EmailQueueCreateManyGuestInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueCreateManyGuestInput(this._res);

  TRes _res;

  call({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      _res;
}

class Input$EmailQueueCreateManyGuestInputEnvelope {
  factory Input$EmailQueueCreateManyGuestInputEnvelope({
    required List<Input$EmailQueueCreateManyGuestInput> data,
    bool? skipDuplicates,
  }) =>
      Input$EmailQueueCreateManyGuestInputEnvelope._({
        r'data': data,
        if (skipDuplicates != null) r'skipDuplicates': skipDuplicates,
      });

  Input$EmailQueueCreateManyGuestInputEnvelope._(this._$data);

  factory Input$EmailQueueCreateManyGuestInputEnvelope.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => Input$EmailQueueCreateManyGuestInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = data['skipDuplicates'];
      result$data['skipDuplicates'] = (l$skipDuplicates as bool?);
    }
    return Input$EmailQueueCreateManyGuestInputEnvelope._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EmailQueueCreateManyGuestInput> get data =>
      (_$data['data'] as List<Input$EmailQueueCreateManyGuestInput>);
  bool? get skipDuplicates => (_$data['skipDuplicates'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = skipDuplicates;
      result$data['skipDuplicates'] = l$skipDuplicates;
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<
          Input$EmailQueueCreateManyGuestInputEnvelope>
      get copyWith => CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueCreateManyGuestInputEnvelope) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (_$data.containsKey('skipDuplicates') !=
        other._$data.containsKey('skipDuplicates')) {
      return false;
    }
    if (l$skipDuplicates != lOther$skipDuplicates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('skipDuplicates') ? l$skipDuplicates : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> {
  factory CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope(
    Input$EmailQueueCreateManyGuestInputEnvelope instance,
    TRes Function(Input$EmailQueueCreateManyGuestInputEnvelope) then,
  ) = _CopyWithImpl$Input$EmailQueueCreateManyGuestInputEnvelope;

  factory CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueCreateManyGuestInputEnvelope;

  TRes call({
    List<Input$EmailQueueCreateManyGuestInput>? data,
    bool? skipDuplicates,
  });
  TRes data(
      Iterable<Input$EmailQueueCreateManyGuestInput> Function(
              Iterable<
                  CopyWith$Input$EmailQueueCreateManyGuestInput<
                      Input$EmailQueueCreateManyGuestInput>>)
          _fn);
}

class _CopyWithImpl$Input$EmailQueueCreateManyGuestInputEnvelope<TRes>
    implements CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> {
  _CopyWithImpl$Input$EmailQueueCreateManyGuestInputEnvelope(
    this._instance,
    this._then,
  );

  final Input$EmailQueueCreateManyGuestInputEnvelope _instance;

  final TRes Function(Input$EmailQueueCreateManyGuestInputEnvelope) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? skipDuplicates = _undefined,
  }) =>
      _then(Input$EmailQueueCreateManyGuestInputEnvelope._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<Input$EmailQueueCreateManyGuestInput>),
        if (skipDuplicates != _undefined)
          'skipDuplicates': (skipDuplicates as bool?),
      }));
  TRes data(
          Iterable<Input$EmailQueueCreateManyGuestInput> Function(
                  Iterable<
                      CopyWith$Input$EmailQueueCreateManyGuestInput<
                          Input$EmailQueueCreateManyGuestInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$Input$EmailQueueCreateManyGuestInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$EmailQueueCreateManyGuestInputEnvelope<TRes>
    implements CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> {
  _CopyWithStubImpl$Input$EmailQueueCreateManyGuestInputEnvelope(this._res);

  TRes _res;

  call({
    List<Input$EmailQueueCreateManyGuestInput>? data,
    bool? skipDuplicates,
  }) =>
      _res;
  data(_fn) => _res;
}

class Input$EmailQueueCreateManyInput {
  factory Input$EmailQueueCreateManyInput({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
    required String guestId,
  }) =>
      Input$EmailQueueCreateManyInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        r'guestId': guestId,
      });

  Input$EmailQueueCreateManyInput._(this._$data);

  factory Input$EmailQueueCreateManyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    final l$guestId = data['guestId'];
    result$data['guestId'] = (l$guestId as String);
    return Input$EmailQueueCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  String get guestId => (_$data['guestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    final l$guestId = guestId;
    result$data['guestId'] = l$guestId;
    return result$data;
  }

  CopyWith$Input$EmailQueueCreateManyInput<Input$EmailQueueCreateManyInput>
      get copyWith => CopyWith$Input$EmailQueueCreateManyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      l$guestId,
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueCreateManyInput<TRes> {
  factory CopyWith$Input$EmailQueueCreateManyInput(
    Input$EmailQueueCreateManyInput instance,
    TRes Function(Input$EmailQueueCreateManyInput) then,
  ) = _CopyWithImpl$Input$EmailQueueCreateManyInput;

  factory CopyWith$Input$EmailQueueCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueCreateManyInput;

  TRes call({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
    String? guestId,
  });
}

class _CopyWithImpl$Input$EmailQueueCreateManyInput<TRes>
    implements CopyWith$Input$EmailQueueCreateManyInput<TRes> {
  _CopyWithImpl$Input$EmailQueueCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueCreateManyInput _instance;

  final TRes Function(Input$EmailQueueCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$EmailQueueCreateManyInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
        if (guestId != _undefined && guestId != null)
          'guestId': (guestId as String),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueCreateManyInput<TRes>
    implements CopyWith$Input$EmailQueueCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueCreateManyInput(this._res);

  TRes _res;

  call({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
    String? guestId,
  }) =>
      _res;
}

class Input$EmailQueueCreateNestedManyWithoutGuestInput {
  factory Input$EmailQueueCreateNestedManyWithoutGuestInput({
    List<Input$EmailQueueCreateWithoutGuestInput>? create,
    List<Input$EmailQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$EmailQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$EmailQueueWhereUniqueInput>? connect,
  }) =>
      Input$EmailQueueCreateNestedManyWithoutGuestInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (createMany != null) r'createMany': createMany,
        if (connect != null) r'connect': connect,
      });

  Input$EmailQueueCreateNestedManyWithoutGuestInput._(this._$data);

  factory Input$EmailQueueCreateNestedManyWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$EmailQueueCreateWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueCreateOrConnectWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$EmailQueueCreateManyGuestInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$EmailQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$EmailQueueCreateNestedManyWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EmailQueueCreateWithoutGuestInput>? get create =>
      (_$data['create'] as List<Input$EmailQueueCreateWithoutGuestInput>?);
  List<Input$EmailQueueCreateOrConnectWithoutGuestInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$EmailQueueCreateOrConnectWithoutGuestInput>?);
  Input$EmailQueueCreateManyGuestInputEnvelope? get createMany =>
      (_$data['createMany'] as Input$EmailQueueCreateManyGuestInputEnvelope?);
  List<Input$EmailQueueWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$EmailQueueWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<
          Input$EmailQueueCreateNestedManyWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueCreateNestedManyWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput(
    Input$EmailQueueCreateNestedManyWithoutGuestInput instance,
    TRes Function(Input$EmailQueueCreateNestedManyWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$EmailQueueCreateNestedManyWithoutGuestInput;

  factory CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EmailQueueCreateNestedManyWithoutGuestInput;

  TRes call({
    List<Input$EmailQueueCreateWithoutGuestInput>? create,
    List<Input$EmailQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$EmailQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$EmailQueueWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$EmailQueueCreateWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueCreateWithoutGuestInput<
                      Input$EmailQueueCreateWithoutGuestInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$EmailQueueCreateOrConnectWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput<
                      Input$EmailQueueCreateOrConnectWithoutGuestInput>>?)
          _fn);
  CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> get createMany;
  TRes connect(
      Iterable<Input$EmailQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereUniqueInput<
                      Input$EmailQueueWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
    implements
        CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$EmailQueueCreateNestedManyWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueCreateNestedManyWithoutGuestInput _instance;

  final TRes Function(Input$EmailQueueCreateNestedManyWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? createMany = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$EmailQueueCreateNestedManyWithoutGuestInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$EmailQueueCreateWithoutGuestInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$EmailQueueCreateOrConnectWithoutGuestInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$EmailQueueCreateManyGuestInputEnvelope?),
        if (connect != _undefined)
          'connect': (connect as List<Input$EmailQueueWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$EmailQueueCreateWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueCreateWithoutGuestInput<
                          Input$EmailQueueCreateWithoutGuestInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$EmailQueueCreateWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$EmailQueueCreateOrConnectWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput<
                          Input$EmailQueueCreateOrConnectWithoutGuestInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes connect(
          Iterable<Input$EmailQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereUniqueInput<
                          Input$EmailQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$EmailQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
    implements
        CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueCreateNestedManyWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    List<Input$EmailQueueCreateWithoutGuestInput>? create,
    List<Input$EmailQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$EmailQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$EmailQueueWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> get createMany =>
      CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope.stub(_res);
  connect(_fn) => _res;
}

class Input$EmailQueueCreateOrConnectWithoutGuestInput {
  factory Input$EmailQueueCreateOrConnectWithoutGuestInput({
    required Input$EmailQueueWhereUniqueInput where,
    required Input$EmailQueueCreateWithoutGuestInput create,
  }) =>
      Input$EmailQueueCreateOrConnectWithoutGuestInput._({
        r'where': where,
        r'create': create,
      });

  Input$EmailQueueCreateOrConnectWithoutGuestInput._(this._$data);

  factory Input$EmailQueueCreateOrConnectWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$EmailQueueWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$EmailQueueCreateWithoutGuestInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$EmailQueueCreateOrConnectWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$EmailQueueWhereUniqueInput get where =>
      (_$data['where'] as Input$EmailQueueWhereUniqueInput);
  Input$EmailQueueCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$EmailQueueCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput<
          Input$EmailQueueCreateOrConnectWithoutGuestInput>
      get copyWith => CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueCreateOrConnectWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput<TRes> {
  factory CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput(
    Input$EmailQueueCreateOrConnectWithoutGuestInput instance,
    TRes Function(Input$EmailQueueCreateOrConnectWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$EmailQueueCreateOrConnectWithoutGuestInput;

  factory CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EmailQueueCreateOrConnectWithoutGuestInput;

  TRes call({
    Input$EmailQueueWhereUniqueInput? where,
    Input$EmailQueueCreateWithoutGuestInput? create,
  });
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where;
  CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$EmailQueueCreateOrConnectWithoutGuestInput<TRes>
    implements CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$EmailQueueCreateOrConnectWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueCreateOrConnectWithoutGuestInput _instance;

  final TRes Function(Input$EmailQueueCreateOrConnectWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$EmailQueueCreateOrConnectWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$EmailQueueWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$EmailQueueCreateWithoutGuestInput),
      }));
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$EmailQueueWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$EmailQueueCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueCreateOrConnectWithoutGuestInput<TRes>
    implements CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueCreateOrConnectWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$EmailQueueWhereUniqueInput? where,
    Input$EmailQueueCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where =>
      CopyWith$Input$EmailQueueWhereUniqueInput.stub(_res);
  CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$EmailQueueCreateWithoutGuestInput.stub(_res);
}

class Input$EmailQueueCreateWithoutGuestInput {
  factory Input$EmailQueueCreateWithoutGuestInput({
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      Input$EmailQueueCreateWithoutGuestInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$EmailQueueCreateWithoutGuestInput._(this._$data);

  factory Input$EmailQueueCreateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    return Input$EmailQueueCreateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueCreateWithoutGuestInput<
          Input$EmailQueueCreateWithoutGuestInput>
      get copyWith => CopyWith$Input$EmailQueueCreateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueCreateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> {
  factory CopyWith$Input$EmailQueueCreateWithoutGuestInput(
    Input$EmailQueueCreateWithoutGuestInput instance,
    TRes Function(Input$EmailQueueCreateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$EmailQueueCreateWithoutGuestInput;

  factory CopyWith$Input$EmailQueueCreateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueCreateWithoutGuestInput;

  TRes call({
    String? createdAt,
    Enum$QueueStatus? status,
  });
}

class _CopyWithImpl$Input$EmailQueueCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$EmailQueueCreateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueCreateWithoutGuestInput _instance;

  final TRes Function(Input$EmailQueueCreateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$EmailQueueCreateWithoutGuestInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueCreateWithoutGuestInput(this._res);

  TRes _res;

  call({
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      _res;
}

class Input$EmailQueueListRelationFilter {
  factory Input$EmailQueueListRelationFilter({
    Input$EmailQueueWhereInput? every,
    Input$EmailQueueWhereInput? some,
    Input$EmailQueueWhereInput? none,
  }) =>
      Input$EmailQueueListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$EmailQueueListRelationFilter._(this._$data);

  factory Input$EmailQueueListRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$EmailQueueWhereInput.fromJson(
              (l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$EmailQueueWhereInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$EmailQueueWhereInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    return Input$EmailQueueListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$EmailQueueWhereInput? get every =>
      (_$data['every'] as Input$EmailQueueWhereInput?);
  Input$EmailQueueWhereInput? get some =>
      (_$data['some'] as Input$EmailQueueWhereInput?);
  Input$EmailQueueWhereInput? get none =>
      (_$data['none'] as Input$EmailQueueWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueListRelationFilter<
          Input$EmailQueueListRelationFilter>
      get copyWith => CopyWith$Input$EmailQueueListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueListRelationFilter<TRes> {
  factory CopyWith$Input$EmailQueueListRelationFilter(
    Input$EmailQueueListRelationFilter instance,
    TRes Function(Input$EmailQueueListRelationFilter) then,
  ) = _CopyWithImpl$Input$EmailQueueListRelationFilter;

  factory CopyWith$Input$EmailQueueListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueListRelationFilter;

  TRes call({
    Input$EmailQueueWhereInput? every,
    Input$EmailQueueWhereInput? some,
    Input$EmailQueueWhereInput? none,
  });
  CopyWith$Input$EmailQueueWhereInput<TRes> get every;
  CopyWith$Input$EmailQueueWhereInput<TRes> get some;
  CopyWith$Input$EmailQueueWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$EmailQueueListRelationFilter<TRes>
    implements CopyWith$Input$EmailQueueListRelationFilter<TRes> {
  _CopyWithImpl$Input$EmailQueueListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$EmailQueueListRelationFilter _instance;

  final TRes Function(Input$EmailQueueListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$EmailQueueListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined)
          'every': (every as Input$EmailQueueWhereInput?),
        if (some != _undefined) 'some': (some as Input$EmailQueueWhereInput?),
        if (none != _undefined) 'none': (none as Input$EmailQueueWhereInput?),
      }));
  CopyWith$Input$EmailQueueWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$EmailQueueWhereInput.stub(_then(_instance))
        : CopyWith$Input$EmailQueueWhereInput(
            local$every, (e) => call(every: e));
  }

  CopyWith$Input$EmailQueueWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$EmailQueueWhereInput.stub(_then(_instance))
        : CopyWith$Input$EmailQueueWhereInput(local$some, (e) => call(some: e));
  }

  CopyWith$Input$EmailQueueWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$EmailQueueWhereInput.stub(_then(_instance))
        : CopyWith$Input$EmailQueueWhereInput(local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueListRelationFilter<TRes>
    implements CopyWith$Input$EmailQueueListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$EmailQueueListRelationFilter(this._res);

  TRes _res;

  call({
    Input$EmailQueueWhereInput? every,
    Input$EmailQueueWhereInput? some,
    Input$EmailQueueWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$EmailQueueWhereInput<TRes> get every =>
      CopyWith$Input$EmailQueueWhereInput.stub(_res);
  CopyWith$Input$EmailQueueWhereInput<TRes> get some =>
      CopyWith$Input$EmailQueueWhereInput.stub(_res);
  CopyWith$Input$EmailQueueWhereInput<TRes> get none =>
      CopyWith$Input$EmailQueueWhereInput.stub(_res);
}

class Input$EmailQueueMaxAggregateInput {
  factory Input$EmailQueueMaxAggregateInput({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      Input$EmailQueueMaxAggregateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$EmailQueueMaxAggregateInput._(this._$data);

  factory Input$EmailQueueMaxAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    return Input$EmailQueueMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueMaxAggregateInput<Input$EmailQueueMaxAggregateInput>
      get copyWith => CopyWith$Input$EmailQueueMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueMaxAggregateInput<TRes> {
  factory CopyWith$Input$EmailQueueMaxAggregateInput(
    Input$EmailQueueMaxAggregateInput instance,
    TRes Function(Input$EmailQueueMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$EmailQueueMaxAggregateInput;

  factory CopyWith$Input$EmailQueueMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueMaxAggregateInput;

  TRes call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  });
}

class _CopyWithImpl$Input$EmailQueueMaxAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$EmailQueueMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueMaxAggregateInput _instance;

  final TRes Function(Input$EmailQueueMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$EmailQueueMaxAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueMaxAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      _res;
}

class Input$EmailQueueMinAggregateInput {
  factory Input$EmailQueueMinAggregateInput({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      Input$EmailQueueMinAggregateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$EmailQueueMinAggregateInput._(this._$data);

  factory Input$EmailQueueMinAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    return Input$EmailQueueMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueMinAggregateInput<Input$EmailQueueMinAggregateInput>
      get copyWith => CopyWith$Input$EmailQueueMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueMinAggregateInput<TRes> {
  factory CopyWith$Input$EmailQueueMinAggregateInput(
    Input$EmailQueueMinAggregateInput instance,
    TRes Function(Input$EmailQueueMinAggregateInput) then,
  ) = _CopyWithImpl$Input$EmailQueueMinAggregateInput;

  factory CopyWith$Input$EmailQueueMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueMinAggregateInput;

  TRes call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  });
}

class _CopyWithImpl$Input$EmailQueueMinAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueMinAggregateInput<TRes> {
  _CopyWithImpl$Input$EmailQueueMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueMinAggregateInput _instance;

  final TRes Function(Input$EmailQueueMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$EmailQueueMinAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueMinAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      _res;
}

class Input$EmailQueueOrderByRelationAggregateInput {
  factory Input$EmailQueueOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$EmailQueueOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$EmailQueueOrderByRelationAggregateInput._(this._$data);

  factory Input$EmailQueueOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$EmailQueueOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueOrderByRelationAggregateInput<
          Input$EmailQueueOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$EmailQueueOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$EmailQueueOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$EmailQueueOrderByRelationAggregateInput(
    Input$EmailQueueOrderByRelationAggregateInput instance,
    TRes Function(Input$EmailQueueOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$EmailQueueOrderByRelationAggregateInput;

  factory CopyWith$Input$EmailQueueOrderByRelationAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EmailQueueOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$EmailQueueOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$EmailQueueOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueOrderByRelationAggregateInput _instance;

  final TRes Function(Input$EmailQueueOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$EmailQueueOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$EmailQueueOrderByWithRelationInput {
  factory Input$EmailQueueOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  }) =>
      Input$EmailQueueOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$EmailQueueOrderByWithRelationInput._(this._$data);

  factory Input$EmailQueueOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortOrder((l$status as String));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : fromJson$Enum$SortOrder((l$guestId as String));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestOrderByWithRelationInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$EmailQueueOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);
  Enum$SortOrder? get status => (_$data['status'] as Enum$SortOrder?);
  Enum$SortOrder? get guestId => (_$data['guestId'] as Enum$SortOrder?);
  Input$GuestOrderByWithRelationInput? get guest =>
      (_$data['guest'] as Input$GuestOrderByWithRelationInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$SortOrder(l$status);
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] =
          l$guestId == null ? null : toJson$Enum$SortOrder(l$guestId);
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueOrderByWithRelationInput<
          Input$EmailQueueOrderByWithRelationInput>
      get copyWith => CopyWith$Input$EmailQueueOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$EmailQueueOrderByWithRelationInput(
    Input$EmailQueueOrderByWithRelationInput instance,
    TRes Function(Input$EmailQueueOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$EmailQueueOrderByWithRelationInput;

  factory CopyWith$Input$EmailQueueOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  });
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest;
}

class _CopyWithImpl$Input$EmailQueueOrderByWithRelationInput<TRes>
    implements CopyWith$Input$EmailQueueOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$EmailQueueOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueOrderByWithRelationInput _instance;

  final TRes Function(Input$EmailQueueOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$EmailQueueOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (status != _undefined) 'status': (status as Enum$SortOrder?),
        if (guestId != _undefined) 'guestId': (guestId as Enum$SortOrder?),
        if (guest != _undefined)
          'guest': (guest as Input$GuestOrderByWithRelationInput?),
      }));
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$GuestOrderByWithRelationInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueOrderByWithRelationInput<TRes>
    implements CopyWith$Input$EmailQueueOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest =>
      CopyWith$Input$GuestOrderByWithRelationInput.stub(_res);
}

class Input$EmailQueueScalarWhereInput {
  factory Input$EmailQueueScalarWhereInput({
    List<Input$EmailQueueScalarWhereInput>? AND,
    List<Input$EmailQueueScalarWhereInput>? OR,
    List<Input$EmailQueueScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  }) =>
      Input$EmailQueueScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$EmailQueueScalarWhereInput._(this._$data);

  factory Input$EmailQueueScalarWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$EmailQueueScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$EmailQueueScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$EmailQueueScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    return Input$EmailQueueScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EmailQueueScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$EmailQueueScalarWhereInput>?);
  List<Input$EmailQueueScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$EmailQueueScalarWhereInput>?);
  List<Input$EmailQueueScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$EmailQueueScalarWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueScalarWhereInput<Input$EmailQueueScalarWhereInput>
      get copyWith => CopyWith$Input$EmailQueueScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueScalarWhereInput<TRes> {
  factory CopyWith$Input$EmailQueueScalarWhereInput(
    Input$EmailQueueScalarWhereInput instance,
    TRes Function(Input$EmailQueueScalarWhereInput) then,
  ) = _CopyWithImpl$Input$EmailQueueScalarWhereInput;

  factory CopyWith$Input$EmailQueueScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueScalarWhereInput;

  TRes call({
    List<Input$EmailQueueScalarWhereInput>? AND,
    List<Input$EmailQueueScalarWhereInput>? OR,
    List<Input$EmailQueueScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  });
  TRes AND(
      Iterable<Input$EmailQueueScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueScalarWhereInput<
                      Input$EmailQueueScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$EmailQueueScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueScalarWhereInput<
                      Input$EmailQueueScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$EmailQueueScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueScalarWhereInput<
                      Input$EmailQueueScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
}

class _CopyWithImpl$Input$EmailQueueScalarWhereInput<TRes>
    implements CopyWith$Input$EmailQueueScalarWhereInput<TRes> {
  _CopyWithImpl$Input$EmailQueueScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueScalarWhereInput _instance;

  final TRes Function(Input$EmailQueueScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$EmailQueueScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$EmailQueueScalarWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$EmailQueueScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$EmailQueueScalarWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
      }));
  TRes AND(
          Iterable<Input$EmailQueueScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueScalarWhereInput<
                          Input$EmailQueueScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$EmailQueueScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$EmailQueueScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueScalarWhereInput<
                          Input$EmailQueueScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$EmailQueueScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$EmailQueueScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueScalarWhereInput<
                          Input$EmailQueueScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$EmailQueueScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueScalarWhereInput<TRes>
    implements CopyWith$Input$EmailQueueScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$EmailQueueScalarWhereInput>? AND,
    List<Input$EmailQueueScalarWhereInput>? OR,
    List<Input$EmailQueueScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
}

class Input$EmailQueueSumAggregateInput {
  factory Input$EmailQueueSumAggregateInput({bool? id}) =>
      Input$EmailQueueSumAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$EmailQueueSumAggregateInput._(this._$data);

  factory Input$EmailQueueSumAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    return Input$EmailQueueSumAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueSumAggregateInput<Input$EmailQueueSumAggregateInput>
      get copyWith => CopyWith$Input$EmailQueueSumAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueSumAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$EmailQueueSumAggregateInput<TRes> {
  factory CopyWith$Input$EmailQueueSumAggregateInput(
    Input$EmailQueueSumAggregateInput instance,
    TRes Function(Input$EmailQueueSumAggregateInput) then,
  ) = _CopyWithImpl$Input$EmailQueueSumAggregateInput;

  factory CopyWith$Input$EmailQueueSumAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueSumAggregateInput;

  TRes call({bool? id});
}

class _CopyWithImpl$Input$EmailQueueSumAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueSumAggregateInput<TRes> {
  _CopyWithImpl$Input$EmailQueueSumAggregateInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueSumAggregateInput _instance;

  final TRes Function(Input$EmailQueueSumAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$EmailQueueSumAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
      }));
}

class _CopyWithStubImpl$Input$EmailQueueSumAggregateInput<TRes>
    implements CopyWith$Input$EmailQueueSumAggregateInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueSumAggregateInput(this._res);

  TRes _res;

  call({bool? id}) => _res;
}

class Input$EmailQueueUpdateInput {
  factory Input$EmailQueueUpdateInput({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput? guest,
  }) =>
      Input$EmailQueueUpdateInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guest != null) r'guest': guest,
      });

  Input$EmailQueueUpdateInput._(this._$data);

  factory Input$EmailQueueUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$EmailQueueUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput? get guest =>
      (_$data['guest']
          as Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueUpdateInput<Input$EmailQueueUpdateInput>
      get copyWith => CopyWith$Input$EmailQueueUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueUpdateInput<TRes> {
  factory CopyWith$Input$EmailQueueUpdateInput(
    Input$EmailQueueUpdateInput instance,
    TRes Function(Input$EmailQueueUpdateInput) then,
  ) = _CopyWithImpl$Input$EmailQueueUpdateInput;

  factory CopyWith$Input$EmailQueueUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueUpdateInput;

  TRes call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput? guest,
  });
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
  CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<TRes>
      get guest;
}

class _CopyWithImpl$Input$EmailQueueUpdateInput<TRes>
    implements CopyWith$Input$EmailQueueUpdateInput<TRes> {
  _CopyWithImpl$Input$EmailQueueUpdateInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueUpdateInput _instance;

  final TRes Function(Input$EmailQueueUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$EmailQueueUpdateInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
        if (guest != _undefined)
          'guest': (guest
              as Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput?),
      }));
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueUpdateInput<TRes>
    implements CopyWith$Input$EmailQueueUpdateInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueUpdateInput(this._res);

  TRes _res;

  call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput? guest,
  }) =>
      _res;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<TRes>
      get guest =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput
              .stub(_res);
}

class Input$EmailQueueUpdateManyMutationInput {
  factory Input$EmailQueueUpdateManyMutationInput({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      Input$EmailQueueUpdateManyMutationInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$EmailQueueUpdateManyMutationInput._(this._$data);

  factory Input$EmailQueueUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    return Input$EmailQueueUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueUpdateManyMutationInput<
          Input$EmailQueueUpdateManyMutationInput>
      get copyWith => CopyWith$Input$EmailQueueUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$EmailQueueUpdateManyMutationInput(
    Input$EmailQueueUpdateManyMutationInput instance,
    TRes Function(Input$EmailQueueUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$EmailQueueUpdateManyMutationInput;

  factory CopyWith$Input$EmailQueueUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueUpdateManyMutationInput;

  TRes call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  });
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
}

class _CopyWithImpl$Input$EmailQueueUpdateManyMutationInput<TRes>
    implements CopyWith$Input$EmailQueueUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$EmailQueueUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueUpdateManyMutationInput _instance;

  final TRes Function(Input$EmailQueueUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$EmailQueueUpdateManyMutationInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueUpdateManyMutationInput<TRes>
    implements CopyWith$Input$EmailQueueUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      _res;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
}

class Input$EmailQueueUpdateManyWithoutGuestNestedInput {
  factory Input$EmailQueueUpdateManyWithoutGuestNestedInput({
    List<Input$EmailQueueCreateWithoutGuestInput>? create,
    List<Input$EmailQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$EmailQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$EmailQueueWhereUniqueInput>? $set,
    List<Input$EmailQueueWhereUniqueInput>? disconnect,
    List<Input$EmailQueueWhereUniqueInput>? delete,
    List<Input$EmailQueueWhereUniqueInput>? connect,
    List<Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$EmailQueueScalarWhereInput>? deleteMany,
  }) =>
      Input$EmailQueueUpdateManyWithoutGuestNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (createMany != null) r'createMany': createMany,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$EmailQueueUpdateManyWithoutGuestNestedInput._(this._$data);

  factory Input$EmailQueueUpdateManyWithoutGuestNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$EmailQueueCreateWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueCreateOrConnectWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$EmailQueueCreateManyGuestInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$EmailQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$EmailQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$EmailQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$EmailQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueUpdateManyWithWhereWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$EmailQueueScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$EmailQueueUpdateManyWithoutGuestNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EmailQueueCreateWithoutGuestInput>? get create =>
      (_$data['create'] as List<Input$EmailQueueCreateWithoutGuestInput>?);
  List<Input$EmailQueueCreateOrConnectWithoutGuestInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$EmailQueueCreateOrConnectWithoutGuestInput>?);
  List<Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>? get upsert =>
      (_$data['upsert']
          as List<Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>?);
  Input$EmailQueueCreateManyGuestInputEnvelope? get createMany =>
      (_$data['createMany'] as Input$EmailQueueCreateManyGuestInputEnvelope?);
  List<Input$EmailQueueWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$EmailQueueWhereUniqueInput>?);
  List<Input$EmailQueueWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$EmailQueueWhereUniqueInput>?);
  List<Input$EmailQueueWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$EmailQueueWhereUniqueInput>?);
  List<Input$EmailQueueWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$EmailQueueWhereUniqueInput>?);
  List<Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>? get update =>
      (_$data['update']
          as List<Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>?);
  List<Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>? get updateMany =>
      (_$data['updateMany']
          as List<Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>?);
  List<Input$EmailQueueScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$EmailQueueScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<
          Input$EmailQueueUpdateManyWithoutGuestNestedInput>
      get copyWith =>
          CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueUpdateManyWithoutGuestNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<
    TRes> {
  factory CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput(
    Input$EmailQueueUpdateManyWithoutGuestNestedInput instance,
    TRes Function(Input$EmailQueueUpdateManyWithoutGuestNestedInput) then,
  ) = _CopyWithImpl$Input$EmailQueueUpdateManyWithoutGuestNestedInput;

  factory CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EmailQueueUpdateManyWithoutGuestNestedInput;

  TRes call({
    List<Input$EmailQueueCreateWithoutGuestInput>? create,
    List<Input$EmailQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$EmailQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$EmailQueueWhereUniqueInput>? $set,
    List<Input$EmailQueueWhereUniqueInput>? disconnect,
    List<Input$EmailQueueWhereUniqueInput>? delete,
    List<Input$EmailQueueWhereUniqueInput>? connect,
    List<Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$EmailQueueScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$EmailQueueCreateWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueCreateWithoutGuestInput<
                      Input$EmailQueueCreateWithoutGuestInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$EmailQueueCreateOrConnectWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput<
                      Input$EmailQueueCreateOrConnectWithoutGuestInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput<
                      Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>>?)
          _fn);
  CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> get createMany;
  TRes $set(
      Iterable<Input$EmailQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereUniqueInput<
                      Input$EmailQueueWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$EmailQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereUniqueInput<
                      Input$EmailQueueWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$EmailQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereUniqueInput<
                      Input$EmailQueueWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$EmailQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereUniqueInput<
                      Input$EmailQueueWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput<
                      Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput<
                      Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$EmailQueueScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueScalarWhereInput<
                      Input$EmailQueueScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
    implements
        CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes> {
  _CopyWithImpl$Input$EmailQueueUpdateManyWithoutGuestNestedInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueUpdateManyWithoutGuestNestedInput _instance;

  final TRes Function(Input$EmailQueueUpdateManyWithoutGuestNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? createMany = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$EmailQueueUpdateManyWithoutGuestNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$EmailQueueCreateWithoutGuestInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$EmailQueueCreateOrConnectWithoutGuestInput>?),
        if (upsert != _undefined)
          'upsert': (upsert
              as List<Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$EmailQueueCreateManyGuestInputEnvelope?),
        if ($set != _undefined)
          'set': ($set as List<Input$EmailQueueWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as List<Input$EmailQueueWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$EmailQueueWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$EmailQueueWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update
              as List<Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany
              as List<Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>?),
        if (deleteMany != _undefined)
          'deleteMany': (deleteMany as List<Input$EmailQueueScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$EmailQueueCreateWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueCreateWithoutGuestInput<
                          Input$EmailQueueCreateWithoutGuestInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$EmailQueueCreateWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$EmailQueueCreateOrConnectWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput<
                          Input$EmailQueueCreateOrConnectWithoutGuestInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$EmailQueueCreateOrConnectWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes upsert(
          Iterable<Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput<
                          Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes $set(
          Iterable<Input$EmailQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereUniqueInput<
                          Input$EmailQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$EmailQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$EmailQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereUniqueInput<
                          Input$EmailQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$EmailQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$EmailQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereUniqueInput<
                          Input$EmailQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$EmailQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$EmailQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereUniqueInput<
                          Input$EmailQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$EmailQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput<
                          Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput<
                          Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$EmailQueueScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueScalarWhereInput<
                          Input$EmailQueueScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$EmailQueueScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
    implements
        CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueUpdateManyWithoutGuestNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$EmailQueueCreateWithoutGuestInput>? create,
    List<Input$EmailQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$EmailQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$EmailQueueWhereUniqueInput>? $set,
    List<Input$EmailQueueWhereUniqueInput>? disconnect,
    List<Input$EmailQueueWhereUniqueInput>? delete,
    List<Input$EmailQueueWhereUniqueInput>? connect,
    List<Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$EmailQueueScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope<TRes> get createMany =>
      CopyWith$Input$EmailQueueCreateManyGuestInputEnvelope.stub(_res);
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$EmailQueueUpdateManyWithWhereWithoutGuestInput {
  factory Input$EmailQueueUpdateManyWithWhereWithoutGuestInput({
    required Input$EmailQueueScalarWhereInput where,
    required Input$EmailQueueUpdateManyMutationInput data,
  }) =>
      Input$EmailQueueUpdateManyWithWhereWithoutGuestInput._({
        r'where': where,
        r'data': data,
      });

  Input$EmailQueueUpdateManyWithWhereWithoutGuestInput._(this._$data);

  factory Input$EmailQueueUpdateManyWithWhereWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$EmailQueueScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$EmailQueueUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$EmailQueueUpdateManyWithWhereWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$EmailQueueScalarWhereInput get where =>
      (_$data['where'] as Input$EmailQueueScalarWhereInput);
  Input$EmailQueueUpdateManyMutationInput get data =>
      (_$data['data'] as Input$EmailQueueUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput<
          Input$EmailQueueUpdateManyWithWhereWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueUpdateManyWithWhereWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput(
    Input$EmailQueueUpdateManyWithWhereWithoutGuestInput instance,
    TRes Function(Input$EmailQueueUpdateManyWithWhereWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput;

  factory CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput;

  TRes call({
    Input$EmailQueueScalarWhereInput? where,
    Input$EmailQueueUpdateManyMutationInput? data,
  });
  CopyWith$Input$EmailQueueScalarWhereInput<TRes> get where;
  CopyWith$Input$EmailQueueUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput<TRes>
    implements
        CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueUpdateManyWithWhereWithoutGuestInput _instance;

  final TRes Function(Input$EmailQueueUpdateManyWithWhereWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$EmailQueueUpdateManyWithWhereWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$EmailQueueScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$EmailQueueUpdateManyMutationInput),
      }));
  CopyWith$Input$EmailQueueScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$EmailQueueScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$EmailQueueUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$EmailQueueUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueUpdateManyWithWhereWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$EmailQueueScalarWhereInput? where,
    Input$EmailQueueUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$EmailQueueScalarWhereInput<TRes> get where =>
      CopyWith$Input$EmailQueueScalarWhereInput.stub(_res);
  CopyWith$Input$EmailQueueUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$EmailQueueUpdateManyMutationInput.stub(_res);
}

class Input$EmailQueueUpdateWithoutGuestInput {
  factory Input$EmailQueueUpdateWithoutGuestInput({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      Input$EmailQueueUpdateWithoutGuestInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$EmailQueueUpdateWithoutGuestInput._(this._$data);

  factory Input$EmailQueueUpdateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    return Input$EmailQueueUpdateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueUpdateWithoutGuestInput<
          Input$EmailQueueUpdateWithoutGuestInput>
      get copyWith => CopyWith$Input$EmailQueueUpdateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueUpdateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> {
  factory CopyWith$Input$EmailQueueUpdateWithoutGuestInput(
    Input$EmailQueueUpdateWithoutGuestInput instance,
    TRes Function(Input$EmailQueueUpdateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$EmailQueueUpdateWithoutGuestInput;

  factory CopyWith$Input$EmailQueueUpdateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueUpdateWithoutGuestInput;

  TRes call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  });
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
}

class _CopyWithImpl$Input$EmailQueueUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$EmailQueueUpdateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueUpdateWithoutGuestInput _instance;

  final TRes Function(Input$EmailQueueUpdateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$EmailQueueUpdateWithoutGuestInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueUpdateWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      _res;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
}

class Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput {
  factory Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput({
    required Input$EmailQueueWhereUniqueInput where,
    required Input$EmailQueueUpdateWithoutGuestInput data,
  }) =>
      Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput._({
        r'where': where,
        r'data': data,
      });

  Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput._(this._$data);

  factory Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$EmailQueueWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$EmailQueueUpdateWithoutGuestInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$EmailQueueWhereUniqueInput get where =>
      (_$data['where'] as Input$EmailQueueWhereUniqueInput);
  Input$EmailQueueUpdateWithoutGuestInput get data =>
      (_$data['data'] as Input$EmailQueueUpdateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput<
          Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput(
    Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput instance,
    TRes Function(Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput;

  factory CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput;

  TRes call({
    Input$EmailQueueWhereUniqueInput? where,
    Input$EmailQueueUpdateWithoutGuestInput? data,
  });
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where;
  CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> get data;
}

class _CopyWithImpl$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput<TRes>
    implements
        CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput _instance;

  final TRes Function(Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$EmailQueueWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$EmailQueueUpdateWithoutGuestInput),
      }));
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$EmailQueueWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$EmailQueueUpdateWithoutGuestInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueUpdateWithWhereUniqueWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$EmailQueueWhereUniqueInput? where,
    Input$EmailQueueUpdateWithoutGuestInput? data,
  }) =>
      _res;
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where =>
      CopyWith$Input$EmailQueueWhereUniqueInput.stub(_res);
  CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> get data =>
      CopyWith$Input$EmailQueueUpdateWithoutGuestInput.stub(_res);
}

class Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput {
  factory Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput({
    required Input$EmailQueueWhereUniqueInput where,
    required Input$EmailQueueUpdateWithoutGuestInput update,
    required Input$EmailQueueCreateWithoutGuestInput create,
  }) =>
      Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput._(this._$data);

  factory Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$EmailQueueWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$EmailQueueUpdateWithoutGuestInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$EmailQueueCreateWithoutGuestInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$EmailQueueWhereUniqueInput get where =>
      (_$data['where'] as Input$EmailQueueWhereUniqueInput);
  Input$EmailQueueUpdateWithoutGuestInput get update =>
      (_$data['update'] as Input$EmailQueueUpdateWithoutGuestInput);
  Input$EmailQueueCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$EmailQueueCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput<
          Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput(
    Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput instance,
    TRes Function(Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput;

  factory CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput;

  TRes call({
    Input$EmailQueueWhereUniqueInput? where,
    Input$EmailQueueUpdateWithoutGuestInput? update,
    Input$EmailQueueCreateWithoutGuestInput? create,
  });
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where;
  CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> get update;
  CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput<TRes>
    implements
        CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput _instance;

  final TRes Function(Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$EmailQueueWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$EmailQueueUpdateWithoutGuestInput),
        if (create != _undefined && create != null)
          'create': (create as Input$EmailQueueCreateWithoutGuestInput),
      }));
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$EmailQueueWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$EmailQueueUpdateWithoutGuestInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$EmailQueueCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueUpsertWithWhereUniqueWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$EmailQueueWhereUniqueInput? where,
    Input$EmailQueueUpdateWithoutGuestInput? update,
    Input$EmailQueueCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$EmailQueueWhereUniqueInput<TRes> get where =>
      CopyWith$Input$EmailQueueWhereUniqueInput.stub(_res);
  CopyWith$Input$EmailQueueUpdateWithoutGuestInput<TRes> get update =>
      CopyWith$Input$EmailQueueUpdateWithoutGuestInput.stub(_res);
  CopyWith$Input$EmailQueueCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$EmailQueueCreateWithoutGuestInput.stub(_res);
}

class Input$EmailQueueWhereInput {
  factory Input$EmailQueueWhereInput({
    List<Input$EmailQueueWhereInput>? AND,
    List<Input$EmailQueueWhereInput>? OR,
    List<Input$EmailQueueWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      Input$EmailQueueWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$EmailQueueWhereInput._(this._$data);

  factory Input$EmailQueueWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$EmailQueueWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$EmailQueueWhereInput>? get AND =>
      (_$data['AND'] as List<Input$EmailQueueWhereInput>?);
  List<Input$EmailQueueWhereInput>? get OR =>
      (_$data['OR'] as List<Input$EmailQueueWhereInput>?);
  List<Input$EmailQueueWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$EmailQueueWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueWhereInput<Input$EmailQueueWhereInput>
      get copyWith => CopyWith$Input$EmailQueueWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueWhereInput<TRes> {
  factory CopyWith$Input$EmailQueueWhereInput(
    Input$EmailQueueWhereInput instance,
    TRes Function(Input$EmailQueueWhereInput) then,
  ) = _CopyWithImpl$Input$EmailQueueWhereInput;

  factory CopyWith$Input$EmailQueueWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueWhereInput;

  TRes call({
    List<Input$EmailQueueWhereInput>? AND,
    List<Input$EmailQueueWhereInput>? OR,
    List<Input$EmailQueueWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  });
  TRes AND(
      Iterable<Input$EmailQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereInput<
                      Input$EmailQueueWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$EmailQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereInput<
                      Input$EmailQueueWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$EmailQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereInput<
                      Input$EmailQueueWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
}

class _CopyWithImpl$Input$EmailQueueWhereInput<TRes>
    implements CopyWith$Input$EmailQueueWhereInput<TRes> {
  _CopyWithImpl$Input$EmailQueueWhereInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueWhereInput _instance;

  final TRes Function(Input$EmailQueueWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$EmailQueueWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$EmailQueueWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$EmailQueueWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$EmailQueueWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$EmailQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereInput<
                          Input$EmailQueueWhereInput>>?)
              _fn) =>
      call(
          AND:
              _fn(_instance.AND?.map((e) => CopyWith$Input$EmailQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$EmailQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereInput<
                          Input$EmailQueueWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$EmailQueueWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$EmailQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereInput<
                          Input$EmailQueueWhereInput>>?)
              _fn) =>
      call(
          NOT:
              _fn(_instance.NOT?.map((e) => CopyWith$Input$EmailQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueWhereInput<TRes>
    implements CopyWith$Input$EmailQueueWhereInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueWhereInput(this._res);

  TRes _res;

  call({
    List<Input$EmailQueueWhereInput>? AND,
    List<Input$EmailQueueWhereInput>? OR,
    List<Input$EmailQueueWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
}

class Input$EmailQueueWhereUniqueInput {
  factory Input$EmailQueueWhereUniqueInput({
    int? id,
    List<Input$EmailQueueWhereInput>? AND,
    List<Input$EmailQueueWhereInput>? OR,
    List<Input$EmailQueueWhereInput>? NOT,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      Input$EmailQueueWhereUniqueInput._({
        if (id != null) r'id': id,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$EmailQueueWhereUniqueInput._(this._$data);

  factory Input$EmailQueueWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$EmailQueueWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$EmailQueueWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  List<Input$EmailQueueWhereInput>? get AND =>
      (_$data['AND'] as List<Input$EmailQueueWhereInput>?);
  List<Input$EmailQueueWhereInput>? get OR =>
      (_$data['OR'] as List<Input$EmailQueueWhereInput>?);
  List<Input$EmailQueueWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$EmailQueueWhereInput>?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EmailQueueWhereUniqueInput<Input$EmailQueueWhereUniqueInput>
      get copyWith => CopyWith$Input$EmailQueueWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EmailQueueWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$EmailQueueWhereUniqueInput<TRes> {
  factory CopyWith$Input$EmailQueueWhereUniqueInput(
    Input$EmailQueueWhereUniqueInput instance,
    TRes Function(Input$EmailQueueWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$EmailQueueWhereUniqueInput;

  factory CopyWith$Input$EmailQueueWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EmailQueueWhereUniqueInput;

  TRes call({
    int? id,
    List<Input$EmailQueueWhereInput>? AND,
    List<Input$EmailQueueWhereInput>? OR,
    List<Input$EmailQueueWhereInput>? NOT,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  });
  TRes AND(
      Iterable<Input$EmailQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereInput<
                      Input$EmailQueueWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$EmailQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereInput<
                      Input$EmailQueueWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$EmailQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$EmailQueueWhereInput<
                      Input$EmailQueueWhereInput>>?)
          _fn);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
}

class _CopyWithImpl$Input$EmailQueueWhereUniqueInput<TRes>
    implements CopyWith$Input$EmailQueueWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$EmailQueueWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$EmailQueueWhereUniqueInput _instance;

  final TRes Function(Input$EmailQueueWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$EmailQueueWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (AND != _undefined)
          'AND': (AND as List<Input$EmailQueueWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$EmailQueueWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$EmailQueueWhereInput>?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$EmailQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereInput<
                          Input$EmailQueueWhereInput>>?)
              _fn) =>
      call(
          AND:
              _fn(_instance.AND?.map((e) => CopyWith$Input$EmailQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$EmailQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereInput<
                          Input$EmailQueueWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$EmailQueueWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$EmailQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$EmailQueueWhereInput<
                          Input$EmailQueueWhereInput>>?)
              _fn) =>
      call(
          NOT:
              _fn(_instance.NOT?.map((e) => CopyWith$Input$EmailQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$EmailQueueWhereUniqueInput<TRes>
    implements CopyWith$Input$EmailQueueWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$EmailQueueWhereUniqueInput(this._res);

  TRes _res;

  call({
    int? id,
    List<Input$EmailQueueWhereInput>? AND,
    List<Input$EmailQueueWhereInput>? OR,
    List<Input$EmailQueueWhereInput>? NOT,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
}

class Input$EnumConfirmationStatusFieldUpdateOperationsInput {
  factory Input$EnumConfirmationStatusFieldUpdateOperationsInput(
          {Enum$ConfirmationStatus? $set}) =>
      Input$EnumConfirmationStatusFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$EnumConfirmationStatusFieldUpdateOperationsInput._(this._$data);

  factory Input$EnumConfirmationStatusFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = l$$set == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$$set as String));
    }
    return Input$EnumConfirmationStatusFieldUpdateOperationsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ConfirmationStatus? get $set =>
      (_$data['set'] as Enum$ConfirmationStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] =
          l$$set == null ? null : toJson$Enum$ConfirmationStatus(l$$set);
    }
    return result$data;
  }

  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<
          Input$EnumConfirmationStatusFieldUpdateOperationsInput>
      get copyWith =>
          CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumConfirmationStatusFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<
    TRes> {
  factory CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
    Input$EnumConfirmationStatusFieldUpdateOperationsInput instance,
    TRes Function(Input$EnumConfirmationStatusFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$EnumConfirmationStatusFieldUpdateOperationsInput;

  factory CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EnumConfirmationStatusFieldUpdateOperationsInput;

  TRes call({Enum$ConfirmationStatus? $set});
}

class _CopyWithImpl$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
    implements
        CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$EnumConfirmationStatusFieldUpdateOperationsInput _instance;

  final TRes Function(Input$EnumConfirmationStatusFieldUpdateOperationsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$EnumConfirmationStatusFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as Enum$ConfirmationStatus?),
      }));
}

class _CopyWithStubImpl$Input$EnumConfirmationStatusFieldUpdateOperationsInput<
        TRes>
    implements
        CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
      this._res);

  TRes _res;

  call({Enum$ConfirmationStatus? $set}) => _res;
}

class Input$EnumConfirmationStatusFilter {
  factory Input$EnumConfirmationStatusFilter({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusFilter? not,
  }) =>
      Input$EnumConfirmationStatusFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$EnumConfirmationStatusFilter._(this._$data);

  factory Input$EnumConfirmationStatusFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConfirmationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConfirmationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumConfirmationStatusFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$EnumConfirmationStatusFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ConfirmationStatus? get equals =>
      (_$data['equals'] as Enum$ConfirmationStatus?);
  List<Enum$ConfirmationStatus>? get $in =>
      (_$data['in'] as List<Enum$ConfirmationStatus>?);
  List<Enum$ConfirmationStatus>? get notIn =>
      (_$data['notIn'] as List<Enum$ConfirmationStatus>?);
  Input$NestedEnumConfirmationStatusFilter? get not =>
      (_$data['not'] as Input$NestedEnumConfirmationStatusFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$ConfirmationStatus(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$ConfirmationStatus(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$ConfirmationStatus(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EnumConfirmationStatusFilter<
          Input$EnumConfirmationStatusFilter>
      get copyWith => CopyWith$Input$EnumConfirmationStatusFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumConfirmationStatusFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumConfirmationStatusFilter<TRes> {
  factory CopyWith$Input$EnumConfirmationStatusFilter(
    Input$EnumConfirmationStatusFilter instance,
    TRes Function(Input$EnumConfirmationStatusFilter) then,
  ) = _CopyWithImpl$Input$EnumConfirmationStatusFilter;

  factory CopyWith$Input$EnumConfirmationStatusFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumConfirmationStatusFilter;

  TRes call({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusFilter? not,
  });
  CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> get not;
}

class _CopyWithImpl$Input$EnumConfirmationStatusFilter<TRes>
    implements CopyWith$Input$EnumConfirmationStatusFilter<TRes> {
  _CopyWithImpl$Input$EnumConfirmationStatusFilter(
    this._instance,
    this._then,
  );

  final Input$EnumConfirmationStatusFilter _instance;

  final TRes Function(Input$EnumConfirmationStatusFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$EnumConfirmationStatusFilter._({
        ..._instance._$data,
        if (equals != _undefined)
          'equals': (equals as Enum$ConfirmationStatus?),
        if ($in != _undefined) 'in': ($in as List<Enum$ConfirmationStatus>?),
        if (notIn != _undefined)
          'notIn': (notIn as List<Enum$ConfirmationStatus>?),
        if (not != _undefined)
          'not': (not as Input$NestedEnumConfirmationStatusFilter?),
      }));
  CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumConfirmationStatusFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedEnumConfirmationStatusFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$EnumConfirmationStatusFilter<TRes>
    implements CopyWith$Input$EnumConfirmationStatusFilter<TRes> {
  _CopyWithStubImpl$Input$EnumConfirmationStatusFilter(this._res);

  TRes _res;

  call({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> get not =>
      CopyWith$Input$NestedEnumConfirmationStatusFilter.stub(_res);
}

class Input$EnumQueueStatusFieldUpdateOperationsInput {
  factory Input$EnumQueueStatusFieldUpdateOperationsInput(
          {Enum$QueueStatus? $set}) =>
      Input$EnumQueueStatusFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$EnumQueueStatusFieldUpdateOperationsInput._(this._$data);

  factory Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] =
          l$$set == null ? null : fromJson$Enum$QueueStatus((l$$set as String));
    }
    return Input$EnumQueueStatusFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$QueueStatus? get $set => (_$data['set'] as Enum$QueueStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] =
          l$$set == null ? null : toJson$Enum$QueueStatus(l$$set);
    }
    return result$data;
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<
          Input$EnumQueueStatusFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumQueueStatusFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
    Input$EnumQueueStatusFieldUpdateOperationsInput instance,
    TRes Function(Input$EnumQueueStatusFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$EnumQueueStatusFieldUpdateOperationsInput;

  factory CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EnumQueueStatusFieldUpdateOperationsInput;

  TRes call({Enum$QueueStatus? $set});
}

class _CopyWithImpl$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$EnumQueueStatusFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$EnumQueueStatusFieldUpdateOperationsInput _instance;

  final TRes Function(Input$EnumQueueStatusFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$EnumQueueStatusFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as Enum$QueueStatus?),
      }));
}

class _CopyWithStubImpl$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$EnumQueueStatusFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({Enum$QueueStatus? $set}) => _res;
}

class Input$EnumQueueStatusFilter {
  factory Input$EnumQueueStatusFilter({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  }) =>
      Input$EnumQueueStatusFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$EnumQueueStatusFilter._(this._$data);

  factory Input$EnumQueueStatusFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$QueueStatus((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$QueueStatus((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$QueueStatus((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumQueueStatusFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$EnumQueueStatusFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$QueueStatus? get equals => (_$data['equals'] as Enum$QueueStatus?);
  List<Enum$QueueStatus>? get $in => (_$data['in'] as List<Enum$QueueStatus>?);
  List<Enum$QueueStatus>? get notIn =>
      (_$data['notIn'] as List<Enum$QueueStatus>?);
  Input$NestedEnumQueueStatusFilter? get not =>
      (_$data['not'] as Input$NestedEnumQueueStatusFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$QueueStatus(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$QueueStatus(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$QueueStatus(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EnumQueueStatusFilter<Input$EnumQueueStatusFilter>
      get copyWith => CopyWith$Input$EnumQueueStatusFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumQueueStatusFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumQueueStatusFilter<TRes> {
  factory CopyWith$Input$EnumQueueStatusFilter(
    Input$EnumQueueStatusFilter instance,
    TRes Function(Input$EnumQueueStatusFilter) then,
  ) = _CopyWithImpl$Input$EnumQueueStatusFilter;

  factory CopyWith$Input$EnumQueueStatusFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumQueueStatusFilter;

  TRes call({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  });
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not;
}

class _CopyWithImpl$Input$EnumQueueStatusFilter<TRes>
    implements CopyWith$Input$EnumQueueStatusFilter<TRes> {
  _CopyWithImpl$Input$EnumQueueStatusFilter(
    this._instance,
    this._then,
  );

  final Input$EnumQueueStatusFilter _instance;

  final TRes Function(Input$EnumQueueStatusFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$EnumQueueStatusFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as Enum$QueueStatus?),
        if ($in != _undefined) 'in': ($in as List<Enum$QueueStatus>?),
        if (notIn != _undefined) 'notIn': (notIn as List<Enum$QueueStatus>?),
        if (not != _undefined)
          'not': (not as Input$NestedEnumQueueStatusFilter?),
      }));
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$NestedEnumQueueStatusFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$EnumQueueStatusFilter<TRes>
    implements CopyWith$Input$EnumQueueStatusFilter<TRes> {
  _CopyWithStubImpl$Input$EnumQueueStatusFilter(this._res);

  TRes _res;

  call({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not =>
      CopyWith$Input$NestedEnumQueueStatusFilter.stub(_res);
}

class Input$EnumUserRoleFieldUpdateOperationsInput {
  factory Input$EnumUserRoleFieldUpdateOperationsInput({Enum$UserRole? $set}) =>
      Input$EnumUserRoleFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$EnumUserRoleFieldUpdateOperationsInput._(this._$data);

  factory Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] =
          l$$set == null ? null : fromJson$Enum$UserRole((l$$set as String));
    }
    return Input$EnumUserRoleFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserRole? get $set => (_$data['set'] as Enum$UserRole?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set == null ? null : toJson$Enum$UserRole(l$$set);
    }
    return result$data;
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<
          Input$EnumUserRoleFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumUserRoleFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
    Input$EnumUserRoleFieldUpdateOperationsInput instance,
    TRes Function(Input$EnumUserRoleFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$EnumUserRoleFieldUpdateOperationsInput;

  factory CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumUserRoleFieldUpdateOperationsInput;

  TRes call({Enum$UserRole? $set});
}

class _CopyWithImpl$Input$EnumUserRoleFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$EnumUserRoleFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$EnumUserRoleFieldUpdateOperationsInput _instance;

  final TRes Function(Input$EnumUserRoleFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$EnumUserRoleFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as Enum$UserRole?),
      }));
}

class _CopyWithStubImpl$Input$EnumUserRoleFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$EnumUserRoleFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({Enum$UserRole? $set}) => _res;
}

class Input$EnumUserRoleFilter {
  factory Input$EnumUserRoleFilter({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  }) =>
      Input$EnumUserRoleFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$EnumUserRoleFilter._(this._$data);

  factory Input$EnumUserRoleFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$UserRole((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumUserRoleFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$EnumUserRoleFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserRole? get equals => (_$data['equals'] as Enum$UserRole?);
  List<Enum$UserRole>? get $in => (_$data['in'] as List<Enum$UserRole>?);
  List<Enum$UserRole>? get notIn => (_$data['notIn'] as List<Enum$UserRole>?);
  Input$NestedEnumUserRoleFilter? get not =>
      (_$data['not'] as Input$NestedEnumUserRoleFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$UserRole(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$EnumUserRoleFilter<Input$EnumUserRoleFilter> get copyWith =>
      CopyWith$Input$EnumUserRoleFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnumUserRoleFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$EnumUserRoleFilter<TRes> {
  factory CopyWith$Input$EnumUserRoleFilter(
    Input$EnumUserRoleFilter instance,
    TRes Function(Input$EnumUserRoleFilter) then,
  ) = _CopyWithImpl$Input$EnumUserRoleFilter;

  factory CopyWith$Input$EnumUserRoleFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$EnumUserRoleFilter;

  TRes call({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  });
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not;
}

class _CopyWithImpl$Input$EnumUserRoleFilter<TRes>
    implements CopyWith$Input$EnumUserRoleFilter<TRes> {
  _CopyWithImpl$Input$EnumUserRoleFilter(
    this._instance,
    this._then,
  );

  final Input$EnumUserRoleFilter _instance;

  final TRes Function(Input$EnumUserRoleFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$EnumUserRoleFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as Enum$UserRole?),
        if ($in != _undefined) 'in': ($in as List<Enum$UserRole>?),
        if (notIn != _undefined) 'notIn': (notIn as List<Enum$UserRole>?),
        if (not != _undefined) 'not': (not as Input$NestedEnumUserRoleFilter?),
      }));
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$NestedEnumUserRoleFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$EnumUserRoleFilter<TRes>
    implements CopyWith$Input$EnumUserRoleFilter<TRes> {
  _CopyWithStubImpl$Input$EnumUserRoleFilter(this._res);

  TRes _res;

  call({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not =>
      CopyWith$Input$NestedEnumUserRoleFilter.stub(_res);
}

class Input$GuestAvgAggregateInput {
  factory Input$GuestAvgAggregateInput({bool? parties}) =>
      Input$GuestAvgAggregateInput._({
        if (parties != null) r'parties': parties,
      });

  Input$GuestAvgAggregateInput._(this._$data);

  factory Input$GuestAvgAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as bool?);
    }
    return Input$GuestAvgAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get parties => (_$data['parties'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    return result$data;
  }

  CopyWith$Input$GuestAvgAggregateInput<Input$GuestAvgAggregateInput>
      get copyWith => CopyWith$Input$GuestAvgAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestAvgAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$parties = parties;
    return Object.hashAll(
        [_$data.containsKey('parties') ? l$parties : const {}]);
  }
}

abstract class CopyWith$Input$GuestAvgAggregateInput<TRes> {
  factory CopyWith$Input$GuestAvgAggregateInput(
    Input$GuestAvgAggregateInput instance,
    TRes Function(Input$GuestAvgAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestAvgAggregateInput;

  factory CopyWith$Input$GuestAvgAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestAvgAggregateInput;

  TRes call({bool? parties});
}

class _CopyWithImpl$Input$GuestAvgAggregateInput<TRes>
    implements CopyWith$Input$GuestAvgAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestAvgAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestAvgAggregateInput _instance;

  final TRes Function(Input$GuestAvgAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? parties = _undefined}) =>
      _then(Input$GuestAvgAggregateInput._({
        ..._instance._$data,
        if (parties != _undefined) 'parties': (parties as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestAvgAggregateInput<TRes>
    implements CopyWith$Input$GuestAvgAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestAvgAggregateInput(this._res);

  TRes _res;

  call({bool? parties}) => _res;
}

class Input$GuestCountAggregateInput {
  factory Input$GuestCountAggregateInput({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
    bool? $_all,
  }) =>
      Input$GuestCountAggregateInput._({
        if (userId != null) r'userId': userId,
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if ($_all != null) r'_all': $_all,
      });

  Input$GuestCountAggregateInput._(this._$data);

  factory Input$GuestCountAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as bool?);
    }
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as bool?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as bool?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as bool?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as bool?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as bool?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as bool?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as bool?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as bool?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = (l$confirmationStatus as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$GuestCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get userId => (_$data['userId'] as bool?);
  bool? get category1 => (_$data['category1'] as bool?);
  bool? get category2 => (_$data['category2'] as bool?);
  bool? get personInCharge => (_$data['personInCharge'] as bool?);
  bool? get $class => (_$data['class'] as bool?);
  bool? get seat => (_$data['seat'] as bool?);
  bool? get rejectionReason => (_$data['rejectionReason'] as bool?);
  bool? get description => (_$data['description'] as bool?);
  bool? get parties => (_$data['parties'] as bool?);
  bool? get confirmationStatus => (_$data['confirmationStatus'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$GuestCountAggregateInput<Input$GuestCountAggregateInput>
      get copyWith => CopyWith$Input$GuestCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCountAggregateInput<TRes> {
  factory CopyWith$Input$GuestCountAggregateInput(
    Input$GuestCountAggregateInput instance,
    TRes Function(Input$GuestCountAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestCountAggregateInput;

  factory CopyWith$Input$GuestCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCountAggregateInput;

  TRes call({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$GuestCountAggregateInput<TRes>
    implements CopyWith$Input$GuestCountAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestCountAggregateInput _instance;

  final TRes Function(Input$GuestCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$GuestCountAggregateInput._({
        ..._instance._$data,
        if (userId != _undefined) 'userId': (userId as bool?),
        if (category1 != _undefined) 'category1': (category1 as bool?),
        if (category2 != _undefined) 'category2': (category2 as bool?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as bool?),
        if ($class != _undefined) 'class': ($class as bool?),
        if (seat != _undefined) 'seat': (seat as bool?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as bool?),
        if (description != _undefined) 'description': (description as bool?),
        if (parties != _undefined) 'parties': (parties as bool?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestCountAggregateInput<TRes>
    implements CopyWith$Input$GuestCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
    bool? $_all,
  }) =>
      _res;
}

class Input$GuestCreateInput {
  factory Input$GuestCreateInput({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    required Input$UserCreateNestedOneWithoutGuestInfoInput user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  }) =>
      Input$GuestCreateInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestCreateInput._(this._$data);

  factory Input$GuestCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as String?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as String?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as int?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    final l$user = data['user'];
    result$data['user'] =
        Input$UserCreateNestedOneWithoutGuestInfoInput.fromJson(
            (l$user as Map<String, dynamic>));
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeCreateNestedManyWithoutGuestInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueCreateNestedManyWithoutGuestInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get category1 => (_$data['category1'] as String?);
  String? get category2 => (_$data['category2'] as String?);
  String? get personInCharge => (_$data['personInCharge'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get description => (_$data['description'] as String?);
  int? get parties => (_$data['parties'] as int?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$UserCreateNestedOneWithoutGuestInfoInput get user =>
      (_$data['user'] as Input$UserCreateNestedOneWithoutGuestInfoInput);
  Input$QrCodeCreateNestedManyWithoutGuestInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeCreateNestedManyWithoutGuestInput?);
  Input$EmailQueueCreateNestedManyWithoutGuestInput? get emailQueue =>
      (_$data['emailQueue']
          as Input$EmailQueueCreateNestedManyWithoutGuestInput?);
  Input$WhatsappQueueCreateNestedManyWithoutGuestInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    final l$user = user;
    result$data['user'] = l$user.toJson();
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateInput<Input$GuestCreateInput> get copyWith =>
      CopyWith$Input$GuestCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      l$user,
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateInput<TRes> {
  factory CopyWith$Input$GuestCreateInput(
    Input$GuestCreateInput instance,
    TRes Function(Input$GuestCreateInput) then,
  ) = _CopyWithImpl$Input$GuestCreateInput;

  factory CopyWith$Input$GuestCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateInput;

  TRes call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$UserCreateNestedOneWithoutGuestInfoInput? user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  });
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user;
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes;
  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue;
  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestCreateInput<TRes>
    implements CopyWith$Input$GuestCreateInput<TRes> {
  _CopyWithImpl$Input$GuestCreateInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateInput _instance;

  final TRes Function(Input$GuestCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestCreateInput._({
        ..._instance._$data,
        if (category1 != _undefined) 'category1': (category1 as String?),
        if (category2 != _undefined) 'category2': (category2 as String?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (description != _undefined) 'description': (description as String?),
        if (parties != _undefined) 'parties': (parties as int?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (user != _undefined && user != null)
          'user': (user as Input$UserCreateNestedOneWithoutGuestInfoInput),
        if (qrcodes != _undefined)
          'qrcodes':
              (qrcodes as Input$QrCodeCreateNestedManyWithoutGuestInput?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue
              as Input$EmailQueueCreateNestedManyWithoutGuestInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user {
    final local$user = _instance.user;
    return CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput(
        local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateInput<TRes>
    implements CopyWith$Input$GuestCreateInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateInput(this._res);

  TRes _res;

  call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$UserCreateNestedOneWithoutGuestInfoInput? user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user =>
      CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(_res);
  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue =>
          CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(_res);
  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateManyInput {
  factory Input$GuestCreateManyInput({
    required String userId,
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
  }) =>
      Input$GuestCreateManyInput._({
        r'userId': userId,
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestCreateManyInput._(this._$data);

  factory Input$GuestCreateManyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as String?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as String?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as int?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    return Input$GuestCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get userId => (_$data['userId'] as String);
  String? get category1 => (_$data['category1'] as String?);
  String? get category2 => (_$data['category2'] as String?);
  String? get personInCharge => (_$data['personInCharge'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get description => (_$data['description'] as String?);
  int? get parties => (_$data['parties'] as int?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$userId = userId;
    result$data['userId'] = l$userId;
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateManyInput<Input$GuestCreateManyInput>
      get copyWith => CopyWith$Input$GuestCreateManyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      l$userId,
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateManyInput<TRes> {
  factory CopyWith$Input$GuestCreateManyInput(
    Input$GuestCreateManyInput instance,
    TRes Function(Input$GuestCreateManyInput) then,
  ) = _CopyWithImpl$Input$GuestCreateManyInput;

  factory CopyWith$Input$GuestCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateManyInput;

  TRes call({
    String? userId,
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
  });
}

class _CopyWithImpl$Input$GuestCreateManyInput<TRes>
    implements CopyWith$Input$GuestCreateManyInput<TRes> {
  _CopyWithImpl$Input$GuestCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateManyInput _instance;

  final TRes Function(Input$GuestCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestCreateManyInput._({
        ..._instance._$data,
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
        if (category1 != _undefined) 'category1': (category1 as String?),
        if (category2 != _undefined) 'category2': (category2 as String?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (description != _undefined) 'description': (description as String?),
        if (parties != _undefined) 'parties': (parties as int?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
      }));
}

class _CopyWithStubImpl$Input$GuestCreateManyInput<TRes>
    implements CopyWith$Input$GuestCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateManyInput(this._res);

  TRes _res;

  call({
    String? userId,
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
  }) =>
      _res;
}

class Input$GuestCreateNestedOneWithoutEmailQueueInput {
  factory Input$GuestCreateNestedOneWithoutEmailQueueInput({
    Input$GuestCreateWithoutEmailQueueInput? create,
    Input$GuestCreateOrConnectWithoutEmailQueueInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      Input$GuestCreateNestedOneWithoutEmailQueueInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedOneWithoutEmailQueueInput._(this._$data);

  factory Input$GuestCreateNestedOneWithoutEmailQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutEmailQueueInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutEmailQueueInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$GuestCreateNestedOneWithoutEmailQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutEmailQueueInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutEmailQueueInput?);
  Input$GuestCreateOrConnectWithoutEmailQueueInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutEmailQueueInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput<
          Input$GuestCreateNestedOneWithoutEmailQueueInput>
      get copyWith => CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedOneWithoutEmailQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput<TRes> {
  factory CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput(
    Input$GuestCreateNestedOneWithoutEmailQueueInput instance,
    TRes Function(Input$GuestCreateNestedOneWithoutEmailQueueInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedOneWithoutEmailQueueInput;

  factory CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutEmailQueueInput;

  TRes call({
    Input$GuestCreateWithoutEmailQueueInput? create,
    Input$GuestCreateOrConnectWithoutEmailQueueInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  });
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$GuestCreateNestedOneWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedOneWithoutEmailQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedOneWithoutEmailQueueInput _instance;

  final TRes Function(Input$GuestCreateNestedOneWithoutEmailQueueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedOneWithoutEmailQueueInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutEmailQueueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutEmailQueueInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutEmailQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutEmailQueueInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestCreateNestedOneWithoutEmailQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutEmailQueueInput(this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutEmailQueueInput? create,
    Input$GuestCreateOrConnectWithoutEmailQueueInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutEmailQueueInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
}

class Input$GuestCreateNestedOneWithoutQrcodesInput {
  factory Input$GuestCreateNestedOneWithoutQrcodesInput({
    Input$GuestCreateWithoutQrcodesInput? create,
    Input$GuestCreateOrConnectWithoutQrcodesInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      Input$GuestCreateNestedOneWithoutQrcodesInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedOneWithoutQrcodesInput._(this._$data);

  factory Input$GuestCreateNestedOneWithoutQrcodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutQrcodesInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutQrcodesInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$GuestCreateNestedOneWithoutQrcodesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutQrcodesInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutQrcodesInput?);
  Input$GuestCreateOrConnectWithoutQrcodesInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutQrcodesInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput<
          Input$GuestCreateNestedOneWithoutQrcodesInput>
      get copyWith => CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedOneWithoutQrcodesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput<TRes> {
  factory CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput(
    Input$GuestCreateNestedOneWithoutQrcodesInput instance,
    TRes Function(Input$GuestCreateNestedOneWithoutQrcodesInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedOneWithoutQrcodesInput;

  factory CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutQrcodesInput;

  TRes call({
    Input$GuestCreateWithoutQrcodesInput? create,
    Input$GuestCreateOrConnectWithoutQrcodesInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  });
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$GuestCreateNestedOneWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedOneWithoutQrcodesInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedOneWithoutQrcodesInput _instance;

  final TRes Function(Input$GuestCreateNestedOneWithoutQrcodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedOneWithoutQrcodesInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutQrcodesInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutQrcodesInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutQrcodesInput.stub(_then(_instance))
        : CopyWith$Input$GuestCreateWithoutQrcodesInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutQrcodesInput(this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutQrcodesInput? create,
    Input$GuestCreateOrConnectWithoutQrcodesInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutQrcodesInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
}

class Input$GuestCreateNestedOneWithoutUserInput {
  factory Input$GuestCreateNestedOneWithoutUserInput({
    Input$GuestCreateWithoutUserInput? create,
    Input$GuestCreateOrConnectWithoutUserInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      Input$GuestCreateNestedOneWithoutUserInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedOneWithoutUserInput._(this._$data);

  factory Input$GuestCreateNestedOneWithoutUserInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutUserInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutUserInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$GuestCreateNestedOneWithoutUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutUserInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutUserInput?);
  Input$GuestCreateOrConnectWithoutUserInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutUserInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedOneWithoutUserInput<
          Input$GuestCreateNestedOneWithoutUserInput>
      get copyWith => CopyWith$Input$GuestCreateNestedOneWithoutUserInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedOneWithoutUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> {
  factory CopyWith$Input$GuestCreateNestedOneWithoutUserInput(
    Input$GuestCreateNestedOneWithoutUserInput instance,
    TRes Function(Input$GuestCreateNestedOneWithoutUserInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedOneWithoutUserInput;

  factory CopyWith$Input$GuestCreateNestedOneWithoutUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutUserInput;

  TRes call({
    Input$GuestCreateWithoutUserInput? create,
    Input$GuestCreateOrConnectWithoutUserInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  });
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes> get connectOrCreate;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$GuestCreateNestedOneWithoutUserInput<TRes>
    implements CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedOneWithoutUserInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedOneWithoutUserInput _instance;

  final TRes Function(Input$GuestCreateNestedOneWithoutUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedOneWithoutUserInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutUserInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate':
              (connectOrCreate as Input$GuestCreateOrConnectWithoutUserInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutUserInput.stub(_then(_instance))
        : CopyWith$Input$GuestCreateWithoutUserInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutUserInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutUserInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutUserInput<TRes>
    implements CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutUserInput(this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutUserInput? create,
    Input$GuestCreateOrConnectWithoutUserInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutUserInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutUserInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
}

class Input$GuestCreateNestedOneWithoutWhatsappQueueInput {
  factory Input$GuestCreateNestedOneWithoutWhatsappQueueInput({
    Input$GuestCreateWithoutWhatsappQueueInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappQueueInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      Input$GuestCreateNestedOneWithoutWhatsappQueueInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$GuestCreateNestedOneWithoutWhatsappQueueInput._(this._$data);

  factory Input$GuestCreateNestedOneWithoutWhatsappQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutWhatsappQueueInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutWhatsappQueueInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$GuestCreateNestedOneWithoutWhatsappQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutWhatsappQueueInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutWhatsappQueueInput?);
  Input$GuestCreateOrConnectWithoutWhatsappQueueInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutWhatsappQueueInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<
          Input$GuestCreateNestedOneWithoutWhatsappQueueInput>
      get copyWith =>
          CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateNestedOneWithoutWhatsappQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<
    TRes> {
  factory CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput(
    Input$GuestCreateNestedOneWithoutWhatsappQueueInput instance,
    TRes Function(Input$GuestCreateNestedOneWithoutWhatsappQueueInput) then,
  ) = _CopyWithImpl$Input$GuestCreateNestedOneWithoutWhatsappQueueInput;

  factory CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutWhatsappQueueInput;

  TRes call({
    Input$GuestCreateWithoutWhatsappQueueInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappQueueInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  });
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<TRes>
    implements
        CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<TRes> {
  _CopyWithImpl$Input$GuestCreateNestedOneWithoutWhatsappQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateNestedOneWithoutWhatsappQueueInput _instance;

  final TRes Function(Input$GuestCreateNestedOneWithoutWhatsappQueueInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$GuestCreateNestedOneWithoutWhatsappQueueInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutWhatsappQueueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutWhatsappQueueInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutWhatsappQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutWhatsappQueueInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<
        TRes>
    implements
        CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateNestedOneWithoutWhatsappQueueInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutWhatsappQueueInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappQueueInput? connectOrCreate,
    Input$GuestWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutWhatsappQueueInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput.stub(
              _res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutEmailQueueInput {
  factory Input$GuestCreateOrConnectWithoutEmailQueueInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutEmailQueueInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutEmailQueueInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutEmailQueueInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutEmailQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutEmailQueueInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutEmailQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutEmailQueueInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutEmailQueueInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<
          Input$GuestCreateOrConnectWithoutEmailQueueInput>
      get copyWith => CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutEmailQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput(
    Input$GuestCreateOrConnectWithoutEmailQueueInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutEmailQueueInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutEmailQueueInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutEmailQueueInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutEmailQueueInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutEmailQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutEmailQueueInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutEmailQueueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutEmailQueueInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutEmailQueueInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutEmailQueueInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutEmailQueueInput(this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutEmailQueueInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutEmailQueueInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutQrcodesInput {
  factory Input$GuestCreateOrConnectWithoutQrcodesInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutQrcodesInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutQrcodesInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutQrcodesInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutQrcodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutQrcodesInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutQrcodesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutQrcodesInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutQrcodesInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<
          Input$GuestCreateOrConnectWithoutQrcodesInput>
      get copyWith => CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutQrcodesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput(
    Input$GuestCreateOrConnectWithoutQrcodesInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutQrcodesInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutQrcodesInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutQrcodesInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutQrcodesInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutQrcodesInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutQrcodesInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutQrcodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutQrcodesInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutQrcodesInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutQrcodesInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutQrcodesInput(this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutQrcodesInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutQrcodesInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutUserInput {
  factory Input$GuestCreateOrConnectWithoutUserInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutUserInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutUserInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutUserInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutUserInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutUserInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutUserInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutUserInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutUserInput<
          Input$GuestCreateOrConnectWithoutUserInput>
      get copyWith => CopyWith$Input$GuestCreateOrConnectWithoutUserInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutUserInput(
    Input$GuestCreateOrConnectWithoutUserInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutUserInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutUserInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutUserInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutUserInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutUserInput<TRes>
    implements CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutUserInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutUserInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutUserInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutUserInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutUserInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutUserInput<TRes>
    implements CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutUserInput(this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutUserInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutUserInput.stub(_res);
}

class Input$GuestCreateOrConnectWithoutWhatsappQueueInput {
  factory Input$GuestCreateOrConnectWithoutWhatsappQueueInput({
    required Input$GuestWhereUniqueInput where,
    required Input$GuestCreateWithoutWhatsappQueueInput create,
  }) =>
      Input$GuestCreateOrConnectWithoutWhatsappQueueInput._({
        r'where': where,
        r'create': create,
      });

  Input$GuestCreateOrConnectWithoutWhatsappQueueInput._(this._$data);

  factory Input$GuestCreateOrConnectWithoutWhatsappQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$GuestWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutWhatsappQueueInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$GuestCreateOrConnectWithoutWhatsappQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereUniqueInput get where =>
      (_$data['where'] as Input$GuestWhereUniqueInput);
  Input$GuestCreateWithoutWhatsappQueueInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutWhatsappQueueInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<
          Input$GuestCreateOrConnectWithoutWhatsappQueueInput>
      get copyWith =>
          CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateOrConnectWithoutWhatsappQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<
    TRes> {
  factory CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput(
    Input$GuestCreateOrConnectWithoutWhatsappQueueInput instance,
    TRes Function(Input$GuestCreateOrConnectWithoutWhatsappQueueInput) then,
  ) = _CopyWithImpl$Input$GuestCreateOrConnectWithoutWhatsappQueueInput;

  factory CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutWhatsappQueueInput;

  TRes call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutWhatsappQueueInput? create,
  });
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where;
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create;
}

class _CopyWithImpl$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes> {
  _CopyWithImpl$Input$GuestCreateOrConnectWithoutWhatsappQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateOrConnectWithoutWhatsappQueueInput _instance;

  final TRes Function(Input$GuestCreateOrConnectWithoutWhatsappQueueInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$GuestCreateOrConnectWithoutWhatsappQueueInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$GuestWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutWhatsappQueueInput),
      }));
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$GuestWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutWhatsappQueueInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<
        TRes>
    implements
        CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateOrConnectWithoutWhatsappQueueInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereUniqueInput? where,
    Input$GuestCreateWithoutWhatsappQueueInput? create,
  }) =>
      _res;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get where =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutWhatsappQueueInput.stub(_res);
}

class Input$GuestCreateWithoutEmailQueueInput {
  factory Input$GuestCreateWithoutEmailQueueInput({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    required Input$UserCreateNestedOneWithoutGuestInfoInput user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  }) =>
      Input$GuestCreateWithoutEmailQueueInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestCreateWithoutEmailQueueInput._(this._$data);

  factory Input$GuestCreateWithoutEmailQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as String?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as String?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as int?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    final l$user = data['user'];
    result$data['user'] =
        Input$UserCreateNestedOneWithoutGuestInfoInput.fromJson(
            (l$user as Map<String, dynamic>));
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeCreateNestedManyWithoutGuestInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutEmailQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get category1 => (_$data['category1'] as String?);
  String? get category2 => (_$data['category2'] as String?);
  String? get personInCharge => (_$data['personInCharge'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get description => (_$data['description'] as String?);
  int? get parties => (_$data['parties'] as int?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$UserCreateNestedOneWithoutGuestInfoInput get user =>
      (_$data['user'] as Input$UserCreateNestedOneWithoutGuestInfoInput);
  Input$QrCodeCreateNestedManyWithoutGuestInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeCreateNestedManyWithoutGuestInput?);
  Input$WhatsappQueueCreateNestedManyWithoutGuestInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    final l$user = user;
    result$data['user'] = l$user.toJson();
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutEmailQueueInput<
          Input$GuestCreateWithoutEmailQueueInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutEmailQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutEmailQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      l$user,
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutEmailQueueInput(
    Input$GuestCreateWithoutEmailQueueInput instance,
    TRes Function(Input$GuestCreateWithoutEmailQueueInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutEmailQueueInput;

  factory CopyWith$Input$GuestCreateWithoutEmailQueueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutEmailQueueInput;

  TRes call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$UserCreateNestedOneWithoutGuestInfoInput? user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  });
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user;
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes;
  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestCreateWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutEmailQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutEmailQueueInput _instance;

  final TRes Function(Input$GuestCreateWithoutEmailQueueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutEmailQueueInput._({
        ..._instance._$data,
        if (category1 != _undefined) 'category1': (category1 as String?),
        if (category2 != _undefined) 'category2': (category2 as String?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (description != _undefined) 'description': (description as String?),
        if (parties != _undefined) 'parties': (parties as int?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (user != _undefined && user != null)
          'user': (user as Input$UserCreateNestedOneWithoutGuestInfoInput),
        if (qrcodes != _undefined)
          'qrcodes':
              (qrcodes as Input$QrCodeCreateNestedManyWithoutGuestInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user {
    final local$user = _instance.user;
    return CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput(
        local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutEmailQueueInput(this._res);

  TRes _res;

  call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$UserCreateNestedOneWithoutGuestInfoInput? user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user =>
      CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(_res);
  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateWithoutQrcodesInput {
  factory Input$GuestCreateWithoutQrcodesInput({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    required Input$UserCreateNestedOneWithoutGuestInfoInput user,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  }) =>
      Input$GuestCreateWithoutQrcodesInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        r'user': user,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestCreateWithoutQrcodesInput._(this._$data);

  factory Input$GuestCreateWithoutQrcodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as String?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as String?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as int?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    final l$user = data['user'];
    result$data['user'] =
        Input$UserCreateNestedOneWithoutGuestInfoInput.fromJson(
            (l$user as Map<String, dynamic>));
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueCreateNestedManyWithoutGuestInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutQrcodesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get category1 => (_$data['category1'] as String?);
  String? get category2 => (_$data['category2'] as String?);
  String? get personInCharge => (_$data['personInCharge'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get description => (_$data['description'] as String?);
  int? get parties => (_$data['parties'] as int?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$UserCreateNestedOneWithoutGuestInfoInput get user =>
      (_$data['user'] as Input$UserCreateNestedOneWithoutGuestInfoInput);
  Input$EmailQueueCreateNestedManyWithoutGuestInput? get emailQueue =>
      (_$data['emailQueue']
          as Input$EmailQueueCreateNestedManyWithoutGuestInput?);
  Input$WhatsappQueueCreateNestedManyWithoutGuestInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    final l$user = user;
    result$data['user'] = l$user.toJson();
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutQrcodesInput<
          Input$GuestCreateWithoutQrcodesInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutQrcodesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutQrcodesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      l$user,
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutQrcodesInput(
    Input$GuestCreateWithoutQrcodesInput instance,
    TRes Function(Input$GuestCreateWithoutQrcodesInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutQrcodesInput;

  factory CopyWith$Input$GuestCreateWithoutQrcodesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutQrcodesInput;

  TRes call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$UserCreateNestedOneWithoutGuestInfoInput? user,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  });
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user;
  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue;
  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestCreateWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutQrcodesInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutQrcodesInput _instance;

  final TRes Function(Input$GuestCreateWithoutQrcodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutQrcodesInput._({
        ..._instance._$data,
        if (category1 != _undefined) 'category1': (category1 as String?),
        if (category2 != _undefined) 'category2': (category2 as String?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (description != _undefined) 'description': (description as String?),
        if (parties != _undefined) 'parties': (parties as int?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (user != _undefined && user != null)
          'user': (user as Input$UserCreateNestedOneWithoutGuestInfoInput),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue
              as Input$EmailQueueCreateNestedManyWithoutGuestInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user {
    final local$user = _instance.user;
    return CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput(
        local$user, (e) => call(user: e));
  }

  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutQrcodesInput(this._res);

  TRes _res;

  call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$UserCreateNestedOneWithoutGuestInfoInput? user,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user =>
      CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue =>
          CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(_res);
  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateWithoutUserInput {
  factory Input$GuestCreateWithoutUserInput({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  }) =>
      Input$GuestCreateWithoutUserInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestCreateWithoutUserInput._(this._$data);

  factory Input$GuestCreateWithoutUserInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as String?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as String?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as int?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeCreateNestedManyWithoutGuestInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueCreateNestedManyWithoutGuestInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueCreateNestedManyWithoutGuestInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get category1 => (_$data['category1'] as String?);
  String? get category2 => (_$data['category2'] as String?);
  String? get personInCharge => (_$data['personInCharge'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get description => (_$data['description'] as String?);
  int? get parties => (_$data['parties'] as int?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$QrCodeCreateNestedManyWithoutGuestInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeCreateNestedManyWithoutGuestInput?);
  Input$EmailQueueCreateNestedManyWithoutGuestInput? get emailQueue =>
      (_$data['emailQueue']
          as Input$EmailQueueCreateNestedManyWithoutGuestInput?);
  Input$WhatsappQueueCreateNestedManyWithoutGuestInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutUserInput<Input$GuestCreateWithoutUserInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutUserInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutUserInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutUserInput(
    Input$GuestCreateWithoutUserInput instance,
    TRes Function(Input$GuestCreateWithoutUserInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutUserInput;

  factory CopyWith$Input$GuestCreateWithoutUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutUserInput;

  TRes call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  });
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes;
  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue;
  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestCreateWithoutUserInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutUserInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutUserInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutUserInput _instance;

  final TRes Function(Input$GuestCreateWithoutUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutUserInput._({
        ..._instance._$data,
        if (category1 != _undefined) 'category1': (category1 as String?),
        if (category2 != _undefined) 'category2': (category2 as String?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (description != _undefined) 'description': (description as String?),
        if (parties != _undefined) 'parties': (parties as int?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (qrcodes != _undefined)
          'qrcodes':
              (qrcodes as Input$QrCodeCreateNestedManyWithoutGuestInput?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue
              as Input$EmailQueueCreateNestedManyWithoutGuestInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutUserInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutUserInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutUserInput(this._res);

  TRes _res;

  call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(_res);
  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue =>
          CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(_res);
  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
              _res);
}

class Input$GuestCreateWithoutWhatsappQueueInput {
  factory Input$GuestCreateWithoutWhatsappQueueInput({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    required Input$UserCreateNestedOneWithoutGuestInfoInput user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
  }) =>
      Input$GuestCreateWithoutWhatsappQueueInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
      });

  Input$GuestCreateWithoutWhatsappQueueInput._(this._$data);

  factory Input$GuestCreateWithoutWhatsappQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as String?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as String?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as String?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as String?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as String?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as int?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$confirmationStatus as String));
    }
    final l$user = data['user'];
    result$data['user'] =
        Input$UserCreateNestedOneWithoutGuestInfoInput.fromJson(
            (l$user as Map<String, dynamic>));
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeCreateNestedManyWithoutGuestInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueCreateNestedManyWithoutGuestInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    return Input$GuestCreateWithoutWhatsappQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get category1 => (_$data['category1'] as String?);
  String? get category2 => (_$data['category2'] as String?);
  String? get personInCharge => (_$data['personInCharge'] as String?);
  String? get $class => (_$data['class'] as String?);
  String? get seat => (_$data['seat'] as String?);
  String? get rejectionReason => (_$data['rejectionReason'] as String?);
  String? get description => (_$data['description'] as String?);
  int? get parties => (_$data['parties'] as int?);
  Enum$ConfirmationStatus? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$ConfirmationStatus?);
  Input$UserCreateNestedOneWithoutGuestInfoInput get user =>
      (_$data['user'] as Input$UserCreateNestedOneWithoutGuestInfoInput);
  Input$QrCodeCreateNestedManyWithoutGuestInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeCreateNestedManyWithoutGuestInput?);
  Input$EmailQueueCreateNestedManyWithoutGuestInput? get emailQueue =>
      (_$data['emailQueue']
          as Input$EmailQueueCreateNestedManyWithoutGuestInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$ConfirmationStatus(l$confirmationStatus);
    }
    final l$user = user;
    result$data['user'] = l$user.toJson();
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<
          Input$GuestCreateWithoutWhatsappQueueInput>
      get copyWith => CopyWith$Input$GuestCreateWithoutWhatsappQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestCreateWithoutWhatsappQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      l$user,
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> {
  factory CopyWith$Input$GuestCreateWithoutWhatsappQueueInput(
    Input$GuestCreateWithoutWhatsappQueueInput instance,
    TRes Function(Input$GuestCreateWithoutWhatsappQueueInput) then,
  ) = _CopyWithImpl$Input$GuestCreateWithoutWhatsappQueueInput;

  factory CopyWith$Input$GuestCreateWithoutWhatsappQueueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestCreateWithoutWhatsappQueueInput;

  TRes call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$UserCreateNestedOneWithoutGuestInfoInput? user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
  });
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user;
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes;
  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue;
}

class _CopyWithImpl$Input$GuestCreateWithoutWhatsappQueueInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> {
  _CopyWithImpl$Input$GuestCreateWithoutWhatsappQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestCreateWithoutWhatsappQueueInput _instance;

  final TRes Function(Input$GuestCreateWithoutWhatsappQueueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
  }) =>
      _then(Input$GuestCreateWithoutWhatsappQueueInput._({
        ..._instance._$data,
        if (category1 != _undefined) 'category1': (category1 as String?),
        if (category2 != _undefined) 'category2': (category2 as String?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as String?),
        if ($class != _undefined) 'class': ($class as String?),
        if (seat != _undefined) 'seat': (seat as String?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as String?),
        if (description != _undefined) 'description': (description as String?),
        if (parties != _undefined) 'parties': (parties as int?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Enum$ConfirmationStatus?),
        if (user != _undefined && user != null)
          'user': (user as Input$UserCreateNestedOneWithoutGuestInfoInput),
        if (qrcodes != _undefined)
          'qrcodes':
              (qrcodes as Input$QrCodeCreateNestedManyWithoutGuestInput?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue
              as Input$EmailQueueCreateNestedManyWithoutGuestInput?),
      }));
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user {
    final local$user = _instance.user;
    return CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput(
        local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestCreateWithoutWhatsappQueueInput<TRes>
    implements CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestCreateWithoutWhatsappQueueInput(this._res);

  TRes _res;

  call({
    String? category1,
    String? category2,
    String? personInCharge,
    String? $class,
    String? seat,
    String? rejectionReason,
    String? description,
    int? parties,
    Enum$ConfirmationStatus? confirmationStatus,
    Input$UserCreateNestedOneWithoutGuestInfoInput? user,
    Input$QrCodeCreateNestedManyWithoutGuestInput? qrcodes,
    Input$EmailQueueCreateNestedManyWithoutGuestInput? emailQueue,
  }) =>
      _res;
  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> get user =>
      CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(_res);
  CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput<TRes>
      get emailQueue =>
          CopyWith$Input$EmailQueueCreateNestedManyWithoutGuestInput.stub(_res);
}

class Input$GuestMaxAggregateInput {
  factory Input$GuestMaxAggregateInput({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
  }) =>
      Input$GuestMaxAggregateInput._({
        if (userId != null) r'userId': userId,
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestMaxAggregateInput._(this._$data);

  factory Input$GuestMaxAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as bool?);
    }
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as bool?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as bool?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as bool?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as bool?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as bool?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as bool?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as bool?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as bool?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = (l$confirmationStatus as bool?);
    }
    return Input$GuestMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get userId => (_$data['userId'] as bool?);
  bool? get category1 => (_$data['category1'] as bool?);
  bool? get category2 => (_$data['category2'] as bool?);
  bool? get personInCharge => (_$data['personInCharge'] as bool?);
  bool? get $class => (_$data['class'] as bool?);
  bool? get seat => (_$data['seat'] as bool?);
  bool? get rejectionReason => (_$data['rejectionReason'] as bool?);
  bool? get description => (_$data['description'] as bool?);
  bool? get parties => (_$data['parties'] as bool?);
  bool? get confirmationStatus => (_$data['confirmationStatus'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus;
    }
    return result$data;
  }

  CopyWith$Input$GuestMaxAggregateInput<Input$GuestMaxAggregateInput>
      get copyWith => CopyWith$Input$GuestMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestMaxAggregateInput<TRes> {
  factory CopyWith$Input$GuestMaxAggregateInput(
    Input$GuestMaxAggregateInput instance,
    TRes Function(Input$GuestMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestMaxAggregateInput;

  factory CopyWith$Input$GuestMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestMaxAggregateInput;

  TRes call({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
  });
}

class _CopyWithImpl$Input$GuestMaxAggregateInput<TRes>
    implements CopyWith$Input$GuestMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestMaxAggregateInput _instance;

  final TRes Function(Input$GuestMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestMaxAggregateInput._({
        ..._instance._$data,
        if (userId != _undefined) 'userId': (userId as bool?),
        if (category1 != _undefined) 'category1': (category1 as bool?),
        if (category2 != _undefined) 'category2': (category2 as bool?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as bool?),
        if ($class != _undefined) 'class': ($class as bool?),
        if (seat != _undefined) 'seat': (seat as bool?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as bool?),
        if (description != _undefined) 'description': (description as bool?),
        if (parties != _undefined) 'parties': (parties as bool?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestMaxAggregateInput<TRes>
    implements CopyWith$Input$GuestMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
  }) =>
      _res;
}

class Input$GuestMinAggregateInput {
  factory Input$GuestMinAggregateInput({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
  }) =>
      Input$GuestMinAggregateInput._({
        if (userId != null) r'userId': userId,
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestMinAggregateInput._(this._$data);

  factory Input$GuestMinAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as bool?);
    }
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = (l$category1 as bool?);
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = (l$category2 as bool?);
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = (l$personInCharge as bool?);
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = (l$$class as bool?);
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = (l$seat as bool?);
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = (l$rejectionReason as bool?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as bool?);
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as bool?);
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = (l$confirmationStatus as bool?);
    }
    return Input$GuestMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get userId => (_$data['userId'] as bool?);
  bool? get category1 => (_$data['category1'] as bool?);
  bool? get category2 => (_$data['category2'] as bool?);
  bool? get personInCharge => (_$data['personInCharge'] as bool?);
  bool? get $class => (_$data['class'] as bool?);
  bool? get seat => (_$data['seat'] as bool?);
  bool? get rejectionReason => (_$data['rejectionReason'] as bool?);
  bool? get description => (_$data['description'] as bool?);
  bool? get parties => (_$data['parties'] as bool?);
  bool? get confirmationStatus => (_$data['confirmationStatus'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1;
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2;
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge;
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class;
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat;
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus;
    }
    return result$data;
  }

  CopyWith$Input$GuestMinAggregateInput<Input$GuestMinAggregateInput>
      get copyWith => CopyWith$Input$GuestMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestMinAggregateInput<TRes> {
  factory CopyWith$Input$GuestMinAggregateInput(
    Input$GuestMinAggregateInput instance,
    TRes Function(Input$GuestMinAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestMinAggregateInput;

  factory CopyWith$Input$GuestMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestMinAggregateInput;

  TRes call({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
  });
}

class _CopyWithImpl$Input$GuestMinAggregateInput<TRes>
    implements CopyWith$Input$GuestMinAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestMinAggregateInput _instance;

  final TRes Function(Input$GuestMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestMinAggregateInput._({
        ..._instance._$data,
        if (userId != _undefined) 'userId': (userId as bool?),
        if (category1 != _undefined) 'category1': (category1 as bool?),
        if (category2 != _undefined) 'category2': (category2 as bool?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as bool?),
        if ($class != _undefined) 'class': ($class as bool?),
        if (seat != _undefined) 'seat': (seat as bool?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as bool?),
        if (description != _undefined) 'description': (description as bool?),
        if (parties != _undefined) 'parties': (parties as bool?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestMinAggregateInput<TRes>
    implements CopyWith$Input$GuestMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? userId,
    bool? category1,
    bool? category2,
    bool? personInCharge,
    bool? $class,
    bool? seat,
    bool? rejectionReason,
    bool? description,
    bool? parties,
    bool? confirmationStatus,
  }) =>
      _res;
}

class Input$GuestNullableRelationFilter {
  factory Input$GuestNullableRelationFilter({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  }) =>
      Input$GuestNullableRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$GuestNullableRelationFilter._(this._$data);

  factory Input$GuestNullableRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$GuestWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$GuestWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$GuestNullableRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get $is => (_$data['is'] as Input$GuestWhereInput?);
  Input$GuestWhereInput? get isNot =>
      (_$data['isNot'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestNullableRelationFilter<Input$GuestNullableRelationFilter>
      get copyWith => CopyWith$Input$GuestNullableRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestNullableRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestNullableRelationFilter<TRes> {
  factory CopyWith$Input$GuestNullableRelationFilter(
    Input$GuestNullableRelationFilter instance,
    TRes Function(Input$GuestNullableRelationFilter) then,
  ) = _CopyWithImpl$Input$GuestNullableRelationFilter;

  factory CopyWith$Input$GuestNullableRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestNullableRelationFilter;

  TRes call({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  });
  CopyWith$Input$GuestWhereInput<TRes> get $is;
  CopyWith$Input$GuestWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$GuestNullableRelationFilter<TRes>
    implements CopyWith$Input$GuestNullableRelationFilter<TRes> {
  _CopyWithImpl$Input$GuestNullableRelationFilter(
    this._instance,
    this._then,
  );

  final Input$GuestNullableRelationFilter _instance;

  final TRes Function(Input$GuestNullableRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$GuestNullableRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$GuestWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$GuestNullableRelationFilter<TRes>
    implements CopyWith$Input$GuestNullableRelationFilter<TRes> {
  _CopyWithStubImpl$Input$GuestNullableRelationFilter(this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get $is =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get isNot =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestOrderByWithRelationInput {
  factory Input$GuestOrderByWithRelationInput({
    Enum$SortOrder? userId,
    Input$SortOrderInput? category1,
    Input$SortOrderInput? category2,
    Input$SortOrderInput? personInCharge,
    Input$SortOrderInput? $class,
    Input$SortOrderInput? seat,
    Input$SortOrderInput? rejectionReason,
    Input$SortOrderInput? description,
    Enum$SortOrder? parties,
    Enum$SortOrder? confirmationStatus,
    Input$UserOrderByWithRelationInput? user,
    Input$QrCodeOrderByRelationAggregateInput? qrcodes,
    Input$EmailQueueOrderByRelationAggregateInput? emailQueue,
    Input$WhatsappQueueOrderByRelationAggregateInput? whatsappQueue,
  }) =>
      Input$GuestOrderByWithRelationInput._({
        if (userId != null) r'userId': userId,
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (user != null) r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestOrderByWithRelationInput._(this._$data);

  factory Input$GuestOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : fromJson$Enum$SortOrder((l$userId as String));
    }
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$SortOrderInput.fromJson((l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$SortOrderInput.fromJson((l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : fromJson$Enum$SortOrder((l$parties as String));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : fromJson$Enum$SortOrder((l$confirmationStatus as String));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$UserOrderByWithRelationInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeOrderByRelationAggregateInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueOrderByRelationAggregateInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueOrderByRelationAggregateInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get userId => (_$data['userId'] as Enum$SortOrder?);
  Input$SortOrderInput? get category1 =>
      (_$data['category1'] as Input$SortOrderInput?);
  Input$SortOrderInput? get category2 =>
      (_$data['category2'] as Input$SortOrderInput?);
  Input$SortOrderInput? get personInCharge =>
      (_$data['personInCharge'] as Input$SortOrderInput?);
  Input$SortOrderInput? get $class =>
      (_$data['class'] as Input$SortOrderInput?);
  Input$SortOrderInput? get seat => (_$data['seat'] as Input$SortOrderInput?);
  Input$SortOrderInput? get rejectionReason =>
      (_$data['rejectionReason'] as Input$SortOrderInput?);
  Input$SortOrderInput? get description =>
      (_$data['description'] as Input$SortOrderInput?);
  Enum$SortOrder? get parties => (_$data['parties'] as Enum$SortOrder?);
  Enum$SortOrder? get confirmationStatus =>
      (_$data['confirmationStatus'] as Enum$SortOrder?);
  Input$UserOrderByWithRelationInput? get user =>
      (_$data['user'] as Input$UserOrderByWithRelationInput?);
  Input$QrCodeOrderByRelationAggregateInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeOrderByRelationAggregateInput?);
  Input$EmailQueueOrderByRelationAggregateInput? get emailQueue =>
      (_$data['emailQueue'] as Input$EmailQueueOrderByRelationAggregateInput?);
  Input$WhatsappQueueOrderByRelationAggregateInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] =
          l$userId == null ? null : toJson$Enum$SortOrder(l$userId);
    }
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] =
          l$parties == null ? null : toJson$Enum$SortOrder(l$parties);
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : toJson$Enum$SortOrder(l$confirmationStatus);
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestOrderByWithRelationInput<
          Input$GuestOrderByWithRelationInput>
      get copyWith => CopyWith$Input$GuestOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$GuestOrderByWithRelationInput(
    Input$GuestOrderByWithRelationInput instance,
    TRes Function(Input$GuestOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$GuestOrderByWithRelationInput;

  factory CopyWith$Input$GuestOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? userId,
    Input$SortOrderInput? category1,
    Input$SortOrderInput? category2,
    Input$SortOrderInput? personInCharge,
    Input$SortOrderInput? $class,
    Input$SortOrderInput? seat,
    Input$SortOrderInput? rejectionReason,
    Input$SortOrderInput? description,
    Enum$SortOrder? parties,
    Enum$SortOrder? confirmationStatus,
    Input$UserOrderByWithRelationInput? user,
    Input$QrCodeOrderByRelationAggregateInput? qrcodes,
    Input$EmailQueueOrderByRelationAggregateInput? emailQueue,
    Input$WhatsappQueueOrderByRelationAggregateInput? whatsappQueue,
  });
  CopyWith$Input$SortOrderInput<TRes> get category1;
  CopyWith$Input$SortOrderInput<TRes> get category2;
  CopyWith$Input$SortOrderInput<TRes> get personInCharge;
  CopyWith$Input$SortOrderInput<TRes> get $class;
  CopyWith$Input$SortOrderInput<TRes> get seat;
  CopyWith$Input$SortOrderInput<TRes> get rejectionReason;
  CopyWith$Input$SortOrderInput<TRes> get description;
  CopyWith$Input$UserOrderByWithRelationInput<TRes> get user;
  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get qrcodes;
  CopyWith$Input$EmailQueueOrderByRelationAggregateInput<TRes> get emailQueue;
  CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestOrderByWithRelationInput<TRes>
    implements CopyWith$Input$GuestOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$GuestOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$GuestOrderByWithRelationInput _instance;

  final TRes Function(Input$GuestOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestOrderByWithRelationInput._({
        ..._instance._$data,
        if (userId != _undefined) 'userId': (userId as Enum$SortOrder?),
        if (category1 != _undefined)
          'category1': (category1 as Input$SortOrderInput?),
        if (category2 != _undefined)
          'category2': (category2 as Input$SortOrderInput?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as Input$SortOrderInput?),
        if ($class != _undefined) 'class': ($class as Input$SortOrderInput?),
        if (seat != _undefined) 'seat': (seat as Input$SortOrderInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as Input$SortOrderInput?),
        if (description != _undefined)
          'description': (description as Input$SortOrderInput?),
        if (parties != _undefined) 'parties': (parties as Enum$SortOrder?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus as Enum$SortOrder?),
        if (user != _undefined)
          'user': (user as Input$UserOrderByWithRelationInput?),
        if (qrcodes != _undefined)
          'qrcodes': (qrcodes as Input$QrCodeOrderByRelationAggregateInput?),
        if (emailQueue != _undefined)
          'emailQueue':
              (emailQueue as Input$EmailQueueOrderByRelationAggregateInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$SortOrderInput<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$$class, (e) => call($class: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$UserOrderByWithRelationInput<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$UserOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$UserOrderByWithRelationInput(
            local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeOrderByRelationAggregateInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueOrderByRelationAggregateInput<TRes> get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueOrderByRelationAggregateInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestOrderByWithRelationInput<TRes>
    implements CopyWith$Input$GuestOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$GuestOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? userId,
    Input$SortOrderInput? category1,
    Input$SortOrderInput? category2,
    Input$SortOrderInput? personInCharge,
    Input$SortOrderInput? $class,
    Input$SortOrderInput? seat,
    Input$SortOrderInput? rejectionReason,
    Input$SortOrderInput? description,
    Enum$SortOrder? parties,
    Enum$SortOrder? confirmationStatus,
    Input$UserOrderByWithRelationInput? user,
    Input$QrCodeOrderByRelationAggregateInput? qrcodes,
    Input$EmailQueueOrderByRelationAggregateInput? emailQueue,
    Input$WhatsappQueueOrderByRelationAggregateInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$SortOrderInput<TRes> get category1 =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get category2 =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get personInCharge =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get $class =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get seat =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get rejectionReason =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get description =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$UserOrderByWithRelationInput<TRes> get user =>
      CopyWith$Input$UserOrderByWithRelationInput.stub(_res);
  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeOrderByRelationAggregateInput.stub(_res);
  CopyWith$Input$EmailQueueOrderByRelationAggregateInput<TRes> get emailQueue =>
      CopyWith$Input$EmailQueueOrderByRelationAggregateInput.stub(_res);
  CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput.stub(_res);
}

class Input$GuestRelationFilter {
  factory Input$GuestRelationFilter({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  }) =>
      Input$GuestRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$GuestRelationFilter._(this._$data);

  factory Input$GuestRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$GuestWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$GuestWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$GuestRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get $is => (_$data['is'] as Input$GuestWhereInput?);
  Input$GuestWhereInput? get isNot =>
      (_$data['isNot'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestRelationFilter<Input$GuestRelationFilter> get copyWith =>
      CopyWith$Input$GuestRelationFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestRelationFilter<TRes> {
  factory CopyWith$Input$GuestRelationFilter(
    Input$GuestRelationFilter instance,
    TRes Function(Input$GuestRelationFilter) then,
  ) = _CopyWithImpl$Input$GuestRelationFilter;

  factory CopyWith$Input$GuestRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestRelationFilter;

  TRes call({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  });
  CopyWith$Input$GuestWhereInput<TRes> get $is;
  CopyWith$Input$GuestWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$GuestRelationFilter<TRes>
    implements CopyWith$Input$GuestRelationFilter<TRes> {
  _CopyWithImpl$Input$GuestRelationFilter(
    this._instance,
    this._then,
  );

  final Input$GuestRelationFilter _instance;

  final TRes Function(Input$GuestRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$GuestRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$GuestWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$GuestRelationFilter<TRes>
    implements CopyWith$Input$GuestRelationFilter<TRes> {
  _CopyWithStubImpl$Input$GuestRelationFilter(this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? $is,
    Input$GuestWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get $is =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get isNot =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestSumAggregateInput {
  factory Input$GuestSumAggregateInput({bool? parties}) =>
      Input$GuestSumAggregateInput._({
        if (parties != null) r'parties': parties,
      });

  Input$GuestSumAggregateInput._(this._$data);

  factory Input$GuestSumAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = (l$parties as bool?);
    }
    return Input$GuestSumAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get parties => (_$data['parties'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties;
    }
    return result$data;
  }

  CopyWith$Input$GuestSumAggregateInput<Input$GuestSumAggregateInput>
      get copyWith => CopyWith$Input$GuestSumAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestSumAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$parties = parties;
    return Object.hashAll(
        [_$data.containsKey('parties') ? l$parties : const {}]);
  }
}

abstract class CopyWith$Input$GuestSumAggregateInput<TRes> {
  factory CopyWith$Input$GuestSumAggregateInput(
    Input$GuestSumAggregateInput instance,
    TRes Function(Input$GuestSumAggregateInput) then,
  ) = _CopyWithImpl$Input$GuestSumAggregateInput;

  factory CopyWith$Input$GuestSumAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestSumAggregateInput;

  TRes call({bool? parties});
}

class _CopyWithImpl$Input$GuestSumAggregateInput<TRes>
    implements CopyWith$Input$GuestSumAggregateInput<TRes> {
  _CopyWithImpl$Input$GuestSumAggregateInput(
    this._instance,
    this._then,
  );

  final Input$GuestSumAggregateInput _instance;

  final TRes Function(Input$GuestSumAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? parties = _undefined}) =>
      _then(Input$GuestSumAggregateInput._({
        ..._instance._$data,
        if (parties != _undefined) 'parties': (parties as bool?),
      }));
}

class _CopyWithStubImpl$Input$GuestSumAggregateInput<TRes>
    implements CopyWith$Input$GuestSumAggregateInput<TRes> {
  _CopyWithStubImpl$Input$GuestSumAggregateInput(this._res);

  TRes _res;

  call({bool? parties}) => _res;
}

class Input$GuestUpdateInput {
  factory Input$GuestUpdateInput({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  }) =>
      Input$GuestUpdateInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (user != null) r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestUpdateInput._(this._$data);

  factory Input$GuestUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$parties as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusFieldUpdateOperationsInput.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeUpdateManyWithoutGuestNestedInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueUpdateManyWithoutGuestNestedInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NullableStringFieldUpdateOperationsInput? get category1 =>
      (_$data['category1'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category2 =>
      (_$data['category2'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get personInCharge =>
      (_$data['personInCharge']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get description =>
      (_$data['description']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get parties =>
      (_$data['parties'] as Input$IntFieldUpdateOperationsInput?);
  Input$EnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? get user =>
      (_$data['user']
          as Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput?);
  Input$QrCodeUpdateManyWithoutGuestNestedInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeUpdateManyWithoutGuestNestedInput?);
  Input$EmailQueueUpdateManyWithoutGuestNestedInput? get emailQueue =>
      (_$data['emailQueue']
          as Input$EmailQueueUpdateManyWithoutGuestNestedInput?);
  Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateInput<Input$GuestUpdateInput> get copyWith =>
      CopyWith$Input$GuestUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateInput<TRes> {
  factory CopyWith$Input$GuestUpdateInput(
    Input$GuestUpdateInput instance,
    TRes Function(Input$GuestUpdateInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateInput;

  factory CopyWith$Input$GuestUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateInput;

  TRes call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  });
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties;
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user;
  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes;
  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue;
  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestUpdateInput<TRes>
    implements CopyWith$Input$GuestUpdateInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateInput _instance;

  final TRes Function(Input$GuestUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestUpdateInput._({
        ..._instance._$data,
        if (category1 != _undefined)
          'category1':
              (category1 as Input$NullableStringFieldUpdateOperationsInput?),
        if (category2 != _undefined)
          'category2':
              (category2 as Input$NullableStringFieldUpdateOperationsInput?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge
              as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$NullableStringFieldUpdateOperationsInput?),
        if (parties != _undefined)
          'parties': (parties as Input$IntFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusFieldUpdateOperationsInput?),
        if (user != _undefined)
          'user':
              (user as Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput?),
        if (qrcodes != _undefined)
          'qrcodes':
              (qrcodes as Input$QrCodeUpdateManyWithoutGuestNestedInput?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue
              as Input$EmailQueueUpdateManyWithoutGuestNestedInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties {
    final local$parties = _instance.parties;
    return local$parties == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$parties, (e) => call(parties: e));
  }

  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput(
            local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateInput<TRes>
    implements CopyWith$Input$GuestUpdateInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateInput(this._res);

  TRes _res;

  call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
              _res);
  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user =>
          CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue =>
          CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateManyMutationInput {
  factory Input$GuestUpdateManyMutationInput({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
  }) =>
      Input$GuestUpdateManyMutationInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
      });

  Input$GuestUpdateManyMutationInput._(this._$data);

  factory Input$GuestUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$parties as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusFieldUpdateOperationsInput.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    return Input$GuestUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NullableStringFieldUpdateOperationsInput? get category1 =>
      (_$data['category1'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category2 =>
      (_$data['category2'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get personInCharge =>
      (_$data['personInCharge']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get description =>
      (_$data['description']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get parties =>
      (_$data['parties'] as Input$IntFieldUpdateOperationsInput?);
  Input$EnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateManyMutationInput<
          Input$GuestUpdateManyMutationInput>
      get copyWith => CopyWith$Input$GuestUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$GuestUpdateManyMutationInput(
    Input$GuestUpdateManyMutationInput instance,
    TRes Function(Input$GuestUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateManyMutationInput;

  factory CopyWith$Input$GuestUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateManyMutationInput;

  TRes call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
  });
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties;
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
}

class _CopyWithImpl$Input$GuestUpdateManyMutationInput<TRes>
    implements CopyWith$Input$GuestUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateManyMutationInput _instance;

  final TRes Function(Input$GuestUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
  }) =>
      _then(Input$GuestUpdateManyMutationInput._({
        ..._instance._$data,
        if (category1 != _undefined)
          'category1':
              (category1 as Input$NullableStringFieldUpdateOperationsInput?),
        if (category2 != _undefined)
          'category2':
              (category2 as Input$NullableStringFieldUpdateOperationsInput?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge
              as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$NullableStringFieldUpdateOperationsInput?),
        if (parties != _undefined)
          'parties': (parties as Input$IntFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties {
    final local$parties = _instance.parties;
    return local$parties == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$parties, (e) => call(parties: e));
  }

  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateManyMutationInput<TRes>
    implements CopyWith$Input$GuestUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
  }) =>
      _res;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
              _res);
}

class Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput {
  factory Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput({
    Input$GuestCreateWithoutEmailQueueInput? create,
    Input$GuestCreateOrConnectWithoutEmailQueueInput? connectOrCreate,
    Input$GuestUpsertWithoutEmailQueueInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput? update,
  }) =>
      Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput._(this._$data);

  factory Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutEmailQueueInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutEmailQueueInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$GuestUpsertWithoutEmailQueueInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutEmailQueueInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutEmailQueueInput?);
  Input$GuestCreateOrConnectWithoutEmailQueueInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutEmailQueueInput?);
  Input$GuestUpsertWithoutEmailQueueInput? get upsert =>
      (_$data['upsert'] as Input$GuestUpsertWithoutEmailQueueInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput? get update =>
      (_$data['update']
          as Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<
          Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput(
    Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput instance,
    TRes Function(Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput;

  factory CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput;

  TRes call({
    Input$GuestCreateWithoutEmailQueueInput? create,
    Input$GuestCreateOrConnectWithoutEmailQueueInput? connectOrCreate,
    Input$GuestUpsertWithoutEmailQueueInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput? update,
  });
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestUpsertWithoutEmailQueueInput<TRes> get upsert;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<TRes>
      get update;
}

class _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput _instance;

  final TRes Function(Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutEmailQueueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutEmailQueueInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$GuestUpsertWithoutEmailQueueInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
        if (update != _undefined)
          'update': (update
              as Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutEmailQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutEmailQueueInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestUpsertWithoutEmailQueueInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$GuestUpsertWithoutEmailQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpsertWithoutEmailQueueInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutEmailQueueNestedInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutEmailQueueInput? create,
    Input$GuestCreateOrConnectWithoutEmailQueueInput? connectOrCreate,
    Input$GuestUpsertWithoutEmailQueueInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput? update,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutEmailQueueInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutEmailQueueInput.stub(_res);
  CopyWith$Input$GuestUpsertWithoutEmailQueueInput<TRes> get upsert =>
      CopyWith$Input$GuestUpsertWithoutEmailQueueInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<TRes>
      get update =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput.stub(
              _res);
}

class Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput {
  factory Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput({
    Input$GuestCreateWithoutQrcodesInput? create,
    Input$GuestCreateOrConnectWithoutQrcodesInput? connectOrCreate,
    Input$GuestUpsertWithoutQrcodesInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutQrcodesInput? update,
  }) =>
      Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput._(this._$data);

  factory Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutQrcodesInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutQrcodesInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$GuestUpsertWithoutQrcodesInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$GuestUpdateToOneWithWhereWithoutQrcodesInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutQrcodesInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutQrcodesInput?);
  Input$GuestCreateOrConnectWithoutQrcodesInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutQrcodesInput?);
  Input$GuestUpsertWithoutQrcodesInput? get upsert =>
      (_$data['upsert'] as Input$GuestUpsertWithoutQrcodesInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Input$GuestUpdateToOneWithWhereWithoutQrcodesInput? get update =>
      (_$data['update'] as Input$GuestUpdateToOneWithWhereWithoutQrcodesInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<
          Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput(
    Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput instance,
    TRes Function(Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput;

  factory CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput;

  TRes call({
    Input$GuestCreateWithoutQrcodesInput? create,
    Input$GuestCreateOrConnectWithoutQrcodesInput? connectOrCreate,
    Input$GuestUpsertWithoutQrcodesInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutQrcodesInput? update,
  });
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestUpsertWithoutQrcodesInput<TRes> get upsert;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<TRes> get update;
}

class _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput _instance;

  final TRes Function(Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutQrcodesInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutQrcodesInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$GuestUpsertWithoutQrcodesInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$GuestUpdateToOneWithWhereWithoutQrcodesInput?),
      }));
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutQrcodesInput.stub(_then(_instance))
        : CopyWith$Input$GuestCreateWithoutQrcodesInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestUpsertWithoutQrcodesInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$GuestUpsertWithoutQrcodesInput.stub(_then(_instance))
        : CopyWith$Input$GuestUpsertWithoutQrcodesInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutQrcodesInput? create,
    Input$GuestCreateOrConnectWithoutQrcodesInput? connectOrCreate,
    Input$GuestUpsertWithoutQrcodesInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutQrcodesInput? update,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutQrcodesInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutQrcodesInput.stub(_res);
  CopyWith$Input$GuestUpsertWithoutQrcodesInput<TRes> get upsert =>
      CopyWith$Input$GuestUpsertWithoutQrcodesInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<TRes>
      get update =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput.stub(
              _res);
}

class Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput {
  factory Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput({
    Input$GuestCreateWithoutWhatsappQueueInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappQueueInput? connectOrCreate,
    Input$GuestUpsertWithoutWhatsappQueueInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput? update,
  }) =>
      Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput._(this._$data);

  factory Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutWhatsappQueueInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutWhatsappQueueInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$GuestUpsertWithoutWhatsappQueueInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutWhatsappQueueInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutWhatsappQueueInput?);
  Input$GuestCreateOrConnectWithoutWhatsappQueueInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutWhatsappQueueInput?);
  Input$GuestUpsertWithoutWhatsappQueueInput? get upsert =>
      (_$data['upsert'] as Input$GuestUpsertWithoutWhatsappQueueInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput? get update =>
      (_$data['update']
          as Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<
          Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput(
    Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput instance,
    TRes Function(Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput;

  factory CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput;

  TRes call({
    Input$GuestCreateWithoutWhatsappQueueInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappQueueInput? connectOrCreate,
    Input$GuestUpsertWithoutWhatsappQueueInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput? update,
  });
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes>
      get connectOrCreate;
  CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput<TRes> get upsert;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<TRes>
      get update;
}

class _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput _instance;

  final TRes Function(
      Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutWhatsappQueueInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$GuestCreateOrConnectWithoutWhatsappQueueInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$GuestUpsertWithoutWhatsappQueueInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
        if (update != _undefined)
          'update': (update
              as Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput?),
      }));
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutWhatsappQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateWithoutWhatsappQueueInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput
            .stub(_then(_instance))
        : CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput(
      this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutWhatsappQueueInput? create,
    Input$GuestCreateOrConnectWithoutWhatsappQueueInput? connectOrCreate,
    Input$GuestUpsertWithoutWhatsappQueueInput? upsert,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput? update,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutWhatsappQueueInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutWhatsappQueueInput.stub(
              _res);
  CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput<TRes> get upsert =>
      CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<TRes>
      get update =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput
              .stub(_res);
}

class Input$GuestUpdateOneWithoutUserNestedInput {
  factory Input$GuestUpdateOneWithoutUserNestedInput({
    Input$GuestCreateWithoutUserInput? create,
    Input$GuestCreateOrConnectWithoutUserInput? connectOrCreate,
    Input$GuestUpsertWithoutUserInput? upsert,
    Input$GuestWhereInput? disconnect,
    Input$GuestWhereInput? delete,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutUserInput? update,
  }) =>
      Input$GuestUpdateOneWithoutUserNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$GuestUpdateOneWithoutUserNestedInput._(this._$data);

  factory Input$GuestUpdateOneWithoutUserNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$GuestCreateWithoutUserInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$GuestCreateOrConnectWithoutUserInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$GuestUpsertWithoutUserInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$GuestWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$GuestWhereInput.fromJson((l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$GuestWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$GuestUpdateToOneWithWhereWithoutUserInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$GuestUpdateOneWithoutUserNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestCreateWithoutUserInput? get create =>
      (_$data['create'] as Input$GuestCreateWithoutUserInput?);
  Input$GuestCreateOrConnectWithoutUserInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$GuestCreateOrConnectWithoutUserInput?);
  Input$GuestUpsertWithoutUserInput? get upsert =>
      (_$data['upsert'] as Input$GuestUpsertWithoutUserInput?);
  Input$GuestWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$GuestWhereInput?);
  Input$GuestWhereInput? get delete =>
      (_$data['delete'] as Input$GuestWhereInput?);
  Input$GuestWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$GuestWhereUniqueInput?);
  Input$GuestUpdateToOneWithWhereWithoutUserInput? get update =>
      (_$data['update'] as Input$GuestUpdateToOneWithWhereWithoutUserInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<
          Input$GuestUpdateOneWithoutUserNestedInput>
      get copyWith => CopyWith$Input$GuestUpdateOneWithoutUserNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateOneWithoutUserNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> {
  factory CopyWith$Input$GuestUpdateOneWithoutUserNestedInput(
    Input$GuestUpdateOneWithoutUserNestedInput instance,
    TRes Function(Input$GuestUpdateOneWithoutUserNestedInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateOneWithoutUserNestedInput;

  factory CopyWith$Input$GuestUpdateOneWithoutUserNestedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateOneWithoutUserNestedInput;

  TRes call({
    Input$GuestCreateWithoutUserInput? create,
    Input$GuestCreateOrConnectWithoutUserInput? connectOrCreate,
    Input$GuestUpsertWithoutUserInput? upsert,
    Input$GuestWhereInput? disconnect,
    Input$GuestWhereInput? delete,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutUserInput? update,
  });
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create;
  CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes> get connectOrCreate;
  CopyWith$Input$GuestUpsertWithoutUserInput<TRes> get upsert;
  CopyWith$Input$GuestWhereInput<TRes> get disconnect;
  CopyWith$Input$GuestWhereInput<TRes> get delete;
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect;
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput<TRes> get update;
}

class _CopyWithImpl$Input$GuestUpdateOneWithoutUserNestedInput<TRes>
    implements CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateOneWithoutUserNestedInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateOneWithoutUserNestedInput _instance;

  final TRes Function(Input$GuestUpdateOneWithoutUserNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$GuestUpdateOneWithoutUserNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$GuestCreateWithoutUserInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate':
              (connectOrCreate as Input$GuestCreateOrConnectWithoutUserInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$GuestUpsertWithoutUserInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$GuestWhereInput?),
        if (delete != _undefined) 'delete': (delete as Input$GuestWhereInput?),
        if (connect != _undefined)
          'connect': (connect as Input$GuestWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$GuestUpdateToOneWithWhereWithoutUserInput?),
      }));
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$GuestCreateWithoutUserInput.stub(_then(_instance))
        : CopyWith$Input$GuestCreateWithoutUserInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$GuestCreateOrConnectWithoutUserInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateOrConnectWithoutUserInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$GuestUpsertWithoutUserInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$GuestUpsertWithoutUserInput.stub(_then(_instance))
        : CopyWith$Input$GuestUpsertWithoutUserInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$GuestWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateOneWithoutUserNestedInput<TRes>
    implements CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateOneWithoutUserNestedInput(this._res);

  TRes _res;

  call({
    Input$GuestCreateWithoutUserInput? create,
    Input$GuestCreateOrConnectWithoutUserInput? connectOrCreate,
    Input$GuestUpsertWithoutUserInput? upsert,
    Input$GuestWhereInput? disconnect,
    Input$GuestWhereInput? delete,
    Input$GuestWhereUniqueInput? connect,
    Input$GuestUpdateToOneWithWhereWithoutUserInput? update,
  }) =>
      _res;
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutUserInput.stub(_res);
  CopyWith$Input$GuestCreateOrConnectWithoutUserInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$GuestCreateOrConnectWithoutUserInput.stub(_res);
  CopyWith$Input$GuestUpsertWithoutUserInput<TRes> get upsert =>
      CopyWith$Input$GuestUpsertWithoutUserInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get disconnect =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get delete =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$GuestWhereUniqueInput.stub(_res);
  CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput<TRes> get update =>
      CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput.stub(_res);
}

class Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput {
  factory Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput({
    Input$GuestWhereInput? where,
    required Input$GuestUpdateWithoutEmailQueueInput data,
  }) =>
      Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput._(this._$data);

  factory Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateWithoutEmailQueueInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Input$GuestUpdateWithoutEmailQueueInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutEmailQueueInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<
          Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput(
    Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput instance,
    TRes Function(Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput;

  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput;

  TRes call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutEmailQueueInput? data,
  });
  CopyWith$Input$GuestWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput _instance;

  final TRes Function(Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutEmailQueueInput),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutEmailQueueInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutEmailQueueInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutEmailQueueInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutEmailQueueInput.stub(_res);
}

class Input$GuestUpdateToOneWithWhereWithoutQrcodesInput {
  factory Input$GuestUpdateToOneWithWhereWithoutQrcodesInput({
    Input$GuestWhereInput? where,
    required Input$GuestUpdateWithoutQrcodesInput data,
  }) =>
      Input$GuestUpdateToOneWithWhereWithoutQrcodesInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$GuestUpdateToOneWithWhereWithoutQrcodesInput._(this._$data);

  factory Input$GuestUpdateToOneWithWhereWithoutQrcodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateWithoutQrcodesInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateToOneWithWhereWithoutQrcodesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Input$GuestUpdateWithoutQrcodesInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutQrcodesInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<
          Input$GuestUpdateToOneWithWhereWithoutQrcodesInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateToOneWithWhereWithoutQrcodesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput(
    Input$GuestUpdateToOneWithWhereWithoutQrcodesInput instance,
    TRes Function(Input$GuestUpdateToOneWithWhereWithoutQrcodesInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput;

  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput;

  TRes call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutQrcodesInput? data,
  });
  CopyWith$Input$GuestWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateToOneWithWhereWithoutQrcodesInput _instance;

  final TRes Function(Input$GuestUpdateToOneWithWhereWithoutQrcodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateToOneWithWhereWithoutQrcodesInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutQrcodesInput),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutQrcodesInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutQrcodesInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutQrcodesInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutQrcodesInput.stub(_res);
}

class Input$GuestUpdateToOneWithWhereWithoutUserInput {
  factory Input$GuestUpdateToOneWithWhereWithoutUserInput({
    Input$GuestWhereInput? where,
    required Input$GuestUpdateWithoutUserInput data,
  }) =>
      Input$GuestUpdateToOneWithWhereWithoutUserInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$GuestUpdateToOneWithWhereWithoutUserInput._(this._$data);

  factory Input$GuestUpdateToOneWithWhereWithoutUserInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateWithoutUserInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateToOneWithWhereWithoutUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Input$GuestUpdateWithoutUserInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutUserInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput<
          Input$GuestUpdateToOneWithWhereWithoutUserInput>
      get copyWith => CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateToOneWithWhereWithoutUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput<TRes> {
  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput(
    Input$GuestUpdateToOneWithWhereWithoutUserInput instance,
    TRes Function(Input$GuestUpdateToOneWithWhereWithoutUserInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutUserInput;

  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutUserInput;

  TRes call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutUserInput? data,
  });
  CopyWith$Input$GuestWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutUserInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutUserInput<TRes>
    implements CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutUserInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateToOneWithWhereWithoutUserInput _instance;

  final TRes Function(Input$GuestUpdateToOneWithWhereWithoutUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateToOneWithWhereWithoutUserInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutUserInput),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutUserInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutUserInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutUserInput<TRes>
    implements CopyWith$Input$GuestUpdateToOneWithWhereWithoutUserInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutUserInput(this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutUserInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutUserInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutUserInput.stub(_res);
}

class Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput {
  factory Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput({
    Input$GuestWhereInput? where,
    required Input$GuestUpdateWithoutWhatsappQueueInput data,
  }) =>
      Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput._(this._$data);

  factory Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$GuestUpdateWithoutWhatsappQueueInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Input$GuestUpdateWithoutWhatsappQueueInput get data =>
      (_$data['data'] as Input$GuestUpdateWithoutWhatsappQueueInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<
          Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput>
      get copyWith =>
          CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<
    TRes> {
  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput(
    Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput instance,
    TRes Function(Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput)
        then,
  ) = _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput;

  factory CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput;

  TRes call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutWhatsappQueueInput? data,
  });
  CopyWith$Input$GuestWhereInput<TRes> get where;
  CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> get data;
}

class _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<
            TRes> {
  _CopyWithImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput _instance;

  final TRes Function(Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$GuestUpdateWithoutWhatsappQueueInput),
      }));
  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<
        TRes>
    implements
        CopyWith$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput<
            TRes> {
  _CopyWithStubImpl$Input$GuestUpdateToOneWithWhereWithoutWhatsappQueueInput(
      this._res);

  TRes _res;

  call({
    Input$GuestWhereInput? where,
    Input$GuestUpdateWithoutWhatsappQueueInput? data,
  }) =>
      _res;
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
  CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> get data =>
      CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput.stub(_res);
}

class Input$GuestUpdateWithoutEmailQueueInput {
  factory Input$GuestUpdateWithoutEmailQueueInput({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  }) =>
      Input$GuestUpdateWithoutEmailQueueInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (user != null) r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestUpdateWithoutEmailQueueInput._(this._$data);

  factory Input$GuestUpdateWithoutEmailQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$parties as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusFieldUpdateOperationsInput.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeUpdateManyWithoutGuestNestedInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutEmailQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NullableStringFieldUpdateOperationsInput? get category1 =>
      (_$data['category1'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category2 =>
      (_$data['category2'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get personInCharge =>
      (_$data['personInCharge']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get description =>
      (_$data['description']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get parties =>
      (_$data['parties'] as Input$IntFieldUpdateOperationsInput?);
  Input$EnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? get user =>
      (_$data['user']
          as Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput?);
  Input$QrCodeUpdateManyWithoutGuestNestedInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeUpdateManyWithoutGuestNestedInput?);
  Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutEmailQueueInput<
          Input$GuestUpdateWithoutEmailQueueInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutEmailQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutEmailQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutEmailQueueInput(
    Input$GuestUpdateWithoutEmailQueueInput instance,
    TRes Function(Input$GuestUpdateWithoutEmailQueueInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutEmailQueueInput;

  factory CopyWith$Input$GuestUpdateWithoutEmailQueueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutEmailQueueInput;

  TRes call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  });
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties;
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user;
  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes;
  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestUpdateWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutEmailQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutEmailQueueInput _instance;

  final TRes Function(Input$GuestUpdateWithoutEmailQueueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutEmailQueueInput._({
        ..._instance._$data,
        if (category1 != _undefined)
          'category1':
              (category1 as Input$NullableStringFieldUpdateOperationsInput?),
        if (category2 != _undefined)
          'category2':
              (category2 as Input$NullableStringFieldUpdateOperationsInput?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge
              as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$NullableStringFieldUpdateOperationsInput?),
        if (parties != _undefined)
          'parties': (parties as Input$IntFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusFieldUpdateOperationsInput?),
        if (user != _undefined)
          'user':
              (user as Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput?),
        if (qrcodes != _undefined)
          'qrcodes':
              (qrcodes as Input$QrCodeUpdateManyWithoutGuestNestedInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties {
    final local$parties = _instance.parties;
    return local$parties == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$parties, (e) => call(parties: e));
  }

  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput(
            local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutEmailQueueInput(this._res);

  TRes _res;

  call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
              _res);
  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user =>
          CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateWithoutQrcodesInput {
  factory Input$GuestUpdateWithoutQrcodesInput({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  }) =>
      Input$GuestUpdateWithoutQrcodesInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (user != null) r'user': user,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestUpdateWithoutQrcodesInput._(this._$data);

  factory Input$GuestUpdateWithoutQrcodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$parties as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusFieldUpdateOperationsInput.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueUpdateManyWithoutGuestNestedInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutQrcodesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NullableStringFieldUpdateOperationsInput? get category1 =>
      (_$data['category1'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category2 =>
      (_$data['category2'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get personInCharge =>
      (_$data['personInCharge']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get description =>
      (_$data['description']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get parties =>
      (_$data['parties'] as Input$IntFieldUpdateOperationsInput?);
  Input$EnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? get user =>
      (_$data['user']
          as Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput?);
  Input$EmailQueueUpdateManyWithoutGuestNestedInput? get emailQueue =>
      (_$data['emailQueue']
          as Input$EmailQueueUpdateManyWithoutGuestNestedInput?);
  Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutQrcodesInput<
          Input$GuestUpdateWithoutQrcodesInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutQrcodesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutQrcodesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutQrcodesInput(
    Input$GuestUpdateWithoutQrcodesInput instance,
    TRes Function(Input$GuestUpdateWithoutQrcodesInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutQrcodesInput;

  factory CopyWith$Input$GuestUpdateWithoutQrcodesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutQrcodesInput;

  TRes call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  });
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties;
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user;
  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue;
  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestUpdateWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutQrcodesInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutQrcodesInput _instance;

  final TRes Function(Input$GuestUpdateWithoutQrcodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutQrcodesInput._({
        ..._instance._$data,
        if (category1 != _undefined)
          'category1':
              (category1 as Input$NullableStringFieldUpdateOperationsInput?),
        if (category2 != _undefined)
          'category2':
              (category2 as Input$NullableStringFieldUpdateOperationsInput?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge
              as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$NullableStringFieldUpdateOperationsInput?),
        if (parties != _undefined)
          'parties': (parties as Input$IntFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusFieldUpdateOperationsInput?),
        if (user != _undefined)
          'user':
              (user as Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue
              as Input$EmailQueueUpdateManyWithoutGuestNestedInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties {
    final local$parties = _instance.parties;
    return local$parties == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$parties, (e) => call(parties: e));
  }

  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput(
            local$user, (e) => call(user: e));
  }

  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutQrcodesInput(this._res);

  TRes _res;

  call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
              _res);
  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user =>
          CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
              _res);
  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue =>
          CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateWithoutUserInput {
  factory Input$GuestUpdateWithoutUserInput({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  }) =>
      Input$GuestUpdateWithoutUserInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestUpdateWithoutUserInput._(this._$data);

  factory Input$GuestUpdateWithoutUserInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$parties as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusFieldUpdateOperationsInput.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeUpdateManyWithoutGuestNestedInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueUpdateManyWithoutGuestNestedInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NullableStringFieldUpdateOperationsInput? get category1 =>
      (_$data['category1'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category2 =>
      (_$data['category2'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get personInCharge =>
      (_$data['personInCharge']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get description =>
      (_$data['description']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get parties =>
      (_$data['parties'] as Input$IntFieldUpdateOperationsInput?);
  Input$EnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$QrCodeUpdateManyWithoutGuestNestedInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeUpdateManyWithoutGuestNestedInput?);
  Input$EmailQueueUpdateManyWithoutGuestNestedInput? get emailQueue =>
      (_$data['emailQueue']
          as Input$EmailQueueUpdateManyWithoutGuestNestedInput?);
  Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? get whatsappQueue =>
      (_$data['whatsappQueue']
          as Input$WhatsappQueueUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutUserInput<Input$GuestUpdateWithoutUserInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutUserInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutUserInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutUserInput(
    Input$GuestUpdateWithoutUserInput instance,
    TRes Function(Input$GuestUpdateWithoutUserInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutUserInput;

  factory CopyWith$Input$GuestUpdateWithoutUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutUserInput;

  TRes call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  });
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties;
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes;
  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue;
  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue;
}

class _CopyWithImpl$Input$GuestUpdateWithoutUserInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutUserInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutUserInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutUserInput _instance;

  final TRes Function(Input$GuestUpdateWithoutUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutUserInput._({
        ..._instance._$data,
        if (category1 != _undefined)
          'category1':
              (category1 as Input$NullableStringFieldUpdateOperationsInput?),
        if (category2 != _undefined)
          'category2':
              (category2 as Input$NullableStringFieldUpdateOperationsInput?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge
              as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$NullableStringFieldUpdateOperationsInput?),
        if (parties != _undefined)
          'parties': (parties as Input$IntFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusFieldUpdateOperationsInput?),
        if (qrcodes != _undefined)
          'qrcodes':
              (qrcodes as Input$QrCodeUpdateManyWithoutGuestNestedInput?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue
              as Input$EmailQueueUpdateManyWithoutGuestNestedInput?),
        if (whatsappQueue != _undefined)
          'whatsappQueue': (whatsappQueue
              as Input$WhatsappQueueUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties {
    final local$parties = _instance.parties;
    return local$parties == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$parties, (e) => call(parties: e));
  }

  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutUserInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutUserInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutUserInput(this._res);

  TRes _res;

  call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput? whatsappQueue,
  }) =>
      _res;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue =>
          CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
      get whatsappQueue =>
          CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
              _res);
}

class Input$GuestUpdateWithoutWhatsappQueueInput {
  factory Input$GuestUpdateWithoutWhatsappQueueInput({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
  }) =>
      Input$GuestUpdateWithoutWhatsappQueueInput._({
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (user != null) r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
      });

  Input$GuestUpdateWithoutWhatsappQueueInput._(this._$data);

  factory Input$GuestUpdateWithoutWhatsappQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$parties as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusFieldUpdateOperationsInput.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.fromJson(
              (l$user as Map<String, dynamic>));
    }
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeUpdateManyWithoutGuestNestedInput.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueUpdateManyWithoutGuestNestedInput.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    return Input$GuestUpdateWithoutWhatsappQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$NullableStringFieldUpdateOperationsInput? get category1 =>
      (_$data['category1'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get category2 =>
      (_$data['category2'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get personInCharge =>
      (_$data['personInCharge']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get $class =>
      (_$data['class'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get seat =>
      (_$data['seat'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get rejectionReason =>
      (_$data['rejectionReason']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get description =>
      (_$data['description']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get parties =>
      (_$data['parties'] as Input$IntFieldUpdateOperationsInput?);
  Input$EnumConfirmationStatusFieldUpdateOperationsInput?
      get confirmationStatus => (_$data['confirmationStatus']
          as Input$EnumConfirmationStatusFieldUpdateOperationsInput?);
  Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? get user =>
      (_$data['user']
          as Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput?);
  Input$QrCodeUpdateManyWithoutGuestNestedInput? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeUpdateManyWithoutGuestNestedInput?);
  Input$EmailQueueUpdateManyWithoutGuestNestedInput? get emailQueue =>
      (_$data['emailQueue']
          as Input$EmailQueueUpdateManyWithoutGuestNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<
          Input$GuestUpdateWithoutWhatsappQueueInput>
      get copyWith => CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpdateWithoutWhatsappQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    return Object.hashAll([
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> {
  factory CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput(
    Input$GuestUpdateWithoutWhatsappQueueInput instance,
    TRes Function(Input$GuestUpdateWithoutWhatsappQueueInput) then,
  ) = _CopyWithImpl$Input$GuestUpdateWithoutWhatsappQueueInput;

  factory CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpdateWithoutWhatsappQueueInput;

  TRes call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
  });
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties;
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus;
  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user;
  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes;
  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue;
}

class _CopyWithImpl$Input$GuestUpdateWithoutWhatsappQueueInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> {
  _CopyWithImpl$Input$GuestUpdateWithoutWhatsappQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpdateWithoutWhatsappQueueInput _instance;

  final TRes Function(Input$GuestUpdateWithoutWhatsappQueueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
  }) =>
      _then(Input$GuestUpdateWithoutWhatsappQueueInput._({
        ..._instance._$data,
        if (category1 != _undefined)
          'category1':
              (category1 as Input$NullableStringFieldUpdateOperationsInput?),
        if (category2 != _undefined)
          'category2':
              (category2 as Input$NullableStringFieldUpdateOperationsInput?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge
              as Input$NullableStringFieldUpdateOperationsInput?),
        if ($class != _undefined)
          'class': ($class as Input$NullableStringFieldUpdateOperationsInput?),
        if (seat != _undefined)
          'seat': (seat as Input$NullableStringFieldUpdateOperationsInput?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason
              as Input$NullableStringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$NullableStringFieldUpdateOperationsInput?),
        if (parties != _undefined)
          'parties': (parties as Input$IntFieldUpdateOperationsInput?),
        if (confirmationStatus != _undefined)
          'confirmationStatus': (confirmationStatus
              as Input$EnumConfirmationStatusFieldUpdateOperationsInput?),
        if (user != _undefined)
          'user':
              (user as Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput?),
        if (qrcodes != _undefined)
          'qrcodes':
              (qrcodes as Input$QrCodeUpdateManyWithoutGuestNestedInput?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue
              as Input$EmailQueueUpdateManyWithoutGuestNestedInput?),
      }));
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties {
    final local$parties = _instance.parties;
    return local$parties == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$parties, (e) => call(parties: e));
  }

  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput(
            local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput(
            local$emailQueue, (e) => call(emailQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpdateWithoutWhatsappQueueInput<TRes>
    implements CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpdateWithoutWhatsappQueueInput(this._res);

  TRes _res;

  call({
    Input$NullableStringFieldUpdateOperationsInput? category1,
    Input$NullableStringFieldUpdateOperationsInput? category2,
    Input$NullableStringFieldUpdateOperationsInput? personInCharge,
    Input$NullableStringFieldUpdateOperationsInput? $class,
    Input$NullableStringFieldUpdateOperationsInput? seat,
    Input$NullableStringFieldUpdateOperationsInput? rejectionReason,
    Input$NullableStringFieldUpdateOperationsInput? description,
    Input$IntFieldUpdateOperationsInput? parties,
    Input$EnumConfirmationStatusFieldUpdateOperationsInput? confirmationStatus,
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput? user,
    Input$QrCodeUpdateManyWithoutGuestNestedInput? qrcodes,
    Input$EmailQueueUpdateManyWithoutGuestNestedInput? emailQueue,
  }) =>
      _res;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category1 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get category2 =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get personInCharge =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get $class =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get seat =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get rejectionReason =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get description =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get parties =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput<TRes>
      get confirmationStatus =>
          CopyWith$Input$EnumConfirmationStatusFieldUpdateOperationsInput.stub(
              _res);
  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
      get user =>
          CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
              _res);
  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> get qrcodes =>
      CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(_res);
  CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput<TRes>
      get emailQueue =>
          CopyWith$Input$EmailQueueUpdateManyWithoutGuestNestedInput.stub(_res);
}

class Input$GuestUpsertWithoutEmailQueueInput {
  factory Input$GuestUpsertWithoutEmailQueueInput({
    required Input$GuestUpdateWithoutEmailQueueInput update,
    required Input$GuestCreateWithoutEmailQueueInput create,
    Input$GuestWhereInput? where,
  }) =>
      Input$GuestUpsertWithoutEmailQueueInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$GuestUpsertWithoutEmailQueueInput._(this._$data);

  factory Input$GuestUpsertWithoutEmailQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$GuestUpdateWithoutEmailQueueInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutEmailQueueInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$GuestUpsertWithoutEmailQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestUpdateWithoutEmailQueueInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutEmailQueueInput);
  Input$GuestCreateWithoutEmailQueueInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutEmailQueueInput);
  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithoutEmailQueueInput<
          Input$GuestUpsertWithoutEmailQueueInput>
      get copyWith => CopyWith$Input$GuestUpsertWithoutEmailQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithoutEmailQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithoutEmailQueueInput<TRes> {
  factory CopyWith$Input$GuestUpsertWithoutEmailQueueInput(
    Input$GuestUpsertWithoutEmailQueueInput instance,
    TRes Function(Input$GuestUpsertWithoutEmailQueueInput) then,
  ) = _CopyWithImpl$Input$GuestUpsertWithoutEmailQueueInput;

  factory CopyWith$Input$GuestUpsertWithoutEmailQueueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithoutEmailQueueInput;

  TRes call({
    Input$GuestUpdateWithoutEmailQueueInput? update,
    Input$GuestCreateWithoutEmailQueueInput? create,
    Input$GuestWhereInput? where,
  });
  CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create;
  CopyWith$Input$GuestWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$GuestUpsertWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutEmailQueueInput<TRes> {
  _CopyWithImpl$Input$GuestUpsertWithoutEmailQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithoutEmailQueueInput _instance;

  final TRes Function(Input$GuestUpsertWithoutEmailQueueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$GuestUpsertWithoutEmailQueueInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutEmailQueueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutEmailQueueInput),
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutEmailQueueInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutEmailQueueInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithoutEmailQueueInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutEmailQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithoutEmailQueueInput(this._res);

  TRes _res;

  call({
    Input$GuestUpdateWithoutEmailQueueInput? update,
    Input$GuestCreateWithoutEmailQueueInput? create,
    Input$GuestWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$GuestUpdateWithoutEmailQueueInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutEmailQueueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutEmailQueueInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutEmailQueueInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestUpsertWithoutQrcodesInput {
  factory Input$GuestUpsertWithoutQrcodesInput({
    required Input$GuestUpdateWithoutQrcodesInput update,
    required Input$GuestCreateWithoutQrcodesInput create,
    Input$GuestWhereInput? where,
  }) =>
      Input$GuestUpsertWithoutQrcodesInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$GuestUpsertWithoutQrcodesInput._(this._$data);

  factory Input$GuestUpsertWithoutQrcodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$GuestUpdateWithoutQrcodesInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutQrcodesInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$GuestUpsertWithoutQrcodesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestUpdateWithoutQrcodesInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutQrcodesInput);
  Input$GuestCreateWithoutQrcodesInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutQrcodesInput);
  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithoutQrcodesInput<
          Input$GuestUpsertWithoutQrcodesInput>
      get copyWith => CopyWith$Input$GuestUpsertWithoutQrcodesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithoutQrcodesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithoutQrcodesInput<TRes> {
  factory CopyWith$Input$GuestUpsertWithoutQrcodesInput(
    Input$GuestUpsertWithoutQrcodesInput instance,
    TRes Function(Input$GuestUpsertWithoutQrcodesInput) then,
  ) = _CopyWithImpl$Input$GuestUpsertWithoutQrcodesInput;

  factory CopyWith$Input$GuestUpsertWithoutQrcodesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithoutQrcodesInput;

  TRes call({
    Input$GuestUpdateWithoutQrcodesInput? update,
    Input$GuestCreateWithoutQrcodesInput? create,
    Input$GuestWhereInput? where,
  });
  CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create;
  CopyWith$Input$GuestWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$GuestUpsertWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutQrcodesInput<TRes> {
  _CopyWithImpl$Input$GuestUpsertWithoutQrcodesInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithoutQrcodesInput _instance;

  final TRes Function(Input$GuestUpsertWithoutQrcodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$GuestUpsertWithoutQrcodesInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutQrcodesInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutQrcodesInput),
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutQrcodesInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutQrcodesInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithoutQrcodesInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutQrcodesInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithoutQrcodesInput(this._res);

  TRes _res;

  call({
    Input$GuestUpdateWithoutQrcodesInput? update,
    Input$GuestCreateWithoutQrcodesInput? create,
    Input$GuestWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$GuestUpdateWithoutQrcodesInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutQrcodesInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutQrcodesInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutQrcodesInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestUpsertWithoutUserInput {
  factory Input$GuestUpsertWithoutUserInput({
    required Input$GuestUpdateWithoutUserInput update,
    required Input$GuestCreateWithoutUserInput create,
    Input$GuestWhereInput? where,
  }) =>
      Input$GuestUpsertWithoutUserInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$GuestUpsertWithoutUserInput._(this._$data);

  factory Input$GuestUpsertWithoutUserInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$GuestUpdateWithoutUserInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutUserInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$GuestUpsertWithoutUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestUpdateWithoutUserInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutUserInput);
  Input$GuestCreateWithoutUserInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutUserInput);
  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithoutUserInput<Input$GuestUpsertWithoutUserInput>
      get copyWith => CopyWith$Input$GuestUpsertWithoutUserInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithoutUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithoutUserInput<TRes> {
  factory CopyWith$Input$GuestUpsertWithoutUserInput(
    Input$GuestUpsertWithoutUserInput instance,
    TRes Function(Input$GuestUpsertWithoutUserInput) then,
  ) = _CopyWithImpl$Input$GuestUpsertWithoutUserInput;

  factory CopyWith$Input$GuestUpsertWithoutUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithoutUserInput;

  TRes call({
    Input$GuestUpdateWithoutUserInput? update,
    Input$GuestCreateWithoutUserInput? create,
    Input$GuestWhereInput? where,
  });
  CopyWith$Input$GuestUpdateWithoutUserInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create;
  CopyWith$Input$GuestWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$GuestUpsertWithoutUserInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutUserInput<TRes> {
  _CopyWithImpl$Input$GuestUpsertWithoutUserInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithoutUserInput _instance;

  final TRes Function(Input$GuestUpsertWithoutUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$GuestUpsertWithoutUserInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutUserInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutUserInput),
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestUpdateWithoutUserInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutUserInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutUserInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithoutUserInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutUserInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithoutUserInput(this._res);

  TRes _res;

  call({
    Input$GuestUpdateWithoutUserInput? update,
    Input$GuestCreateWithoutUserInput? create,
    Input$GuestWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$GuestUpdateWithoutUserInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutUserInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutUserInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutUserInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestUpsertWithoutWhatsappQueueInput {
  factory Input$GuestUpsertWithoutWhatsappQueueInput({
    required Input$GuestUpdateWithoutWhatsappQueueInput update,
    required Input$GuestCreateWithoutWhatsappQueueInput create,
    Input$GuestWhereInput? where,
  }) =>
      Input$GuestUpsertWithoutWhatsappQueueInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$GuestUpsertWithoutWhatsappQueueInput._(this._$data);

  factory Input$GuestUpsertWithoutWhatsappQueueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$GuestUpdateWithoutWhatsappQueueInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$GuestCreateWithoutWhatsappQueueInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$GuestWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$GuestUpsertWithoutWhatsappQueueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$GuestUpdateWithoutWhatsappQueueInput get update =>
      (_$data['update'] as Input$GuestUpdateWithoutWhatsappQueueInput);
  Input$GuestCreateWithoutWhatsappQueueInput get create =>
      (_$data['create'] as Input$GuestCreateWithoutWhatsappQueueInput);
  Input$GuestWhereInput? get where =>
      (_$data['where'] as Input$GuestWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput<
          Input$GuestUpsertWithoutWhatsappQueueInput>
      get copyWith => CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestUpsertWithoutWhatsappQueueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput<TRes> {
  factory CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput(
    Input$GuestUpsertWithoutWhatsappQueueInput instance,
    TRes Function(Input$GuestUpsertWithoutWhatsappQueueInput) then,
  ) = _CopyWithImpl$Input$GuestUpsertWithoutWhatsappQueueInput;

  factory CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestUpsertWithoutWhatsappQueueInput;

  TRes call({
    Input$GuestUpdateWithoutWhatsappQueueInput? update,
    Input$GuestCreateWithoutWhatsappQueueInput? create,
    Input$GuestWhereInput? where,
  });
  CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> get update;
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create;
  CopyWith$Input$GuestWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$GuestUpsertWithoutWhatsappQueueInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput<TRes> {
  _CopyWithImpl$Input$GuestUpsertWithoutWhatsappQueueInput(
    this._instance,
    this._then,
  );

  final Input$GuestUpsertWithoutWhatsappQueueInput _instance;

  final TRes Function(Input$GuestUpsertWithoutWhatsappQueueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$GuestUpsertWithoutWhatsappQueueInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$GuestUpdateWithoutWhatsappQueueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$GuestCreateWithoutWhatsappQueueInput),
        if (where != _undefined) 'where': (where as Input$GuestWhereInput?),
      }));
  CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$GuestCreateWithoutWhatsappQueueInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$GuestWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$GuestWhereInput.stub(_then(_instance))
        : CopyWith$Input$GuestWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$GuestUpsertWithoutWhatsappQueueInput<TRes>
    implements CopyWith$Input$GuestUpsertWithoutWhatsappQueueInput<TRes> {
  _CopyWithStubImpl$Input$GuestUpsertWithoutWhatsappQueueInput(this._res);

  TRes _res;

  call({
    Input$GuestUpdateWithoutWhatsappQueueInput? update,
    Input$GuestCreateWithoutWhatsappQueueInput? create,
    Input$GuestWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput<TRes> get update =>
      CopyWith$Input$GuestUpdateWithoutWhatsappQueueInput.stub(_res);
  CopyWith$Input$GuestCreateWithoutWhatsappQueueInput<TRes> get create =>
      CopyWith$Input$GuestCreateWithoutWhatsappQueueInput.stub(_res);
  CopyWith$Input$GuestWhereInput<TRes> get where =>
      CopyWith$Input$GuestWhereInput.stub(_res);
}

class Input$GuestWhereInput {
  factory Input$GuestWhereInput({
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringFilter? userId,
    Input$StringNullableFilter? category1,
    Input$StringNullableFilter? category2,
    Input$StringNullableFilter? personInCharge,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? rejectionReason,
    Input$StringNullableFilter? description,
    Input$IntFilter? parties,
    Input$EnumConfirmationStatusFilter? confirmationStatus,
    Input$UserRelationFilter? user,
    Input$QrCodeListRelationFilter? qrcodes,
    Input$EmailQueueListRelationFilter? emailQueue,
    Input$WhatsappQueueListRelationFilter? whatsappQueue,
  }) =>
      Input$GuestWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (userId != null) r'userId': userId,
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (user != null) r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestWhereInput._(this._$data);

  factory Input$GuestWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = l$userId == null
          ? null
          : Input$StringFilter.fromJson((l$userId as Map<String, dynamic>));
    }
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : Input$IntFilter.fromJson((l$parties as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusFilter.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$UserRelationFilter.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeListRelationFilter.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueListRelationFilter.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueListRelationFilter.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$GuestWhereInput>? get AND =>
      (_$data['AND'] as List<Input$GuestWhereInput>?);
  List<Input$GuestWhereInput>? get OR =>
      (_$data['OR'] as List<Input$GuestWhereInput>?);
  List<Input$GuestWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$GuestWhereInput>?);
  Input$StringFilter? get userId => (_$data['userId'] as Input$StringFilter?);
  Input$StringNullableFilter? get category1 =>
      (_$data['category1'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get category2 =>
      (_$data['category2'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get personInCharge =>
      (_$data['personInCharge'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get $class =>
      (_$data['class'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get seat =>
      (_$data['seat'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get rejectionReason =>
      (_$data['rejectionReason'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get description =>
      (_$data['description'] as Input$StringNullableFilter?);
  Input$IntFilter? get parties => (_$data['parties'] as Input$IntFilter?);
  Input$EnumConfirmationStatusFilter? get confirmationStatus =>
      (_$data['confirmationStatus'] as Input$EnumConfirmationStatusFilter?);
  Input$UserRelationFilter? get user =>
      (_$data['user'] as Input$UserRelationFilter?);
  Input$QrCodeListRelationFilter? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeListRelationFilter?);
  Input$EmailQueueListRelationFilter? get emailQueue =>
      (_$data['emailQueue'] as Input$EmailQueueListRelationFilter?);
  Input$WhatsappQueueListRelationFilter? get whatsappQueue =>
      (_$data['whatsappQueue'] as Input$WhatsappQueueListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId?.toJson();
    }
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestWhereInput<Input$GuestWhereInput> get copyWith =>
      CopyWith$Input$GuestWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestWhereInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$userId = userId;
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestWhereInput<TRes> {
  factory CopyWith$Input$GuestWhereInput(
    Input$GuestWhereInput instance,
    TRes Function(Input$GuestWhereInput) then,
  ) = _CopyWithImpl$Input$GuestWhereInput;

  factory CopyWith$Input$GuestWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestWhereInput;

  TRes call({
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringFilter? userId,
    Input$StringNullableFilter? category1,
    Input$StringNullableFilter? category2,
    Input$StringNullableFilter? personInCharge,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? rejectionReason,
    Input$StringNullableFilter? description,
    Input$IntFilter? parties,
    Input$EnumConfirmationStatusFilter? confirmationStatus,
    Input$UserRelationFilter? user,
    Input$QrCodeListRelationFilter? qrcodes,
    Input$EmailQueueListRelationFilter? emailQueue,
    Input$WhatsappQueueListRelationFilter? whatsappQueue,
  });
  TRes AND(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get userId;
  CopyWith$Input$StringNullableFilter<TRes> get category1;
  CopyWith$Input$StringNullableFilter<TRes> get category2;
  CopyWith$Input$StringNullableFilter<TRes> get personInCharge;
  CopyWith$Input$StringNullableFilter<TRes> get $class;
  CopyWith$Input$StringNullableFilter<TRes> get seat;
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason;
  CopyWith$Input$StringNullableFilter<TRes> get description;
  CopyWith$Input$IntFilter<TRes> get parties;
  CopyWith$Input$EnumConfirmationStatusFilter<TRes> get confirmationStatus;
  CopyWith$Input$UserRelationFilter<TRes> get user;
  CopyWith$Input$QrCodeListRelationFilter<TRes> get qrcodes;
  CopyWith$Input$EmailQueueListRelationFilter<TRes> get emailQueue;
  CopyWith$Input$WhatsappQueueListRelationFilter<TRes> get whatsappQueue;
}

class _CopyWithImpl$Input$GuestWhereInput<TRes>
    implements CopyWith$Input$GuestWhereInput<TRes> {
  _CopyWithImpl$Input$GuestWhereInput(
    this._instance,
    this._then,
  );

  final Input$GuestWhereInput _instance;

  final TRes Function(Input$GuestWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? userId = _undefined,
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$GuestWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$GuestWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$GuestWhereInput>?),
        if (userId != _undefined) 'userId': (userId as Input$StringFilter?),
        if (category1 != _undefined)
          'category1': (category1 as Input$StringNullableFilter?),
        if (category2 != _undefined)
          'category2': (category2 as Input$StringNullableFilter?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as Input$StringNullableFilter?),
        if ($class != _undefined)
          'class': ($class as Input$StringNullableFilter?),
        if (seat != _undefined) 'seat': (seat as Input$StringNullableFilter?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as Input$StringNullableFilter?),
        if (description != _undefined)
          'description': (description as Input$StringNullableFilter?),
        if (parties != _undefined) 'parties': (parties as Input$IntFilter?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Input$EnumConfirmationStatusFilter?),
        if (user != _undefined) 'user': (user as Input$UserRelationFilter?),
        if (qrcodes != _undefined)
          'qrcodes': (qrcodes as Input$QrCodeListRelationFilter?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue as Input$EmailQueueListRelationFilter?),
        if (whatsappQueue != _undefined)
          'whatsappQueue':
              (whatsappQueue as Input$WhatsappQueueListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get userId {
    final local$userId = _instance.userId;
    return local$userId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$userId, (e) => call(userId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$IntFilter<TRes> get parties {
    final local$parties = _instance.parties;
    return local$parties == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$parties, (e) => call(parties: e));
  }

  CopyWith$Input$EnumConfirmationStatusFilter<TRes> get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumConfirmationStatusFilter(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$UserRelationFilter<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$UserRelationFilter.stub(_then(_instance))
        : CopyWith$Input$UserRelationFilter(local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeListRelationFilter<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$QrCodeListRelationFilter(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueListRelationFilter<TRes> get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$EmailQueueListRelationFilter(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueListRelationFilter<TRes> get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$WhatsappQueueListRelationFilter(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestWhereInput<TRes>
    implements CopyWith$Input$GuestWhereInput<TRes> {
  _CopyWithStubImpl$Input$GuestWhereInput(this._res);

  TRes _res;

  call({
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringFilter? userId,
    Input$StringNullableFilter? category1,
    Input$StringNullableFilter? category2,
    Input$StringNullableFilter? personInCharge,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? rejectionReason,
    Input$StringNullableFilter? description,
    Input$IntFilter? parties,
    Input$EnumConfirmationStatusFilter? confirmationStatus,
    Input$UserRelationFilter? user,
    Input$QrCodeListRelationFilter? qrcodes,
    Input$EmailQueueListRelationFilter? emailQueue,
    Input$WhatsappQueueListRelationFilter? whatsappQueue,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get userId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get category1 =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get category2 =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get personInCharge =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get $class =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get seat =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get description =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get parties =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$EnumConfirmationStatusFilter<TRes> get confirmationStatus =>
      CopyWith$Input$EnumConfirmationStatusFilter.stub(_res);
  CopyWith$Input$UserRelationFilter<TRes> get user =>
      CopyWith$Input$UserRelationFilter.stub(_res);
  CopyWith$Input$QrCodeListRelationFilter<TRes> get qrcodes =>
      CopyWith$Input$QrCodeListRelationFilter.stub(_res);
  CopyWith$Input$EmailQueueListRelationFilter<TRes> get emailQueue =>
      CopyWith$Input$EmailQueueListRelationFilter.stub(_res);
  CopyWith$Input$WhatsappQueueListRelationFilter<TRes> get whatsappQueue =>
      CopyWith$Input$WhatsappQueueListRelationFilter.stub(_res);
}

class Input$GuestWhereUniqueInput {
  factory Input$GuestWhereUniqueInput({
    String? userId,
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringNullableFilter? category1,
    Input$StringNullableFilter? category2,
    Input$StringNullableFilter? personInCharge,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? rejectionReason,
    Input$StringNullableFilter? description,
    Input$IntFilter? parties,
    Input$EnumConfirmationStatusFilter? confirmationStatus,
    Input$UserRelationFilter? user,
    Input$QrCodeListRelationFilter? qrcodes,
    Input$EmailQueueListRelationFilter? emailQueue,
    Input$WhatsappQueueListRelationFilter? whatsappQueue,
  }) =>
      Input$GuestWhereUniqueInput._({
        if (userId != null) r'userId': userId,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (category1 != null) r'category1': category1,
        if (category2 != null) r'category2': category2,
        if (personInCharge != null) r'personInCharge': personInCharge,
        if ($class != null) r'class': $class,
        if (seat != null) r'seat': seat,
        if (rejectionReason != null) r'rejectionReason': rejectionReason,
        if (description != null) r'description': description,
        if (parties != null) r'parties': parties,
        if (confirmationStatus != null)
          r'confirmationStatus': confirmationStatus,
        if (user != null) r'user': user,
        if (qrcodes != null) r'qrcodes': qrcodes,
        if (emailQueue != null) r'emailQueue': emailQueue,
        if (whatsappQueue != null) r'whatsappQueue': whatsappQueue,
      });

  Input$GuestWhereUniqueInput._(this._$data);

  factory Input$GuestWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('userId')) {
      final l$userId = data['userId'];
      result$data['userId'] = (l$userId as String?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$GuestWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('category1')) {
      final l$category1 = data['category1'];
      result$data['category1'] = l$category1 == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$category1 as Map<String, dynamic>));
    }
    if (data.containsKey('category2')) {
      final l$category2 = data['category2'];
      result$data['category2'] = l$category2 == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$category2 as Map<String, dynamic>));
    }
    if (data.containsKey('personInCharge')) {
      final l$personInCharge = data['personInCharge'];
      result$data['personInCharge'] = l$personInCharge == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$personInCharge as Map<String, dynamic>));
    }
    if (data.containsKey('class')) {
      final l$$class = data['class'];
      result$data['class'] = l$$class == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$$class as Map<String, dynamic>));
    }
    if (data.containsKey('seat')) {
      final l$seat = data['seat'];
      result$data['seat'] = l$seat == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$seat as Map<String, dynamic>));
    }
    if (data.containsKey('rejectionReason')) {
      final l$rejectionReason = data['rejectionReason'];
      result$data['rejectionReason'] = l$rejectionReason == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$rejectionReason as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('parties')) {
      final l$parties = data['parties'];
      result$data['parties'] = l$parties == null
          ? null
          : Input$IntFilter.fromJson((l$parties as Map<String, dynamic>));
    }
    if (data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = data['confirmationStatus'];
      result$data['confirmationStatus'] = l$confirmationStatus == null
          ? null
          : Input$EnumConfirmationStatusFilter.fromJson(
              (l$confirmationStatus as Map<String, dynamic>));
    }
    if (data.containsKey('user')) {
      final l$user = data['user'];
      result$data['user'] = l$user == null
          ? null
          : Input$UserRelationFilter.fromJson((l$user as Map<String, dynamic>));
    }
    if (data.containsKey('qrcodes')) {
      final l$qrcodes = data['qrcodes'];
      result$data['qrcodes'] = l$qrcodes == null
          ? null
          : Input$QrCodeListRelationFilter.fromJson(
              (l$qrcodes as Map<String, dynamic>));
    }
    if (data.containsKey('emailQueue')) {
      final l$emailQueue = data['emailQueue'];
      result$data['emailQueue'] = l$emailQueue == null
          ? null
          : Input$EmailQueueListRelationFilter.fromJson(
              (l$emailQueue as Map<String, dynamic>));
    }
    if (data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = data['whatsappQueue'];
      result$data['whatsappQueue'] = l$whatsappQueue == null
          ? null
          : Input$WhatsappQueueListRelationFilter.fromJson(
              (l$whatsappQueue as Map<String, dynamic>));
    }
    return Input$GuestWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get userId => (_$data['userId'] as String?);
  List<Input$GuestWhereInput>? get AND =>
      (_$data['AND'] as List<Input$GuestWhereInput>?);
  List<Input$GuestWhereInput>? get OR =>
      (_$data['OR'] as List<Input$GuestWhereInput>?);
  List<Input$GuestWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$GuestWhereInput>?);
  Input$StringNullableFilter? get category1 =>
      (_$data['category1'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get category2 =>
      (_$data['category2'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get personInCharge =>
      (_$data['personInCharge'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get $class =>
      (_$data['class'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get seat =>
      (_$data['seat'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get rejectionReason =>
      (_$data['rejectionReason'] as Input$StringNullableFilter?);
  Input$StringNullableFilter? get description =>
      (_$data['description'] as Input$StringNullableFilter?);
  Input$IntFilter? get parties => (_$data['parties'] as Input$IntFilter?);
  Input$EnumConfirmationStatusFilter? get confirmationStatus =>
      (_$data['confirmationStatus'] as Input$EnumConfirmationStatusFilter?);
  Input$UserRelationFilter? get user =>
      (_$data['user'] as Input$UserRelationFilter?);
  Input$QrCodeListRelationFilter? get qrcodes =>
      (_$data['qrcodes'] as Input$QrCodeListRelationFilter?);
  Input$EmailQueueListRelationFilter? get emailQueue =>
      (_$data['emailQueue'] as Input$EmailQueueListRelationFilter?);
  Input$WhatsappQueueListRelationFilter? get whatsappQueue =>
      (_$data['whatsappQueue'] as Input$WhatsappQueueListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('userId')) {
      final l$userId = userId;
      result$data['userId'] = l$userId;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('category1')) {
      final l$category1 = category1;
      result$data['category1'] = l$category1?.toJson();
    }
    if (_$data.containsKey('category2')) {
      final l$category2 = category2;
      result$data['category2'] = l$category2?.toJson();
    }
    if (_$data.containsKey('personInCharge')) {
      final l$personInCharge = personInCharge;
      result$data['personInCharge'] = l$personInCharge?.toJson();
    }
    if (_$data.containsKey('class')) {
      final l$$class = $class;
      result$data['class'] = l$$class?.toJson();
    }
    if (_$data.containsKey('seat')) {
      final l$seat = seat;
      result$data['seat'] = l$seat?.toJson();
    }
    if (_$data.containsKey('rejectionReason')) {
      final l$rejectionReason = rejectionReason;
      result$data['rejectionReason'] = l$rejectionReason?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('parties')) {
      final l$parties = parties;
      result$data['parties'] = l$parties?.toJson();
    }
    if (_$data.containsKey('confirmationStatus')) {
      final l$confirmationStatus = confirmationStatus;
      result$data['confirmationStatus'] = l$confirmationStatus?.toJson();
    }
    if (_$data.containsKey('user')) {
      final l$user = user;
      result$data['user'] = l$user?.toJson();
    }
    if (_$data.containsKey('qrcodes')) {
      final l$qrcodes = qrcodes;
      result$data['qrcodes'] = l$qrcodes?.toJson();
    }
    if (_$data.containsKey('emailQueue')) {
      final l$emailQueue = emailQueue;
      result$data['emailQueue'] = l$emailQueue?.toJson();
    }
    if (_$data.containsKey('whatsappQueue')) {
      final l$whatsappQueue = whatsappQueue;
      result$data['whatsappQueue'] = l$whatsappQueue?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$GuestWhereUniqueInput<Input$GuestWhereUniqueInput>
      get copyWith => CopyWith$Input$GuestWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GuestWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (_$data.containsKey('userId') != other._$data.containsKey('userId')) {
      return false;
    }
    if (l$userId != lOther$userId) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$category1 = category1;
    final lOther$category1 = other.category1;
    if (_$data.containsKey('category1') !=
        other._$data.containsKey('category1')) {
      return false;
    }
    if (l$category1 != lOther$category1) {
      return false;
    }
    final l$category2 = category2;
    final lOther$category2 = other.category2;
    if (_$data.containsKey('category2') !=
        other._$data.containsKey('category2')) {
      return false;
    }
    if (l$category2 != lOther$category2) {
      return false;
    }
    final l$personInCharge = personInCharge;
    final lOther$personInCharge = other.personInCharge;
    if (_$data.containsKey('personInCharge') !=
        other._$data.containsKey('personInCharge')) {
      return false;
    }
    if (l$personInCharge != lOther$personInCharge) {
      return false;
    }
    final l$$class = $class;
    final lOther$$class = other.$class;
    if (_$data.containsKey('class') != other._$data.containsKey('class')) {
      return false;
    }
    if (l$$class != lOther$$class) {
      return false;
    }
    final l$seat = seat;
    final lOther$seat = other.seat;
    if (_$data.containsKey('seat') != other._$data.containsKey('seat')) {
      return false;
    }
    if (l$seat != lOther$seat) {
      return false;
    }
    final l$rejectionReason = rejectionReason;
    final lOther$rejectionReason = other.rejectionReason;
    if (_$data.containsKey('rejectionReason') !=
        other._$data.containsKey('rejectionReason')) {
      return false;
    }
    if (l$rejectionReason != lOther$rejectionReason) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$parties = parties;
    final lOther$parties = other.parties;
    if (_$data.containsKey('parties') != other._$data.containsKey('parties')) {
      return false;
    }
    if (l$parties != lOther$parties) {
      return false;
    }
    final l$confirmationStatus = confirmationStatus;
    final lOther$confirmationStatus = other.confirmationStatus;
    if (_$data.containsKey('confirmationStatus') !=
        other._$data.containsKey('confirmationStatus')) {
      return false;
    }
    if (l$confirmationStatus != lOther$confirmationStatus) {
      return false;
    }
    final l$user = user;
    final lOther$user = other.user;
    if (_$data.containsKey('user') != other._$data.containsKey('user')) {
      return false;
    }
    if (l$user != lOther$user) {
      return false;
    }
    final l$qrcodes = qrcodes;
    final lOther$qrcodes = other.qrcodes;
    if (_$data.containsKey('qrcodes') != other._$data.containsKey('qrcodes')) {
      return false;
    }
    if (l$qrcodes != lOther$qrcodes) {
      return false;
    }
    final l$emailQueue = emailQueue;
    final lOther$emailQueue = other.emailQueue;
    if (_$data.containsKey('emailQueue') !=
        other._$data.containsKey('emailQueue')) {
      return false;
    }
    if (l$emailQueue != lOther$emailQueue) {
      return false;
    }
    final l$whatsappQueue = whatsappQueue;
    final lOther$whatsappQueue = other.whatsappQueue;
    if (_$data.containsKey('whatsappQueue') !=
        other._$data.containsKey('whatsappQueue')) {
      return false;
    }
    if (l$whatsappQueue != lOther$whatsappQueue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$userId = userId;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$category1 = category1;
    final l$category2 = category2;
    final l$personInCharge = personInCharge;
    final l$$class = $class;
    final l$seat = seat;
    final l$rejectionReason = rejectionReason;
    final l$description = description;
    final l$parties = parties;
    final l$confirmationStatus = confirmationStatus;
    final l$user = user;
    final l$qrcodes = qrcodes;
    final l$emailQueue = emailQueue;
    final l$whatsappQueue = whatsappQueue;
    return Object.hashAll([
      _$data.containsKey('userId') ? l$userId : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('category1') ? l$category1 : const {},
      _$data.containsKey('category2') ? l$category2 : const {},
      _$data.containsKey('personInCharge') ? l$personInCharge : const {},
      _$data.containsKey('class') ? l$$class : const {},
      _$data.containsKey('seat') ? l$seat : const {},
      _$data.containsKey('rejectionReason') ? l$rejectionReason : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('parties') ? l$parties : const {},
      _$data.containsKey('confirmationStatus')
          ? l$confirmationStatus
          : const {},
      _$data.containsKey('user') ? l$user : const {},
      _$data.containsKey('qrcodes') ? l$qrcodes : const {},
      _$data.containsKey('emailQueue') ? l$emailQueue : const {},
      _$data.containsKey('whatsappQueue') ? l$whatsappQueue : const {},
    ]);
  }
}

abstract class CopyWith$Input$GuestWhereUniqueInput<TRes> {
  factory CopyWith$Input$GuestWhereUniqueInput(
    Input$GuestWhereUniqueInput instance,
    TRes Function(Input$GuestWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$GuestWhereUniqueInput;

  factory CopyWith$Input$GuestWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GuestWhereUniqueInput;

  TRes call({
    String? userId,
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringNullableFilter? category1,
    Input$StringNullableFilter? category2,
    Input$StringNullableFilter? personInCharge,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? rejectionReason,
    Input$StringNullableFilter? description,
    Input$IntFilter? parties,
    Input$EnumConfirmationStatusFilter? confirmationStatus,
    Input$UserRelationFilter? user,
    Input$QrCodeListRelationFilter? qrcodes,
    Input$EmailQueueListRelationFilter? emailQueue,
    Input$WhatsappQueueListRelationFilter? whatsappQueue,
  });
  TRes AND(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$GuestWhereInput>? Function(
              Iterable<CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
          _fn);
  CopyWith$Input$StringNullableFilter<TRes> get category1;
  CopyWith$Input$StringNullableFilter<TRes> get category2;
  CopyWith$Input$StringNullableFilter<TRes> get personInCharge;
  CopyWith$Input$StringNullableFilter<TRes> get $class;
  CopyWith$Input$StringNullableFilter<TRes> get seat;
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason;
  CopyWith$Input$StringNullableFilter<TRes> get description;
  CopyWith$Input$IntFilter<TRes> get parties;
  CopyWith$Input$EnumConfirmationStatusFilter<TRes> get confirmationStatus;
  CopyWith$Input$UserRelationFilter<TRes> get user;
  CopyWith$Input$QrCodeListRelationFilter<TRes> get qrcodes;
  CopyWith$Input$EmailQueueListRelationFilter<TRes> get emailQueue;
  CopyWith$Input$WhatsappQueueListRelationFilter<TRes> get whatsappQueue;
}

class _CopyWithImpl$Input$GuestWhereUniqueInput<TRes>
    implements CopyWith$Input$GuestWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$GuestWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$GuestWhereUniqueInput _instance;

  final TRes Function(Input$GuestWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? userId = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? category1 = _undefined,
    Object? category2 = _undefined,
    Object? personInCharge = _undefined,
    Object? $class = _undefined,
    Object? seat = _undefined,
    Object? rejectionReason = _undefined,
    Object? description = _undefined,
    Object? parties = _undefined,
    Object? confirmationStatus = _undefined,
    Object? user = _undefined,
    Object? qrcodes = _undefined,
    Object? emailQueue = _undefined,
    Object? whatsappQueue = _undefined,
  }) =>
      _then(Input$GuestWhereUniqueInput._({
        ..._instance._$data,
        if (userId != _undefined) 'userId': (userId as String?),
        if (AND != _undefined) 'AND': (AND as List<Input$GuestWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$GuestWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$GuestWhereInput>?),
        if (category1 != _undefined)
          'category1': (category1 as Input$StringNullableFilter?),
        if (category2 != _undefined)
          'category2': (category2 as Input$StringNullableFilter?),
        if (personInCharge != _undefined)
          'personInCharge': (personInCharge as Input$StringNullableFilter?),
        if ($class != _undefined)
          'class': ($class as Input$StringNullableFilter?),
        if (seat != _undefined) 'seat': (seat as Input$StringNullableFilter?),
        if (rejectionReason != _undefined)
          'rejectionReason': (rejectionReason as Input$StringNullableFilter?),
        if (description != _undefined)
          'description': (description as Input$StringNullableFilter?),
        if (parties != _undefined) 'parties': (parties as Input$IntFilter?),
        if (confirmationStatus != _undefined)
          'confirmationStatus':
              (confirmationStatus as Input$EnumConfirmationStatusFilter?),
        if (user != _undefined) 'user': (user as Input$UserRelationFilter?),
        if (qrcodes != _undefined)
          'qrcodes': (qrcodes as Input$QrCodeListRelationFilter?),
        if (emailQueue != _undefined)
          'emailQueue': (emailQueue as Input$EmailQueueListRelationFilter?),
        if (whatsappQueue != _undefined)
          'whatsappQueue':
              (whatsappQueue as Input$WhatsappQueueListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$GuestWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$GuestWhereInput<Input$GuestWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$GuestWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringNullableFilter<TRes> get category1 {
    final local$category1 = _instance.category1;
    return local$category1 == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$category1, (e) => call(category1: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get category2 {
    final local$category2 = _instance.category2;
    return local$category2 == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$category2, (e) => call(category2: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get personInCharge {
    final local$personInCharge = _instance.personInCharge;
    return local$personInCharge == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$personInCharge, (e) => call(personInCharge: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get $class {
    final local$$class = _instance.$class;
    return local$$class == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$$class, (e) => call($class: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get seat {
    final local$seat = _instance.seat;
    return local$seat == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(local$seat, (e) => call(seat: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason {
    final local$rejectionReason = _instance.rejectionReason;
    return local$rejectionReason == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$rejectionReason, (e) => call(rejectionReason: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$IntFilter<TRes> get parties {
    final local$parties = _instance.parties;
    return local$parties == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$parties, (e) => call(parties: e));
  }

  CopyWith$Input$EnumConfirmationStatusFilter<TRes> get confirmationStatus {
    final local$confirmationStatus = _instance.confirmationStatus;
    return local$confirmationStatus == null
        ? CopyWith$Input$EnumConfirmationStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumConfirmationStatusFilter(
            local$confirmationStatus, (e) => call(confirmationStatus: e));
  }

  CopyWith$Input$UserRelationFilter<TRes> get user {
    final local$user = _instance.user;
    return local$user == null
        ? CopyWith$Input$UserRelationFilter.stub(_then(_instance))
        : CopyWith$Input$UserRelationFilter(local$user, (e) => call(user: e));
  }

  CopyWith$Input$QrCodeListRelationFilter<TRes> get qrcodes {
    final local$qrcodes = _instance.qrcodes;
    return local$qrcodes == null
        ? CopyWith$Input$QrCodeListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$QrCodeListRelationFilter(
            local$qrcodes, (e) => call(qrcodes: e));
  }

  CopyWith$Input$EmailQueueListRelationFilter<TRes> get emailQueue {
    final local$emailQueue = _instance.emailQueue;
    return local$emailQueue == null
        ? CopyWith$Input$EmailQueueListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$EmailQueueListRelationFilter(
            local$emailQueue, (e) => call(emailQueue: e));
  }

  CopyWith$Input$WhatsappQueueListRelationFilter<TRes> get whatsappQueue {
    final local$whatsappQueue = _instance.whatsappQueue;
    return local$whatsappQueue == null
        ? CopyWith$Input$WhatsappQueueListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$WhatsappQueueListRelationFilter(
            local$whatsappQueue, (e) => call(whatsappQueue: e));
  }
}

class _CopyWithStubImpl$Input$GuestWhereUniqueInput<TRes>
    implements CopyWith$Input$GuestWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$GuestWhereUniqueInput(this._res);

  TRes _res;

  call({
    String? userId,
    List<Input$GuestWhereInput>? AND,
    List<Input$GuestWhereInput>? OR,
    List<Input$GuestWhereInput>? NOT,
    Input$StringNullableFilter? category1,
    Input$StringNullableFilter? category2,
    Input$StringNullableFilter? personInCharge,
    Input$StringNullableFilter? $class,
    Input$StringNullableFilter? seat,
    Input$StringNullableFilter? rejectionReason,
    Input$StringNullableFilter? description,
    Input$IntFilter? parties,
    Input$EnumConfirmationStatusFilter? confirmationStatus,
    Input$UserRelationFilter? user,
    Input$QrCodeListRelationFilter? qrcodes,
    Input$EmailQueueListRelationFilter? emailQueue,
    Input$WhatsappQueueListRelationFilter? whatsappQueue,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringNullableFilter<TRes> get category1 =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get category2 =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get personInCharge =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get $class =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get seat =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get rejectionReason =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get description =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get parties =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$EnumConfirmationStatusFilter<TRes> get confirmationStatus =>
      CopyWith$Input$EnumConfirmationStatusFilter.stub(_res);
  CopyWith$Input$UserRelationFilter<TRes> get user =>
      CopyWith$Input$UserRelationFilter.stub(_res);
  CopyWith$Input$QrCodeListRelationFilter<TRes> get qrcodes =>
      CopyWith$Input$QrCodeListRelationFilter.stub(_res);
  CopyWith$Input$EmailQueueListRelationFilter<TRes> get emailQueue =>
      CopyWith$Input$EmailQueueListRelationFilter.stub(_res);
  CopyWith$Input$WhatsappQueueListRelationFilter<TRes> get whatsappQueue =>
      CopyWith$Input$WhatsappQueueListRelationFilter.stub(_res);
}

class Input$IntFieldUpdateOperationsInput {
  factory Input$IntFieldUpdateOperationsInput({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  }) =>
      Input$IntFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
        if (increment != null) r'increment': increment,
        if (decrement != null) r'decrement': decrement,
        if (multiply != null) r'multiply': multiply,
        if (divide != null) r'divide': divide,
      });

  Input$IntFieldUpdateOperationsInput._(this._$data);

  factory Input$IntFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as int?);
    }
    if (data.containsKey('increment')) {
      final l$increment = data['increment'];
      result$data['increment'] = (l$increment as int?);
    }
    if (data.containsKey('decrement')) {
      final l$decrement = data['decrement'];
      result$data['decrement'] = (l$decrement as int?);
    }
    if (data.containsKey('multiply')) {
      final l$multiply = data['multiply'];
      result$data['multiply'] = (l$multiply as int?);
    }
    if (data.containsKey('divide')) {
      final l$divide = data['divide'];
      result$data['divide'] = (l$divide as int?);
    }
    return Input$IntFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get $set => (_$data['set'] as int?);
  int? get increment => (_$data['increment'] as int?);
  int? get decrement => (_$data['decrement'] as int?);
  int? get multiply => (_$data['multiply'] as int?);
  int? get divide => (_$data['divide'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    if (_$data.containsKey('increment')) {
      final l$increment = increment;
      result$data['increment'] = l$increment;
    }
    if (_$data.containsKey('decrement')) {
      final l$decrement = decrement;
      result$data['decrement'] = l$decrement;
    }
    if (_$data.containsKey('multiply')) {
      final l$multiply = multiply;
      result$data['multiply'] = l$multiply;
    }
    if (_$data.containsKey('divide')) {
      final l$divide = divide;
      result$data['divide'] = l$divide;
    }
    return result$data;
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<
          Input$IntFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$IntFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (_$data.containsKey('increment') !=
        other._$data.containsKey('increment')) {
      return false;
    }
    if (l$increment != lOther$increment) {
      return false;
    }
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (_$data.containsKey('decrement') !=
        other._$data.containsKey('decrement')) {
      return false;
    }
    if (l$decrement != lOther$decrement) {
      return false;
    }
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (_$data.containsKey('multiply') !=
        other._$data.containsKey('multiply')) {
      return false;
    }
    if (l$multiply != lOther$multiply) {
      return false;
    }
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (_$data.containsKey('divide') != other._$data.containsKey('divide')) {
      return false;
    }
    if (l$divide != lOther$divide) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll([
      _$data.containsKey('set') ? l$$set : const {},
      _$data.containsKey('increment') ? l$increment : const {},
      _$data.containsKey('decrement') ? l$decrement : const {},
      _$data.containsKey('multiply') ? l$multiply : const {},
      _$data.containsKey('divide') ? l$divide : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$IntFieldUpdateOperationsInput(
    Input$IntFieldUpdateOperationsInput instance,
    TRes Function(Input$IntFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$IntFieldUpdateOperationsInput;

  factory CopyWith$Input$IntFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput;

  TRes call({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  });
}

class _CopyWithImpl$Input$IntFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$IntFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$IntFieldUpdateOperationsInput _instance;

  final TRes Function(Input$IntFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $set = _undefined,
    Object? increment = _undefined,
    Object? decrement = _undefined,
    Object? multiply = _undefined,
    Object? divide = _undefined,
  }) =>
      _then(Input$IntFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as int?),
        if (increment != _undefined) 'increment': (increment as int?),
        if (decrement != _undefined) 'decrement': (decrement as int?),
        if (multiply != _undefined) 'multiply': (multiply as int?),
        if (divide != _undefined) 'divide': (divide as int?),
      }));
}

class _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  }) =>
      _res;
}

class Input$IntFilter {
  factory Input$IntFilter({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      Input$IntFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$IntFilter._(this._$data);

  factory Input$IntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$IntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  List<int>? get notIn => (_$data['notIn'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  Input$NestedIntFilter? get not => (_$data['not'] as Input$NestedIntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$IntFilter<Input$IntFilter> get copyWith =>
      CopyWith$Input$IntFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntFilter<TRes> {
  factory CopyWith$Input$IntFilter(
    Input$IntFilter instance,
    TRes Function(Input$IntFilter) then,
  ) = _CopyWithImpl$Input$IntFilter;

  factory CopyWith$Input$IntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$IntFilter;

  TRes call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  });
  CopyWith$Input$NestedIntFilter<TRes> get not;
}

class _CopyWithImpl$Input$IntFilter<TRes>
    implements CopyWith$Input$IntFilter<TRes> {
  _CopyWithImpl$Input$IntFilter(
    this._instance,
    this._then,
  );

  final Input$IntFilter _instance;

  final TRes Function(Input$IntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$IntFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntFilter?),
      }));
  CopyWith$Input$NestedIntFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$IntFilter<TRes>
    implements CopyWith$Input$IntFilter<TRes> {
  _CopyWithStubImpl$Input$IntFilter(this._res);

  TRes _res;

  call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedIntFilter<TRes> get not =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$LoginArgs {
  factory Input$LoginArgs({
    required String email,
    required String password,
  }) =>
      Input$LoginArgs._({
        r'email': email,
        r'password': password,
      });

  Input$LoginArgs._(this._$data);

  factory Input$LoginArgs.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$email = data['email'];
    result$data['email'] = (l$email as String);
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    return Input$LoginArgs._(result$data);
  }

  Map<String, dynamic> _$data;

  String get email => (_$data['email'] as String);
  String get password => (_$data['password'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$email = email;
    result$data['email'] = l$email;
    final l$password = password;
    result$data['password'] = l$password;
    return result$data;
  }

  CopyWith$Input$LoginArgs<Input$LoginArgs> get copyWith =>
      CopyWith$Input$LoginArgs(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LoginArgs) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$email = email;
    final l$password = password;
    return Object.hashAll([
      l$email,
      l$password,
    ]);
  }
}

abstract class CopyWith$Input$LoginArgs<TRes> {
  factory CopyWith$Input$LoginArgs(
    Input$LoginArgs instance,
    TRes Function(Input$LoginArgs) then,
  ) = _CopyWithImpl$Input$LoginArgs;

  factory CopyWith$Input$LoginArgs.stub(TRes res) =
      _CopyWithStubImpl$Input$LoginArgs;

  TRes call({
    String? email,
    String? password,
  });
}

class _CopyWithImpl$Input$LoginArgs<TRes>
    implements CopyWith$Input$LoginArgs<TRes> {
  _CopyWithImpl$Input$LoginArgs(
    this._instance,
    this._then,
  );

  final Input$LoginArgs _instance;

  final TRes Function(Input$LoginArgs) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? email = _undefined,
    Object? password = _undefined,
  }) =>
      _then(Input$LoginArgs._({
        ..._instance._$data,
        if (email != _undefined && email != null) 'email': (email as String),
        if (password != _undefined && password != null)
          'password': (password as String),
      }));
}

class _CopyWithStubImpl$Input$LoginArgs<TRes>
    implements CopyWith$Input$LoginArgs<TRes> {
  _CopyWithStubImpl$Input$LoginArgs(this._res);

  TRes _res;

  call({
    String? email,
    String? password,
  }) =>
      _res;
}

class Input$NestedDateTimeFilter {
  factory Input$NestedDateTimeFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      Input$NestedDateTimeFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedDateTimeFilter._(this._$data);

  factory Input$NestedDateTimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedDateTimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedDateTimeFilter<Input$NestedDateTimeFilter>
      get copyWith => CopyWith$Input$NestedDateTimeFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedDateTimeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedDateTimeFilter<TRes> {
  factory CopyWith$Input$NestedDateTimeFilter(
    Input$NestedDateTimeFilter instance,
    TRes Function(Input$NestedDateTimeFilter) then,
  ) = _CopyWithImpl$Input$NestedDateTimeFilter;

  factory CopyWith$Input$NestedDateTimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedDateTimeFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  });
  CopyWith$Input$NestedDateTimeFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedDateTimeFilter<TRes>
    implements CopyWith$Input$NestedDateTimeFilter<TRes> {
  _CopyWithImpl$Input$NestedDateTimeFilter(
    this._instance,
    this._then,
  );

  final Input$NestedDateTimeFilter _instance;

  final TRes Function(Input$NestedDateTimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedDateTimeFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined) 'not': (not as Input$NestedDateTimeFilter?),
      }));
  CopyWith$Input$NestedDateTimeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedDateTimeFilter<TRes>
    implements CopyWith$Input$NestedDateTimeFilter<TRes> {
  _CopyWithStubImpl$Input$NestedDateTimeFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$NestedDateTimeNullableFilter {
  factory Input$NestedDateTimeNullableFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  }) =>
      Input$NestedDateTimeNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedDateTimeNullableFilter._(this._$data);

  factory Input$NestedDateTimeNullableFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedDateTimeNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeNullableFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedDateTimeNullableFilter<
          Input$NestedDateTimeNullableFilter>
      get copyWith => CopyWith$Input$NestedDateTimeNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedDateTimeNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedDateTimeNullableFilter<TRes> {
  factory CopyWith$Input$NestedDateTimeNullableFilter(
    Input$NestedDateTimeNullableFilter instance,
    TRes Function(Input$NestedDateTimeNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedDateTimeNullableFilter;

  factory CopyWith$Input$NestedDateTimeNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedDateTimeNullableFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  });
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedDateTimeNullableFilter<TRes>
    implements CopyWith$Input$NestedDateTimeNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedDateTimeNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedDateTimeNullableFilter _instance;

  final TRes Function(Input$NestedDateTimeNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedDateTimeNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedDateTimeNullableFilter?),
      }));
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedDateTimeNullableFilter<TRes>
    implements CopyWith$Input$NestedDateTimeNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedDateTimeNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeNullableFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeNullableFilter.stub(_res);
}

class Input$NestedEnumConfirmationStatusFilter {
  factory Input$NestedEnumConfirmationStatusFilter({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusFilter? not,
  }) =>
      Input$NestedEnumConfirmationStatusFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$NestedEnumConfirmationStatusFilter._(this._$data);

  factory Input$NestedEnumConfirmationStatusFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$ConfirmationStatus((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConfirmationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$ConfirmationStatus((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumConfirmationStatusFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedEnumConfirmationStatusFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ConfirmationStatus? get equals =>
      (_$data['equals'] as Enum$ConfirmationStatus?);
  List<Enum$ConfirmationStatus>? get $in =>
      (_$data['in'] as List<Enum$ConfirmationStatus>?);
  List<Enum$ConfirmationStatus>? get notIn =>
      (_$data['notIn'] as List<Enum$ConfirmationStatus>?);
  Input$NestedEnumConfirmationStatusFilter? get not =>
      (_$data['not'] as Input$NestedEnumConfirmationStatusFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$ConfirmationStatus(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$ConfirmationStatus(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$ConfirmationStatus(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedEnumConfirmationStatusFilter<
          Input$NestedEnumConfirmationStatusFilter>
      get copyWith => CopyWith$Input$NestedEnumConfirmationStatusFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedEnumConfirmationStatusFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> {
  factory CopyWith$Input$NestedEnumConfirmationStatusFilter(
    Input$NestedEnumConfirmationStatusFilter instance,
    TRes Function(Input$NestedEnumConfirmationStatusFilter) then,
  ) = _CopyWithImpl$Input$NestedEnumConfirmationStatusFilter;

  factory CopyWith$Input$NestedEnumConfirmationStatusFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedEnumConfirmationStatusFilter;

  TRes call({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusFilter? not,
  });
  CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedEnumConfirmationStatusFilter<TRes>
    implements CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> {
  _CopyWithImpl$Input$NestedEnumConfirmationStatusFilter(
    this._instance,
    this._then,
  );

  final Input$NestedEnumConfirmationStatusFilter _instance;

  final TRes Function(Input$NestedEnumConfirmationStatusFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedEnumConfirmationStatusFilter._({
        ..._instance._$data,
        if (equals != _undefined)
          'equals': (equals as Enum$ConfirmationStatus?),
        if ($in != _undefined) 'in': ($in as List<Enum$ConfirmationStatus>?),
        if (notIn != _undefined)
          'notIn': (notIn as List<Enum$ConfirmationStatus>?),
        if (not != _undefined)
          'not': (not as Input$NestedEnumConfirmationStatusFilter?),
      }));
  CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumConfirmationStatusFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedEnumConfirmationStatusFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedEnumConfirmationStatusFilter<TRes>
    implements CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> {
  _CopyWithStubImpl$Input$NestedEnumConfirmationStatusFilter(this._res);

  TRes _res;

  call({
    Enum$ConfirmationStatus? equals,
    List<Enum$ConfirmationStatus>? $in,
    List<Enum$ConfirmationStatus>? notIn,
    Input$NestedEnumConfirmationStatusFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumConfirmationStatusFilter<TRes> get not =>
      CopyWith$Input$NestedEnumConfirmationStatusFilter.stub(_res);
}

class Input$NestedEnumQueueStatusFilter {
  factory Input$NestedEnumQueueStatusFilter({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  }) =>
      Input$NestedEnumQueueStatusFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$NestedEnumQueueStatusFilter._(this._$data);

  factory Input$NestedEnumQueueStatusFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$QueueStatus((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$QueueStatus((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$QueueStatus((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumQueueStatusFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedEnumQueueStatusFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$QueueStatus? get equals => (_$data['equals'] as Enum$QueueStatus?);
  List<Enum$QueueStatus>? get $in => (_$data['in'] as List<Enum$QueueStatus>?);
  List<Enum$QueueStatus>? get notIn =>
      (_$data['notIn'] as List<Enum$QueueStatus>?);
  Input$NestedEnumQueueStatusFilter? get not =>
      (_$data['not'] as Input$NestedEnumQueueStatusFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$QueueStatus(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] =
          l$$in?.map((e) => toJson$Enum$QueueStatus(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$QueueStatus(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedEnumQueueStatusFilter<Input$NestedEnumQueueStatusFilter>
      get copyWith => CopyWith$Input$NestedEnumQueueStatusFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedEnumQueueStatusFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedEnumQueueStatusFilter<TRes> {
  factory CopyWith$Input$NestedEnumQueueStatusFilter(
    Input$NestedEnumQueueStatusFilter instance,
    TRes Function(Input$NestedEnumQueueStatusFilter) then,
  ) = _CopyWithImpl$Input$NestedEnumQueueStatusFilter;

  factory CopyWith$Input$NestedEnumQueueStatusFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedEnumQueueStatusFilter;

  TRes call({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  });
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedEnumQueueStatusFilter<TRes>
    implements CopyWith$Input$NestedEnumQueueStatusFilter<TRes> {
  _CopyWithImpl$Input$NestedEnumQueueStatusFilter(
    this._instance,
    this._then,
  );

  final Input$NestedEnumQueueStatusFilter _instance;

  final TRes Function(Input$NestedEnumQueueStatusFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedEnumQueueStatusFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as Enum$QueueStatus?),
        if ($in != _undefined) 'in': ($in as List<Enum$QueueStatus>?),
        if (notIn != _undefined) 'notIn': (notIn as List<Enum$QueueStatus>?),
        if (not != _undefined)
          'not': (not as Input$NestedEnumQueueStatusFilter?),
      }));
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$NestedEnumQueueStatusFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedEnumQueueStatusFilter<TRes>
    implements CopyWith$Input$NestedEnumQueueStatusFilter<TRes> {
  _CopyWithStubImpl$Input$NestedEnumQueueStatusFilter(this._res);

  TRes _res;

  call({
    Enum$QueueStatus? equals,
    List<Enum$QueueStatus>? $in,
    List<Enum$QueueStatus>? notIn,
    Input$NestedEnumQueueStatusFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumQueueStatusFilter<TRes> get not =>
      CopyWith$Input$NestedEnumQueueStatusFilter.stub(_res);
}

class Input$NestedEnumUserRoleFilter {
  factory Input$NestedEnumUserRoleFilter({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  }) =>
      Input$NestedEnumUserRoleFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (not != null) r'not': not,
      });

  Input$NestedEnumUserRoleFilter._(this._$data);

  factory Input$NestedEnumUserRoleFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = l$equals == null
          ? null
          : fromJson$Enum$UserRole((l$equals as String));
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] = (l$$in as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => fromJson$Enum$UserRole((e as String)))
          .toList();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedEnumUserRoleFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedEnumUserRoleFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$UserRole? get equals => (_$data['equals'] as Enum$UserRole?);
  List<Enum$UserRole>? get $in => (_$data['in'] as List<Enum$UserRole>?);
  List<Enum$UserRole>? get notIn => (_$data['notIn'] as List<Enum$UserRole>?);
  Input$NestedEnumUserRoleFilter? get not =>
      (_$data['not'] as Input$NestedEnumUserRoleFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] =
          l$equals == null ? null : toJson$Enum$UserRole(l$equals);
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] =
          l$notIn?.map((e) => toJson$Enum$UserRole(e)).toList();
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedEnumUserRoleFilter<Input$NestedEnumUserRoleFilter>
      get copyWith => CopyWith$Input$NestedEnumUserRoleFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedEnumUserRoleFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedEnumUserRoleFilter<TRes> {
  factory CopyWith$Input$NestedEnumUserRoleFilter(
    Input$NestedEnumUserRoleFilter instance,
    TRes Function(Input$NestedEnumUserRoleFilter) then,
  ) = _CopyWithImpl$Input$NestedEnumUserRoleFilter;

  factory CopyWith$Input$NestedEnumUserRoleFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedEnumUserRoleFilter;

  TRes call({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  });
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedEnumUserRoleFilter<TRes>
    implements CopyWith$Input$NestedEnumUserRoleFilter<TRes> {
  _CopyWithImpl$Input$NestedEnumUserRoleFilter(
    this._instance,
    this._then,
  );

  final Input$NestedEnumUserRoleFilter _instance;

  final TRes Function(Input$NestedEnumUserRoleFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedEnumUserRoleFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as Enum$UserRole?),
        if ($in != _undefined) 'in': ($in as List<Enum$UserRole>?),
        if (notIn != _undefined) 'notIn': (notIn as List<Enum$UserRole>?),
        if (not != _undefined) 'not': (not as Input$NestedEnumUserRoleFilter?),
      }));
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedEnumUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$NestedEnumUserRoleFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedEnumUserRoleFilter<TRes>
    implements CopyWith$Input$NestedEnumUserRoleFilter<TRes> {
  _CopyWithStubImpl$Input$NestedEnumUserRoleFilter(this._res);

  TRes _res;

  call({
    Enum$UserRole? equals,
    List<Enum$UserRole>? $in,
    List<Enum$UserRole>? notIn,
    Input$NestedEnumUserRoleFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedEnumUserRoleFilter<TRes> get not =>
      CopyWith$Input$NestedEnumUserRoleFilter.stub(_res);
}

class Input$NestedIntFilter {
  factory Input$NestedIntFilter({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      Input$NestedIntFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedIntFilter._(this._$data);

  factory Input$NestedIntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NestedIntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  List<int>? get notIn => (_$data['notIn'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  Input$NestedIntFilter? get not => (_$data['not'] as Input$NestedIntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedIntFilter<Input$NestedIntFilter> get copyWith =>
      CopyWith$Input$NestedIntFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedIntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedIntFilter<TRes> {
  factory CopyWith$Input$NestedIntFilter(
    Input$NestedIntFilter instance,
    TRes Function(Input$NestedIntFilter) then,
  ) = _CopyWithImpl$Input$NestedIntFilter;

  factory CopyWith$Input$NestedIntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedIntFilter;

  TRes call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  });
  CopyWith$Input$NestedIntFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedIntFilter<TRes>
    implements CopyWith$Input$NestedIntFilter<TRes> {
  _CopyWithImpl$Input$NestedIntFilter(
    this._instance,
    this._then,
  );

  final Input$NestedIntFilter _instance;

  final TRes Function(Input$NestedIntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedIntFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntFilter?),
      }));
  CopyWith$Input$NestedIntFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedIntFilter<TRes>
    implements CopyWith$Input$NestedIntFilter<TRes> {
  _CopyWithStubImpl$Input$NestedIntFilter(this._res);

  TRes _res;

  call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedIntFilter<TRes> get not =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$NestedStringFilter {
  factory Input$NestedStringFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      Input$NestedStringFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$NestedStringFilter._(this._$data);

  factory Input$NestedStringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NestedStringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringFilter? get not =>
      (_$data['not'] as Input$NestedStringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedStringFilter<Input$NestedStringFilter> get copyWith =>
      CopyWith$Input$NestedStringFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringFilter<TRes> {
  factory CopyWith$Input$NestedStringFilter(
    Input$NestedStringFilter instance,
    TRes Function(Input$NestedStringFilter) then,
  ) = _CopyWithImpl$Input$NestedStringFilter;

  factory CopyWith$Input$NestedStringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  });
  CopyWith$Input$NestedStringFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringFilter<TRes>
    implements CopyWith$Input$NestedStringFilter<TRes> {
  _CopyWithImpl$Input$NestedStringFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringFilter _instance;

  final TRes Function(Input$NestedStringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedStringFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined) 'not': (not as Input$NestedStringFilter?),
      }));
  CopyWith$Input$NestedStringFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringFilter<TRes>
    implements CopyWith$Input$NestedStringFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringFilter<TRes> get not =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$NestedStringNullableFilter {
  factory Input$NestedStringNullableFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  }) =>
      Input$NestedStringNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$NestedStringNullableFilter._(this._$data);

  factory Input$NestedStringNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedStringNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringNullableFilter? get not =>
      (_$data['not'] as Input$NestedStringNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedStringNullableFilter<Input$NestedStringNullableFilter>
      get copyWith => CopyWith$Input$NestedStringNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringNullableFilter<TRes> {
  factory CopyWith$Input$NestedStringNullableFilter(
    Input$NestedStringNullableFilter instance,
    TRes Function(Input$NestedStringNullableFilter) then,
  ) = _CopyWithImpl$Input$NestedStringNullableFilter;

  factory CopyWith$Input$NestedStringNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringNullableFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  });
  CopyWith$Input$NestedStringNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringNullableFilter<TRes>
    implements CopyWith$Input$NestedStringNullableFilter<TRes> {
  _CopyWithImpl$Input$NestedStringNullableFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringNullableFilter _instance;

  final TRes Function(Input$NestedStringNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedStringNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringNullableFilter?),
      }));
  CopyWith$Input$NestedStringNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringNullableFilter<TRes>
    implements CopyWith$Input$NestedStringNullableFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringNullableFilter<TRes> get not =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);
}

class Input$NullableDateTimeFieldUpdateOperationsInput {
  factory Input$NullableDateTimeFieldUpdateOperationsInput({String? $set}) =>
      Input$NullableDateTimeFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$NullableDateTimeFieldUpdateOperationsInput._(this._$data);

  factory Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$NullableDateTimeFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<
          Input$NullableDateTimeFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NullableDateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
    Input$NullableDateTimeFieldUpdateOperationsInput instance,
    TRes Function(Input$NullableDateTimeFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$NullableDateTimeFieldUpdateOperationsInput;

  factory CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NullableDateTimeFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$NullableDateTimeFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$NullableDateTimeFieldUpdateOperationsInput _instance;

  final TRes Function(Input$NullableDateTimeFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$NullableDateTimeFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$NullableDateTimeFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$NullableStringFieldUpdateOperationsInput {
  factory Input$NullableStringFieldUpdateOperationsInput({String? $set}) =>
      Input$NullableStringFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$NullableStringFieldUpdateOperationsInput._(this._$data);

  factory Input$NullableStringFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$NullableStringFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<
          Input$NullableStringFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NullableStringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$NullableStringFieldUpdateOperationsInput(
    Input$NullableStringFieldUpdateOperationsInput instance,
    TRes Function(Input$NullableStringFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput;

  factory CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$NullableStringFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$NullableStringFieldUpdateOperationsInput _instance;

  final TRes Function(Input$NullableStringFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$NullableStringFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$NullableStringFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$QrCodeCreateManyGuestInput {
  factory Input$QrCodeCreateManyGuestInput({
    required String path,
    String? scannedAt,
    String? createdAt,
    String? scannedByUserId,
  }) =>
      Input$QrCodeCreateManyGuestInput._({
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
      });

  Input$QrCodeCreateManyGuestInput._(this._$data);

  factory Input$QrCodeCreateManyGuestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = (l$scannedByUserId as String?);
    }
    return Input$QrCodeCreateManyGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get scannedByUserId => (_$data['scannedByUserId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateManyGuestInput<Input$QrCodeCreateManyGuestInput>
      get copyWith => CopyWith$Input$QrCodeCreateManyGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateManyGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$scannedByUserId = scannedByUserId;
    return Object.hashAll([
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateManyGuestInput<TRes> {
  factory CopyWith$Input$QrCodeCreateManyGuestInput(
    Input$QrCodeCreateManyGuestInput instance,
    TRes Function(Input$QrCodeCreateManyGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateManyGuestInput;

  factory CopyWith$Input$QrCodeCreateManyGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateManyGuestInput;

  TRes call({
    String? path,
    String? scannedAt,
    String? createdAt,
    String? scannedByUserId,
  });
}

class _CopyWithImpl$Input$QrCodeCreateManyGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateManyGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateManyGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateManyGuestInput _instance;

  final TRes Function(Input$QrCodeCreateManyGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? scannedByUserId = _undefined,
  }) =>
      _then(Input$QrCodeCreateManyGuestInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as String?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeCreateManyGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateManyGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateManyGuestInput(this._res);

  TRes _res;

  call({
    String? path,
    String? scannedAt,
    String? createdAt,
    String? scannedByUserId,
  }) =>
      _res;
}

class Input$QrCodeCreateManyGuestInputEnvelope {
  factory Input$QrCodeCreateManyGuestInputEnvelope({
    required List<Input$QrCodeCreateManyGuestInput> data,
    bool? skipDuplicates,
  }) =>
      Input$QrCodeCreateManyGuestInputEnvelope._({
        r'data': data,
        if (skipDuplicates != null) r'skipDuplicates': skipDuplicates,
      });

  Input$QrCodeCreateManyGuestInputEnvelope._(this._$data);

  factory Input$QrCodeCreateManyGuestInputEnvelope.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => Input$QrCodeCreateManyGuestInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = data['skipDuplicates'];
      result$data['skipDuplicates'] = (l$skipDuplicates as bool?);
    }
    return Input$QrCodeCreateManyGuestInputEnvelope._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateManyGuestInput> get data =>
      (_$data['data'] as List<Input$QrCodeCreateManyGuestInput>);
  bool? get skipDuplicates => (_$data['skipDuplicates'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = skipDuplicates;
      result$data['skipDuplicates'] = l$skipDuplicates;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<
          Input$QrCodeCreateManyGuestInputEnvelope>
      get copyWith => CopyWith$Input$QrCodeCreateManyGuestInputEnvelope(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateManyGuestInputEnvelope) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (_$data.containsKey('skipDuplicates') !=
        other._$data.containsKey('skipDuplicates')) {
      return false;
    }
    if (l$skipDuplicates != lOther$skipDuplicates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('skipDuplicates') ? l$skipDuplicates : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> {
  factory CopyWith$Input$QrCodeCreateManyGuestInputEnvelope(
    Input$QrCodeCreateManyGuestInputEnvelope instance,
    TRes Function(Input$QrCodeCreateManyGuestInputEnvelope) then,
  ) = _CopyWithImpl$Input$QrCodeCreateManyGuestInputEnvelope;

  factory CopyWith$Input$QrCodeCreateManyGuestInputEnvelope.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateManyGuestInputEnvelope;

  TRes call({
    List<Input$QrCodeCreateManyGuestInput>? data,
    bool? skipDuplicates,
  });
  TRes data(
      Iterable<Input$QrCodeCreateManyGuestInput> Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateManyGuestInput<
                      Input$QrCodeCreateManyGuestInput>>)
          _fn);
}

class _CopyWithImpl$Input$QrCodeCreateManyGuestInputEnvelope<TRes>
    implements CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> {
  _CopyWithImpl$Input$QrCodeCreateManyGuestInputEnvelope(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateManyGuestInputEnvelope _instance;

  final TRes Function(Input$QrCodeCreateManyGuestInputEnvelope) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? skipDuplicates = _undefined,
  }) =>
      _then(Input$QrCodeCreateManyGuestInputEnvelope._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<Input$QrCodeCreateManyGuestInput>),
        if (skipDuplicates != _undefined)
          'skipDuplicates': (skipDuplicates as bool?),
      }));
  TRes data(
          Iterable<Input$QrCodeCreateManyGuestInput> Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateManyGuestInput<
                          Input$QrCodeCreateManyGuestInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$Input$QrCodeCreateManyGuestInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$QrCodeCreateManyGuestInputEnvelope<TRes>
    implements CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateManyGuestInputEnvelope(this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateManyGuestInput>? data,
    bool? skipDuplicates,
  }) =>
      _res;
  data(_fn) => _res;
}

class Input$QrCodeCreateManyScannedByInput {
  factory Input$QrCodeCreateManyScannedByInput({
    required String path,
    String? scannedAt,
    String? createdAt,
    required String guestId,
  }) =>
      Input$QrCodeCreateManyScannedByInput._({
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        r'guestId': guestId,
      });

  Input$QrCodeCreateManyScannedByInput._(this._$data);

  factory Input$QrCodeCreateManyScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    final l$guestId = data['guestId'];
    result$data['guestId'] = (l$guestId as String);
    return Input$QrCodeCreateManyScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String get guestId => (_$data['guestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    final l$guestId = guestId;
    result$data['guestId'] = l$guestId;
    return result$data;
  }

  CopyWith$Input$QrCodeCreateManyScannedByInput<
          Input$QrCodeCreateManyScannedByInput>
      get copyWith => CopyWith$Input$QrCodeCreateManyScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateManyScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    return Object.hashAll([
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      l$guestId,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateManyScannedByInput<TRes> {
  factory CopyWith$Input$QrCodeCreateManyScannedByInput(
    Input$QrCodeCreateManyScannedByInput instance,
    TRes Function(Input$QrCodeCreateManyScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateManyScannedByInput;

  factory CopyWith$Input$QrCodeCreateManyScannedByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInput;

  TRes call({
    String? path,
    String? scannedAt,
    String? createdAt,
    String? guestId,
  });
}

class _CopyWithImpl$Input$QrCodeCreateManyScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateManyScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateManyScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateManyScannedByInput _instance;

  final TRes Function(Input$QrCodeCreateManyScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$QrCodeCreateManyScannedByInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (guestId != _undefined && guestId != null)
          'guestId': (guestId as String),
      }));
}

class _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateManyScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInput(this._res);

  TRes _res;

  call({
    String? path,
    String? scannedAt,
    String? createdAt,
    String? guestId,
  }) =>
      _res;
}

class Input$QrCodeCreateManyScannedByInputEnvelope {
  factory Input$QrCodeCreateManyScannedByInputEnvelope({
    required List<Input$QrCodeCreateManyScannedByInput> data,
    bool? skipDuplicates,
  }) =>
      Input$QrCodeCreateManyScannedByInputEnvelope._({
        r'data': data,
        if (skipDuplicates != null) r'skipDuplicates': skipDuplicates,
      });

  Input$QrCodeCreateManyScannedByInputEnvelope._(this._$data);

  factory Input$QrCodeCreateManyScannedByInputEnvelope.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => Input$QrCodeCreateManyScannedByInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = data['skipDuplicates'];
      result$data['skipDuplicates'] = (l$skipDuplicates as bool?);
    }
    return Input$QrCodeCreateManyScannedByInputEnvelope._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateManyScannedByInput> get data =>
      (_$data['data'] as List<Input$QrCodeCreateManyScannedByInput>);
  bool? get skipDuplicates => (_$data['skipDuplicates'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = skipDuplicates;
      result$data['skipDuplicates'] = l$skipDuplicates;
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<
          Input$QrCodeCreateManyScannedByInputEnvelope>
      get copyWith => CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateManyScannedByInputEnvelope) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (_$data.containsKey('skipDuplicates') !=
        other._$data.containsKey('skipDuplicates')) {
      return false;
    }
    if (l$skipDuplicates != lOther$skipDuplicates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('skipDuplicates') ? l$skipDuplicates : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> {
  factory CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope(
    Input$QrCodeCreateManyScannedByInputEnvelope instance,
    TRes Function(Input$QrCodeCreateManyScannedByInputEnvelope) then,
  ) = _CopyWithImpl$Input$QrCodeCreateManyScannedByInputEnvelope;

  factory CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInputEnvelope;

  TRes call({
    List<Input$QrCodeCreateManyScannedByInput>? data,
    bool? skipDuplicates,
  });
  TRes data(
      Iterable<Input$QrCodeCreateManyScannedByInput> Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateManyScannedByInput<
                      Input$QrCodeCreateManyScannedByInput>>)
          _fn);
}

class _CopyWithImpl$Input$QrCodeCreateManyScannedByInputEnvelope<TRes>
    implements CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> {
  _CopyWithImpl$Input$QrCodeCreateManyScannedByInputEnvelope(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateManyScannedByInputEnvelope _instance;

  final TRes Function(Input$QrCodeCreateManyScannedByInputEnvelope) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? skipDuplicates = _undefined,
  }) =>
      _then(Input$QrCodeCreateManyScannedByInputEnvelope._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<Input$QrCodeCreateManyScannedByInput>),
        if (skipDuplicates != _undefined)
          'skipDuplicates': (skipDuplicates as bool?),
      }));
  TRes data(
          Iterable<Input$QrCodeCreateManyScannedByInput> Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateManyScannedByInput<
                          Input$QrCodeCreateManyScannedByInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$Input$QrCodeCreateManyScannedByInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInputEnvelope<TRes>
    implements CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateManyScannedByInputEnvelope(this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateManyScannedByInput>? data,
    bool? skipDuplicates,
  }) =>
      _res;
  data(_fn) => _res;
}

class Input$QrCodeCreateNestedManyWithoutGuestInput {
  factory Input$QrCodeCreateNestedManyWithoutGuestInput({
    List<Input$QrCodeCreateWithoutGuestInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$QrCodeCreateManyGuestInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  }) =>
      Input$QrCodeCreateNestedManyWithoutGuestInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (createMany != null) r'createMany': createMany,
        if (connect != null) r'connect': connect,
      });

  Input$QrCodeCreateNestedManyWithoutGuestInput._(this._$data);

  factory Input$QrCodeCreateNestedManyWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$QrCodeCreateWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) => Input$QrCodeCreateOrConnectWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$QrCodeCreateManyGuestInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$QrCodeCreateNestedManyWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateWithoutGuestInput>? get create =>
      (_$data['create'] as List<Input$QrCodeCreateWithoutGuestInput>?);
  List<Input$QrCodeCreateOrConnectWithoutGuestInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$QrCodeCreateOrConnectWithoutGuestInput>?);
  Input$QrCodeCreateManyGuestInputEnvelope? get createMany =>
      (_$data['createMany'] as Input$QrCodeCreateManyGuestInputEnvelope?);
  List<Input$QrCodeWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$QrCodeWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<
          Input$QrCodeCreateNestedManyWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateNestedManyWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput(
    Input$QrCodeCreateNestedManyWithoutGuestInput instance,
    TRes Function(Input$QrCodeCreateNestedManyWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutGuestInput;

  factory CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutGuestInput;

  TRes call({
    List<Input$QrCodeCreateWithoutGuestInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$QrCodeCreateManyGuestInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$QrCodeCreateWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateWithoutGuestInput<
                      Input$QrCodeCreateWithoutGuestInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$QrCodeCreateOrConnectWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<
                      Input$QrCodeCreateOrConnectWithoutGuestInput>>?)
          _fn);
  CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> get createMany;
  TRes connect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateNestedManyWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeCreateNestedManyWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? createMany = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$QrCodeCreateNestedManyWithoutGuestInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$QrCodeCreateWithoutGuestInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$QrCodeCreateOrConnectWithoutGuestInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$QrCodeCreateManyGuestInputEnvelope?),
        if (connect != _undefined)
          'connect': (connect as List<Input$QrCodeWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$QrCodeCreateWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateWithoutGuestInput<
                          Input$QrCodeCreateWithoutGuestInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$QrCodeCreateWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$QrCodeCreateOrConnectWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<
                          Input$QrCodeCreateOrConnectWithoutGuestInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$QrCodeCreateManyGuestInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateManyGuestInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes connect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateNestedManyWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutGuestInput(this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateWithoutGuestInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$QrCodeCreateManyGuestInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> get createMany =>
      CopyWith$Input$QrCodeCreateManyGuestInputEnvelope.stub(_res);
  connect(_fn) => _res;
}

class Input$QrCodeCreateNestedManyWithoutScannedByInput {
  factory Input$QrCodeCreateNestedManyWithoutScannedByInput({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  }) =>
      Input$QrCodeCreateNestedManyWithoutScannedByInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (createMany != null) r'createMany': createMany,
        if (connect != null) r'connect': connect,
      });

  Input$QrCodeCreateNestedManyWithoutScannedByInput._(this._$data);

  factory Input$QrCodeCreateNestedManyWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$QrCodeCreateWithoutScannedByInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeCreateOrConnectWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$QrCodeCreateManyScannedByInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$QrCodeCreateNestedManyWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateWithoutScannedByInput>? get create =>
      (_$data['create'] as List<Input$QrCodeCreateWithoutScannedByInput>?);
  List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$QrCodeCreateOrConnectWithoutScannedByInput>?);
  Input$QrCodeCreateManyScannedByInputEnvelope? get createMany =>
      (_$data['createMany'] as Input$QrCodeCreateManyScannedByInputEnvelope?);
  List<Input$QrCodeWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$QrCodeWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<
          Input$QrCodeCreateNestedManyWithoutScannedByInput>
      get copyWith =>
          CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateNestedManyWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<
    TRes> {
  factory CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput(
    Input$QrCodeCreateNestedManyWithoutScannedByInput instance,
    TRes Function(Input$QrCodeCreateNestedManyWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput;

  factory CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput;

  TRes call({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$QrCodeCreateWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateWithoutScannedByInput<
                      Input$QrCodeCreateWithoutScannedByInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$QrCodeCreateOrConnectWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
                      Input$QrCodeCreateOrConnectWithoutScannedByInput>>?)
          _fn);
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany;
  TRes connect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateNestedManyWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeCreateNestedManyWithoutScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? createMany = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$QrCodeCreateNestedManyWithoutScannedByInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$QrCodeCreateWithoutScannedByInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$QrCodeCreateOrConnectWithoutScannedByInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$QrCodeCreateManyScannedByInputEnvelope?),
        if (connect != _undefined)
          'connect': (connect as List<Input$QrCodeWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$QrCodeCreateWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateWithoutScannedByInput<
                          Input$QrCodeCreateWithoutScannedByInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$QrCodeCreateWithoutScannedByInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$QrCodeCreateOrConnectWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
                          Input$QrCodeCreateOrConnectWithoutScannedByInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes connect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateNestedManyWithoutScannedByInput(
      this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany =>
      CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(_res);
  connect(_fn) => _res;
}

class Input$QrCodeCreateOrConnectWithoutGuestInput {
  factory Input$QrCodeCreateOrConnectWithoutGuestInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeCreateWithoutGuestInput create,
  }) =>
      Input$QrCodeCreateOrConnectWithoutGuestInput._({
        r'where': where,
        r'create': create,
      });

  Input$QrCodeCreateOrConnectWithoutGuestInput._(this._$data);

  factory Input$QrCodeCreateOrConnectWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$QrCodeCreateWithoutGuestInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$QrCodeCreateOrConnectWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<
          Input$QrCodeCreateOrConnectWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateOrConnectWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput(
    Input$QrCodeCreateOrConnectWithoutGuestInput instance,
    TRes Function(Input$QrCodeCreateOrConnectWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutGuestInput;

  factory CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutGuestInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeCreateWithoutGuestInput? create,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateOrConnectWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeCreateOrConnectWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$QrCodeCreateOrConnectWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$QrCodeCreateWithoutGuestInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$QrCodeCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(_res);
}

class Input$QrCodeCreateOrConnectWithoutScannedByInput {
  factory Input$QrCodeCreateOrConnectWithoutScannedByInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeCreateWithoutScannedByInput create,
  }) =>
      Input$QrCodeCreateOrConnectWithoutScannedByInput._({
        r'where': where,
        r'create': create,
      });

  Input$QrCodeCreateOrConnectWithoutScannedByInput._(this._$data);

  factory Input$QrCodeCreateOrConnectWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$QrCodeCreateWithoutScannedByInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$QrCodeCreateOrConnectWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeCreateWithoutScannedByInput get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutScannedByInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
          Input$QrCodeCreateOrConnectWithoutScannedByInput>
      get copyWith => CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateOrConnectWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes> {
  factory CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput(
    Input$QrCodeCreateOrConnectWithoutScannedByInput instance,
    TRes Function(Input$QrCodeCreateOrConnectWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput;

  factory CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeCreateWithoutScannedByInput? create,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create;
}

class _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateOrConnectWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeCreateOrConnectWithoutScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$QrCodeCreateOrConnectWithoutScannedByInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$QrCodeCreateWithoutScannedByInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$QrCodeCreateWithoutScannedByInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateOrConnectWithoutScannedByInput(this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeCreateWithoutScannedByInput? create,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutScannedByInput.stub(_res);
}

class Input$QrCodeCreateWithoutGuestInput {
  factory Input$QrCodeCreateWithoutGuestInput({
    required String path,
    String? scannedAt,
    String? createdAt,
    Input$UserCreateNestedOneWithoutQrCodeInput? scannedBy,
  }) =>
      Input$QrCodeCreateWithoutGuestInput._({
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeCreateWithoutGuestInput._(this._$data);

  factory Input$QrCodeCreateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserCreateNestedOneWithoutQrCodeInput.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeCreateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Input$UserCreateNestedOneWithoutQrCodeInput? get scannedBy =>
      (_$data['scannedBy'] as Input$UserCreateNestedOneWithoutQrCodeInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeCreateWithoutGuestInput<
          Input$QrCodeCreateWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeCreateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeCreateWithoutGuestInput(
    Input$QrCodeCreateWithoutGuestInput instance,
    TRes Function(Input$QrCodeCreateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateWithoutGuestInput;

  factory CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateWithoutGuestInput;

  TRes call({
    String? path,
    String? scannedAt,
    String? createdAt,
    Input$UserCreateNestedOneWithoutQrCodeInput? scannedBy,
  });
  CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeCreateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeCreateWithoutGuestInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (scannedBy != _undefined)
          'scannedBy':
              (scannedBy as Input$UserCreateNestedOneWithoutQrCodeInput?),
      }));
  CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateWithoutGuestInput(this._res);

  TRes _res;

  call({
    String? path,
    String? scannedAt,
    String? createdAt,
    Input$UserCreateNestedOneWithoutQrCodeInput? scannedBy,
  }) =>
      _res;
  CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput<TRes> get scannedBy =>
      CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput.stub(_res);
}

class Input$QrCodeCreateWithoutScannedByInput {
  factory Input$QrCodeCreateWithoutScannedByInput({
    required String path,
    String? scannedAt,
    String? createdAt,
    required Input$GuestCreateNestedOneWithoutQrcodesInput guest,
  }) =>
      Input$QrCodeCreateWithoutScannedByInput._({
        r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        r'guest': guest,
      });

  Input$QrCodeCreateWithoutScannedByInput._(this._$data);

  factory Input$QrCodeCreateWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = (l$scannedAt as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    final l$guest = data['guest'];
    result$data['guest'] =
        Input$GuestCreateNestedOneWithoutQrcodesInput.fromJson(
            (l$guest as Map<String, dynamic>));
    return Input$QrCodeCreateWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  String? get scannedAt => (_$data['scannedAt'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Input$GuestCreateNestedOneWithoutQrcodesInput get guest =>
      (_$data['guest'] as Input$GuestCreateNestedOneWithoutQrcodesInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    final l$guest = guest;
    result$data['guest'] = l$guest.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeCreateWithoutScannedByInput<
          Input$QrCodeCreateWithoutScannedByInput>
      get copyWith => CopyWith$Input$QrCodeCreateWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeCreateWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$guest = guest;
    return Object.hashAll([
      l$path,
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      l$guest,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> {
  factory CopyWith$Input$QrCodeCreateWithoutScannedByInput(
    Input$QrCodeCreateWithoutScannedByInput instance,
    TRes Function(Input$QrCodeCreateWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeCreateWithoutScannedByInput;

  factory CopyWith$Input$QrCodeCreateWithoutScannedByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeCreateWithoutScannedByInput;

  TRes call({
    String? path,
    String? scannedAt,
    String? createdAt,
    Input$GuestCreateNestedOneWithoutQrcodesInput? guest,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput<TRes> get guest;
}

class _CopyWithImpl$Input$QrCodeCreateWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeCreateWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeCreateWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeCreateWithoutScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$QrCodeCreateWithoutScannedByInput._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
        if (scannedAt != _undefined) 'scannedAt': (scannedAt as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (guest != _undefined && guest != null)
          'guest': (guest as Input$GuestCreateNestedOneWithoutQrcodesInput),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput<TRes> get guest {
    final local$guest = _instance.guest;
    return CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput(
        local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeCreateWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeCreateWithoutScannedByInput(this._res);

  TRes _res;

  call({
    String? path,
    String? scannedAt,
    String? createdAt,
    Input$GuestCreateNestedOneWithoutQrcodesInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput<TRes> get guest =>
      CopyWith$Input$GuestCreateNestedOneWithoutQrcodesInput.stub(_res);
}

class Input$QrCodeListRelationFilter {
  factory Input$QrCodeListRelationFilter({
    Input$QrCodeWhereInput? every,
    Input$QrCodeWhereInput? some,
    Input$QrCodeWhereInput? none,
  }) =>
      Input$QrCodeListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$QrCodeListRelationFilter._(this._$data);

  factory Input$QrCodeListRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$QrCodeWhereInput.fromJson((l$none as Map<String, dynamic>));
    }
    return Input$QrCodeListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereInput? get every =>
      (_$data['every'] as Input$QrCodeWhereInput?);
  Input$QrCodeWhereInput? get some =>
      (_$data['some'] as Input$QrCodeWhereInput?);
  Input$QrCodeWhereInput? get none =>
      (_$data['none'] as Input$QrCodeWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeListRelationFilter<Input$QrCodeListRelationFilter>
      get copyWith => CopyWith$Input$QrCodeListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeListRelationFilter<TRes> {
  factory CopyWith$Input$QrCodeListRelationFilter(
    Input$QrCodeListRelationFilter instance,
    TRes Function(Input$QrCodeListRelationFilter) then,
  ) = _CopyWithImpl$Input$QrCodeListRelationFilter;

  factory CopyWith$Input$QrCodeListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeListRelationFilter;

  TRes call({
    Input$QrCodeWhereInput? every,
    Input$QrCodeWhereInput? some,
    Input$QrCodeWhereInput? none,
  });
  CopyWith$Input$QrCodeWhereInput<TRes> get every;
  CopyWith$Input$QrCodeWhereInput<TRes> get some;
  CopyWith$Input$QrCodeWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$QrCodeListRelationFilter<TRes>
    implements CopyWith$Input$QrCodeListRelationFilter<TRes> {
  _CopyWithImpl$Input$QrCodeListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$QrCodeListRelationFilter _instance;

  final TRes Function(Input$QrCodeListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$QrCodeListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined) 'every': (every as Input$QrCodeWhereInput?),
        if (some != _undefined) 'some': (some as Input$QrCodeWhereInput?),
        if (none != _undefined) 'none': (none as Input$QrCodeWhereInput?),
      }));
  CopyWith$Input$QrCodeWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$every, (e) => call(every: e));
  }

  CopyWith$Input$QrCodeWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$some, (e) => call(some: e));
  }

  CopyWith$Input$QrCodeWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$QrCodeWhereInput.stub(_then(_instance))
        : CopyWith$Input$QrCodeWhereInput(local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeListRelationFilter<TRes>
    implements CopyWith$Input$QrCodeListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$QrCodeListRelationFilter(this._res);

  TRes _res;

  call({
    Input$QrCodeWhereInput? every,
    Input$QrCodeWhereInput? some,
    Input$QrCodeWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereInput<TRes> get every =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
  CopyWith$Input$QrCodeWhereInput<TRes> get some =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
  CopyWith$Input$QrCodeWhereInput<TRes> get none =>
      CopyWith$Input$QrCodeWhereInput.stub(_res);
}

class Input$QrCodeOrderByRelationAggregateInput {
  factory Input$QrCodeOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$QrCodeOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$QrCodeOrderByRelationAggregateInput._(this._$data);

  factory Input$QrCodeOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$QrCodeOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$QrCodeOrderByRelationAggregateInput<
          Input$QrCodeOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$QrCodeOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$QrCodeOrderByRelationAggregateInput(
    Input$QrCodeOrderByRelationAggregateInput instance,
    TRes Function(Input$QrCodeOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$QrCodeOrderByRelationAggregateInput;

  factory CopyWith$Input$QrCodeOrderByRelationAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$QrCodeOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$QrCodeOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeOrderByRelationAggregateInput _instance;

  final TRes Function(Input$QrCodeOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$QrCodeOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$QrCodeOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$QrCodeScalarWhereInput {
  factory Input$QrCodeScalarWhereInput({
    List<Input$QrCodeScalarWhereInput>? AND,
    List<Input$QrCodeScalarWhereInput>? OR,
    List<Input$QrCodeScalarWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
  }) =>
      Input$QrCodeScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (guestId != null) r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
      });

  Input$QrCodeScalarWhereInput._(this._$data);

  factory Input$QrCodeScalarWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFilter.fromJson((l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = l$scannedByUserId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$scannedByUserId as Map<String, dynamic>));
    }
    return Input$QrCodeScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$QrCodeScalarWhereInput>?);
  List<Input$QrCodeScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$QrCodeScalarWhereInput>?);
  List<Input$QrCodeScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$QrCodeScalarWhereInput>?);
  Input$StringFilter? get path => (_$data['path'] as Input$StringFilter?);
  Input$DateTimeNullableFilter? get scannedAt =>
      (_$data['scannedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$StringNullableFilter? get scannedByUserId =>
      (_$data['scannedByUserId'] as Input$StringNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeScalarWhereInput<Input$QrCodeScalarWhereInput>
      get copyWith => CopyWith$Input$QrCodeScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeScalarWhereInput<TRes> {
  factory CopyWith$Input$QrCodeScalarWhereInput(
    Input$QrCodeScalarWhereInput instance,
    TRes Function(Input$QrCodeScalarWhereInput) then,
  ) = _CopyWithImpl$Input$QrCodeScalarWhereInput;

  factory CopyWith$Input$QrCodeScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeScalarWhereInput;

  TRes call({
    List<Input$QrCodeScalarWhereInput>? AND,
    List<Input$QrCodeScalarWhereInput>? OR,
    List<Input$QrCodeScalarWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
  });
  TRes AND(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get path;
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId;
}

class _CopyWithImpl$Input$QrCodeScalarWhereInput<TRes>
    implements CopyWith$Input$QrCodeScalarWhereInput<TRes> {
  _CopyWithImpl$Input$QrCodeScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeScalarWhereInput _instance;

  final TRes Function(Input$QrCodeScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
  }) =>
      _then(Input$QrCodeScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$QrCodeScalarWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$QrCodeScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$QrCodeScalarWhereInput>?),
        if (path != _undefined) 'path': (path as Input$StringFilter?),
        if (scannedAt != _undefined)
          'scannedAt': (scannedAt as Input$DateTimeNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as Input$StringNullableFilter?),
      }));
  TRes AND(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$StringFilter<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId {
    final local$scannedByUserId = _instance.scannedByUserId;
    return local$scannedByUserId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$scannedByUserId, (e) => call(scannedByUserId: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeScalarWhereInput<TRes>
    implements CopyWith$Input$QrCodeScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$QrCodeScalarWhereInput>? AND,
    List<Input$QrCodeScalarWhereInput>? OR,
    List<Input$QrCodeScalarWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get path =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
}

class Input$QrCodeUpdateManyMutationInput {
  factory Input$QrCodeUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  }) =>
      Input$QrCodeUpdateManyMutationInput._({
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
      });

  Input$QrCodeUpdateManyMutationInput._(this._$data);

  factory Input$QrCodeUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    return Input$QrCodeUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get scannedAt =>
      (_$data['scannedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateManyMutationInput<
          Input$QrCodeUpdateManyMutationInput>
      get copyWith => CopyWith$Input$QrCodeUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    return Object.hashAll([
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateManyMutationInput(
    Input$QrCodeUpdateManyMutationInput instance,
    TRes Function(Input$QrCodeUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateManyMutationInput;

  factory CopyWith$Input$QrCodeUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get scannedAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
}

class _CopyWithImpl$Input$QrCodeUpdateManyMutationInput<TRes>
    implements CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateManyMutationInput _instance;

  final TRes Function(Input$QrCodeUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
  }) =>
      _then(Input$QrCodeUpdateManyMutationInput._({
        ..._instance._$data,
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (scannedAt != _undefined)
          'scannedAt':
              (scannedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateManyMutationInput<TRes>
    implements CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
}

class Input$QrCodeUpdateManyWithoutGuestNestedInput {
  factory Input$QrCodeUpdateManyWithoutGuestNestedInput({
    List<Input$QrCodeCreateWithoutGuestInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$QrCodeCreateManyGuestInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  }) =>
      Input$QrCodeUpdateManyWithoutGuestNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (createMany != null) r'createMany': createMany,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$QrCodeUpdateManyWithoutGuestNestedInput._(this._$data);

  factory Input$QrCodeUpdateManyWithoutGuestNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$QrCodeCreateWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) => Input$QrCodeCreateOrConnectWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$QrCodeCreateManyGuestInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpdateManyWithWhereWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$QrCodeUpdateManyWithoutGuestNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateWithoutGuestInput>? get create =>
      (_$data['create'] as List<Input$QrCodeCreateWithoutGuestInput>?);
  List<Input$QrCodeCreateOrConnectWithoutGuestInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$QrCodeCreateOrConnectWithoutGuestInput>?);
  List<Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>? get upsert =>
      (_$data['upsert']
          as List<Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>?);
  Input$QrCodeCreateManyGuestInputEnvelope? get createMany =>
      (_$data['createMany'] as Input$QrCodeCreateManyGuestInputEnvelope?);
  List<Input$QrCodeWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>? get update =>
      (_$data['update']
          as List<Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>?);
  List<Input$QrCodeUpdateManyWithWhereWithoutGuestInput>? get updateMany =>
      (_$data['updateMany']
          as List<Input$QrCodeUpdateManyWithWhereWithoutGuestInput>?);
  List<Input$QrCodeScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$QrCodeScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<
          Input$QrCodeUpdateManyWithoutGuestNestedInput>
      get copyWith => CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateManyWithoutGuestNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput(
    Input$QrCodeUpdateManyWithoutGuestNestedInput instance,
    TRes Function(Input$QrCodeUpdateManyWithoutGuestNestedInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateManyWithoutGuestNestedInput;

  factory CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutGuestNestedInput;

  TRes call({
    List<Input$QrCodeCreateWithoutGuestInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$QrCodeCreateManyGuestInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$QrCodeCreateWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateWithoutGuestInput<
                      Input$QrCodeCreateWithoutGuestInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$QrCodeCreateOrConnectWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<
                      Input$QrCodeCreateOrConnectWithoutGuestInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput<
                      Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>>?)
          _fn);
  CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> get createMany;
  TRes $set(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput<
                      Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$QrCodeUpdateManyWithWhereWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput<
                      Input$QrCodeUpdateManyWithWhereWithoutGuestInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes>
    implements CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateManyWithoutGuestNestedInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateManyWithoutGuestNestedInput _instance;

  final TRes Function(Input$QrCodeUpdateManyWithoutGuestNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? createMany = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$QrCodeUpdateManyWithoutGuestNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$QrCodeCreateWithoutGuestInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$QrCodeCreateOrConnectWithoutGuestInput>?),
        if (upsert != _undefined)
          'upsert': (upsert
              as List<Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$QrCodeCreateManyGuestInputEnvelope?),
        if ($set != _undefined)
          'set': ($set as List<Input$QrCodeWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as List<Input$QrCodeWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$QrCodeWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$QrCodeWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update
              as List<Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany
              as List<Input$QrCodeUpdateManyWithWhereWithoutGuestInput>?),
        if (deleteMany != _undefined)
          'deleteMany': (deleteMany as List<Input$QrCodeScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$QrCodeCreateWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateWithoutGuestInput<
                          Input$QrCodeCreateWithoutGuestInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$QrCodeCreateWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$QrCodeCreateOrConnectWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput<
                          Input$QrCodeCreateOrConnectWithoutGuestInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$QrCodeCreateOrConnectWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes upsert(
          Iterable<Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput<
                          Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$QrCodeCreateManyGuestInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateManyGuestInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes $set(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(
              _instance.$set?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput<
                          Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$QrCodeUpdateManyWithWhereWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput<
                          Input$QrCodeUpdateManyWithWhereWithoutGuestInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map(
              (e) => CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes deleteMany(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes>
    implements CopyWith$Input$QrCodeUpdateManyWithoutGuestNestedInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutGuestNestedInput(this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateWithoutGuestInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$QrCodeCreateManyGuestInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  CopyWith$Input$QrCodeCreateManyGuestInputEnvelope<TRes> get createMany =>
      CopyWith$Input$QrCodeCreateManyGuestInputEnvelope.stub(_res);
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$QrCodeUpdateManyWithoutScannedByNestedInput {
  factory Input$QrCodeUpdateManyWithoutScannedByNestedInput({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? upsert,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  }) =>
      Input$QrCodeUpdateManyWithoutScannedByNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (createMany != null) r'createMany': createMany,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$QrCodeUpdateManyWithoutScannedByNestedInput._(this._$data);

  factory Input$QrCodeUpdateManyWithoutScannedByNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$QrCodeCreateWithoutScannedByInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeCreateOrConnectWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$QrCodeCreateManyScannedByInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$QrCodeWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeUpdateManyWithWhereWithoutScannedByInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$QrCodeScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$QrCodeUpdateManyWithoutScannedByNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeCreateWithoutScannedByInput>? get create =>
      (_$data['create'] as List<Input$QrCodeCreateWithoutScannedByInput>?);
  List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$QrCodeCreateOrConnectWithoutScannedByInput>?);
  List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? get upsert =>
      (_$data['upsert']
          as List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>?);
  Input$QrCodeCreateManyScannedByInputEnvelope? get createMany =>
      (_$data['createMany'] as Input$QrCodeCreateManyScannedByInputEnvelope?);
  List<Input$QrCodeWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$QrCodeWhereUniqueInput>?);
  List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? get update =>
      (_$data['update']
          as List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>?);
  List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? get updateMany =>
      (_$data['updateMany']
          as List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>?);
  List<Input$QrCodeScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$QrCodeScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<
          Input$QrCodeUpdateManyWithoutScannedByNestedInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateManyWithoutScannedByNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
    Input$QrCodeUpdateManyWithoutScannedByNestedInput instance,
    TRes Function(Input$QrCodeUpdateManyWithoutScannedByNestedInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput;

  factory CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput;

  TRes call({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? upsert,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$QrCodeCreateWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateWithoutScannedByInput<
                      Input$QrCodeCreateWithoutScannedByInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$QrCodeCreateOrConnectWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
                      Input$QrCodeCreateOrConnectWithoutScannedByInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
                      Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>>?)
          _fn);
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany;
  TRes $set(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$QrCodeWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereUniqueInput<
                      Input$QrCodeWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
                      Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
                      Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$QrCodeScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeScalarWhereInput<
                      Input$QrCodeScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateManyWithoutScannedByNestedInput _instance;

  final TRes Function(Input$QrCodeUpdateManyWithoutScannedByNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? createMany = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$QrCodeUpdateManyWithoutScannedByNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$QrCodeCreateWithoutScannedByInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$QrCodeCreateOrConnectWithoutScannedByInput>?),
        if (upsert != _undefined)
          'upsert': (upsert
              as List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$QrCodeCreateManyScannedByInputEnvelope?),
        if ($set != _undefined)
          'set': ($set as List<Input$QrCodeWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as List<Input$QrCodeWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$QrCodeWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$QrCodeWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update
              as List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany
              as List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>?),
        if (deleteMany != _undefined)
          'deleteMany': (deleteMany as List<Input$QrCodeScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$QrCodeCreateWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateWithoutScannedByInput<
                          Input$QrCodeCreateWithoutScannedByInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$QrCodeCreateWithoutScannedByInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$QrCodeCreateOrConnectWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput<
                          Input$QrCodeCreateOrConnectWithoutScannedByInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$QrCodeCreateOrConnectWithoutScannedByInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes upsert(
          Iterable<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
                          Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes $set(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(
              _instance.$set?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$QrCodeWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereUniqueInput<
                          Input$QrCodeWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$QrCodeWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
                          Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
                          Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$QrCodeScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeScalarWhereInput<
                          Input$QrCodeScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$QrCodeScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$QrCodeCreateWithoutScannedByInput>? create,
    List<Input$QrCodeCreateOrConnectWithoutScannedByInput>? connectOrCreate,
    List<Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>? upsert,
    Input$QrCodeCreateManyScannedByInputEnvelope? createMany,
    List<Input$QrCodeWhereUniqueInput>? $set,
    List<Input$QrCodeWhereUniqueInput>? disconnect,
    List<Input$QrCodeWhereUniqueInput>? delete,
    List<Input$QrCodeWhereUniqueInput>? connect,
    List<Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>? update,
    List<Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>? updateMany,
    List<Input$QrCodeScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope<TRes> get createMany =>
      CopyWith$Input$QrCodeCreateManyScannedByInputEnvelope.stub(_res);
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$QrCodeUpdateManyWithWhereWithoutGuestInput {
  factory Input$QrCodeUpdateManyWithWhereWithoutGuestInput({
    required Input$QrCodeScalarWhereInput where,
    required Input$QrCodeUpdateManyMutationInput data,
  }) =>
      Input$QrCodeUpdateManyWithWhereWithoutGuestInput._({
        r'where': where,
        r'data': data,
      });

  Input$QrCodeUpdateManyWithWhereWithoutGuestInput._(this._$data);

  factory Input$QrCodeUpdateManyWithWhereWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$QrCodeUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$QrCodeUpdateManyWithWhereWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeScalarWhereInput get where =>
      (_$data['where'] as Input$QrCodeScalarWhereInput);
  Input$QrCodeUpdateManyMutationInput get data =>
      (_$data['data'] as Input$QrCodeUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput<
          Input$QrCodeUpdateManyWithWhereWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateManyWithWhereWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput(
    Input$QrCodeUpdateManyWithWhereWithoutGuestInput instance,
    TRes Function(Input$QrCodeUpdateManyWithWhereWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutGuestInput;

  factory CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutGuestInput;

  TRes call({
    Input$QrCodeScalarWhereInput? where,
    Input$QrCodeUpdateManyMutationInput? data,
  });
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateManyWithWhereWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeUpdateManyWithWhereWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$QrCodeUpdateManyWithWhereWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$QrCodeUpdateManyMutationInput),
      }));
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$QrCodeUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeUpdateManyWithWhereWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$QrCodeScalarWhereInput? where,
    Input$QrCodeUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where =>
      CopyWith$Input$QrCodeScalarWhereInput.stub(_res);
  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$QrCodeUpdateManyMutationInput.stub(_res);
}

class Input$QrCodeUpdateManyWithWhereWithoutScannedByInput {
  factory Input$QrCodeUpdateManyWithWhereWithoutScannedByInput({
    required Input$QrCodeScalarWhereInput where,
    required Input$QrCodeUpdateManyMutationInput data,
  }) =>
      Input$QrCodeUpdateManyWithWhereWithoutScannedByInput._({
        r'where': where,
        r'data': data,
      });

  Input$QrCodeUpdateManyWithWhereWithoutScannedByInput._(this._$data);

  factory Input$QrCodeUpdateManyWithWhereWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$QrCodeUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$QrCodeUpdateManyWithWhereWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeScalarWhereInput get where =>
      (_$data['where'] as Input$QrCodeScalarWhereInput);
  Input$QrCodeUpdateManyMutationInput get data =>
      (_$data['data'] as Input$QrCodeUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
          Input$QrCodeUpdateManyWithWhereWithoutScannedByInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateManyWithWhereWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
    Input$QrCodeUpdateManyWithWhereWithoutScannedByInput instance,
    TRes Function(Input$QrCodeUpdateManyWithWhereWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput;

  factory CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput;

  TRes call({
    Input$QrCodeScalarWhereInput? where,
    Input$QrCodeUpdateManyMutationInput? data,
  });
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateManyWithWhereWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeUpdateManyWithWhereWithoutScannedByInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$QrCodeUpdateManyWithWhereWithoutScannedByInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$QrCodeUpdateManyMutationInput),
      }));
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$QrCodeUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<
        TRes>
    implements
        CopyWith$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateManyWithWhereWithoutScannedByInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeScalarWhereInput? where,
    Input$QrCodeUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$QrCodeScalarWhereInput<TRes> get where =>
      CopyWith$Input$QrCodeScalarWhereInput.stub(_res);
  CopyWith$Input$QrCodeUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$QrCodeUpdateManyMutationInput.stub(_res);
}

class Input$QrCodeUpdateWithoutGuestInput {
  factory Input$QrCodeUpdateWithoutGuestInput({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$UserUpdateOneWithoutQrCodeNestedInput? scannedBy,
  }) =>
      Input$QrCodeUpdateWithoutGuestInput._({
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeUpdateWithoutGuestInput._(this._$data);

  factory Input$QrCodeUpdateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserUpdateOneWithoutQrCodeNestedInput.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeUpdateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get scannedAt =>
      (_$data['scannedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$UserUpdateOneWithoutQrCodeNestedInput? get scannedBy =>
      (_$data['scannedBy'] as Input$UserUpdateOneWithoutQrCodeNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateWithoutGuestInput<
          Input$QrCodeUpdateWithoutGuestInput>
      get copyWith => CopyWith$Input$QrCodeUpdateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateWithoutGuestInput(
    Input$QrCodeUpdateWithoutGuestInput instance,
    TRes Function(Input$QrCodeUpdateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateWithoutGuestInput;

  factory CopyWith$Input$QrCodeUpdateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateWithoutGuestInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$UserUpdateOneWithoutQrCodeNestedInput? scannedBy,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get scannedAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeUpdateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeUpdateWithoutGuestInput._({
        ..._instance._$data,
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (scannedAt != _undefined)
          'scannedAt':
              (scannedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (scannedBy != _undefined)
          'scannedBy':
              (scannedBy as Input$UserUpdateOneWithoutQrCodeNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$UserUpdateOneWithoutQrCodeNestedInput? scannedBy,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput<TRes> get scannedBy =>
      CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput.stub(_res);
}

class Input$QrCodeUpdateWithoutScannedByInput {
  factory Input$QrCodeUpdateWithoutScannedByInput({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput? guest,
  }) =>
      Input$QrCodeUpdateWithoutScannedByInput._({
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (guest != null) r'guest': guest,
      });

  Input$QrCodeUpdateWithoutScannedByInput._(this._$data);

  factory Input$QrCodeUpdateWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$QrCodeUpdateWithoutScannedByInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get path =>
      (_$data['path'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get scannedAt =>
      (_$data['scannedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput? get guest =>
      (_$data['guest']
          as Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<
          Input$QrCodeUpdateWithoutScannedByInput>
      get copyWith => CopyWith$Input$QrCodeUpdateWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> {
  factory CopyWith$Input$QrCodeUpdateWithoutScannedByInput(
    Input$QrCodeUpdateWithoutScannedByInput instance,
    TRes Function(Input$QrCodeUpdateWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateWithoutScannedByInput;

  factory CopyWith$Input$QrCodeUpdateWithoutScannedByInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateWithoutScannedByInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput? guest,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get scannedAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<TRes>
      get guest;
}

class _CopyWithImpl$Input$QrCodeUpdateWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeUpdateWithoutScannedByInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$QrCodeUpdateWithoutScannedByInput._({
        ..._instance._$data,
        if (path != _undefined)
          'path': (path as Input$StringFieldUpdateOperationsInput?),
        if (scannedAt != _undefined)
          'scannedAt':
              (scannedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (guest != _undefined)
          'guest':
              (guest as Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$path, (e) => call(path: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateWithoutScannedByInput<TRes>
    implements CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateWithoutScannedByInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? path,
    Input$NullableDateTimeFieldUpdateOperationsInput? scannedAt,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput? guest,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get path =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get scannedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput<TRes>
      get guest =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutQrcodesNestedInput.stub(
              _res);
}

class Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput {
  factory Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeUpdateWithoutGuestInput data,
  }) =>
      Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput._({
        r'where': where,
        r'data': data,
      });

  Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput._(this._$data);

  factory Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$QrCodeUpdateWithoutGuestInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeUpdateWithoutGuestInput get data =>
      (_$data['data'] as Input$QrCodeUpdateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput<
          Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput(
    Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput instance,
    TRes Function(Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput;

  factory CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutGuestInput? data,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get data;
}

class _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$QrCodeUpdateWithoutGuestInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$QrCodeUpdateWithoutGuestInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutGuestInput? data,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get data =>
      CopyWith$Input$QrCodeUpdateWithoutGuestInput.stub(_res);
}

class Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput {
  factory Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeUpdateWithoutScannedByInput data,
  }) =>
      Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput._({
        r'where': where,
        r'data': data,
      });

  Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput._(this._$data);

  factory Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$QrCodeUpdateWithoutScannedByInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeUpdateWithoutScannedByInput get data =>
      (_$data['data'] as Input$QrCodeUpdateWithoutScannedByInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
          Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
    Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput instance,
    TRes Function(Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput;

  factory CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutScannedByInput? data,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get data;
}

class _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$QrCodeUpdateWithoutScannedByInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$QrCodeUpdateWithoutScannedByInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<
        TRes>
    implements
        CopyWith$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpdateWithWhereUniqueWithoutScannedByInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutScannedByInput? data,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get data =>
      CopyWith$Input$QrCodeUpdateWithoutScannedByInput.stub(_res);
}

class Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput {
  factory Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeUpdateWithoutGuestInput update,
    required Input$QrCodeCreateWithoutGuestInput create,
  }) =>
      Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput._(this._$data);

  factory Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$QrCodeUpdateWithoutGuestInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$QrCodeCreateWithoutGuestInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeUpdateWithoutGuestInput get update =>
      (_$data['update'] as Input$QrCodeUpdateWithoutGuestInput);
  Input$QrCodeCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput<
          Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput(
    Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput instance,
    TRes Function(Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput;

  factory CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutGuestInput? update,
    Input$QrCodeCreateWithoutGuestInput? create,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get update;
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput<TRes>
    implements
        CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput _instance;

  final TRes Function(Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$QrCodeUpdateWithoutGuestInput),
        if (create != _undefined && create != null)
          'create': (create as Input$QrCodeCreateWithoutGuestInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$QrCodeUpdateWithoutGuestInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$QrCodeCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput<TRes>
    implements
        CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutGuestInput? update,
    Input$QrCodeCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeUpdateWithoutGuestInput<TRes> get update =>
      CopyWith$Input$QrCodeUpdateWithoutGuestInput.stub(_res);
  CopyWith$Input$QrCodeCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutGuestInput.stub(_res);
}

class Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput {
  factory Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput({
    required Input$QrCodeWhereUniqueInput where,
    required Input$QrCodeUpdateWithoutScannedByInput update,
    required Input$QrCodeCreateWithoutScannedByInput create,
  }) =>
      Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput._(this._$data);

  factory Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$QrCodeWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$QrCodeUpdateWithoutScannedByInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$QrCodeCreateWithoutScannedByInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$QrCodeWhereUniqueInput get where =>
      (_$data['where'] as Input$QrCodeWhereUniqueInput);
  Input$QrCodeUpdateWithoutScannedByInput get update =>
      (_$data['update'] as Input$QrCodeUpdateWithoutScannedByInput);
  Input$QrCodeCreateWithoutScannedByInput get create =>
      (_$data['create'] as Input$QrCodeCreateWithoutScannedByInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
          Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput>
      get copyWith =>
          CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
    TRes> {
  factory CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
    Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput instance,
    TRes Function(Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput) then,
  ) = _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput;

  factory CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput;

  TRes call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutScannedByInput? update,
    Input$QrCodeCreateWithoutScannedByInput? create,
  });
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where;
  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get update;
  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create;
}

class _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<TRes>
    implements
        CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<TRes> {
  _CopyWithImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput _instance;

  final TRes Function(Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$QrCodeWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$QrCodeUpdateWithoutScannedByInput),
        if (create != _undefined && create != null)
          'create': (create as Input$QrCodeCreateWithoutScannedByInput),
      }));
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$QrCodeWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$QrCodeUpdateWithoutScannedByInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$QrCodeCreateWithoutScannedByInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<
        TRes>
    implements
        CopyWith$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeUpsertWithWhereUniqueWithoutScannedByInput(
      this._res);

  TRes _res;

  call({
    Input$QrCodeWhereUniqueInput? where,
    Input$QrCodeUpdateWithoutScannedByInput? update,
    Input$QrCodeCreateWithoutScannedByInput? create,
  }) =>
      _res;
  CopyWith$Input$QrCodeWhereUniqueInput<TRes> get where =>
      CopyWith$Input$QrCodeWhereUniqueInput.stub(_res);
  CopyWith$Input$QrCodeUpdateWithoutScannedByInput<TRes> get update =>
      CopyWith$Input$QrCodeUpdateWithoutScannedByInput.stub(_res);
  CopyWith$Input$QrCodeCreateWithoutScannedByInput<TRes> get create =>
      CopyWith$Input$QrCodeCreateWithoutScannedByInput.stub(_res);
}

class Input$QrCodeWhereInput {
  factory Input$QrCodeWhereInput({
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  }) =>
      Input$QrCodeWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (guestId != null) r'guestId': guestId,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
        if (guest != null) r'guest': guest,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeWhereInput._(this._$data);

  factory Input$QrCodeWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFilter.fromJson((l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = l$scannedByUserId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$scannedByUserId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserNullableRelationFilter.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$QrCodeWhereInput>? get AND =>
      (_$data['AND'] as List<Input$QrCodeWhereInput>?);
  List<Input$QrCodeWhereInput>? get OR =>
      (_$data['OR'] as List<Input$QrCodeWhereInput>?);
  List<Input$QrCodeWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$QrCodeWhereInput>?);
  Input$StringFilter? get path => (_$data['path'] as Input$StringFilter?);
  Input$DateTimeNullableFilter? get scannedAt =>
      (_$data['scannedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$StringNullableFilter? get scannedByUserId =>
      (_$data['scannedByUserId'] as Input$StringNullableFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Input$UserNullableRelationFilter? get scannedBy =>
      (_$data['scannedBy'] as Input$UserNullableRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput> get copyWith =>
      CopyWith$Input$QrCodeWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$guestId = guestId;
    final l$scannedByUserId = scannedByUserId;
    final l$guest = guest;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeWhereInput<TRes> {
  factory CopyWith$Input$QrCodeWhereInput(
    Input$QrCodeWhereInput instance,
    TRes Function(Input$QrCodeWhereInput) then,
  ) = _CopyWithImpl$Input$QrCodeWhereInput;

  factory CopyWith$Input$QrCodeWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeWhereInput;

  TRes call({
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  });
  TRes AND(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get path;
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeWhereInput<TRes>
    implements CopyWith$Input$QrCodeWhereInput<TRes> {
  _CopyWithImpl$Input$QrCodeWhereInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeWhereInput _instance;

  final TRes Function(Input$QrCodeWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? guestId = _undefined,
    Object? scannedByUserId = _undefined,
    Object? guest = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$QrCodeWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$QrCodeWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$QrCodeWhereInput>?),
        if (path != _undefined) 'path': (path as Input$StringFilter?),
        if (scannedAt != _undefined)
          'scannedAt': (scannedAt as Input$DateTimeNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as Input$StringNullableFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
        if (scannedBy != _undefined)
          'scannedBy': (scannedBy as Input$UserNullableRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId {
    final local$scannedByUserId = _instance.scannedByUserId;
    return local$scannedByUserId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$scannedByUserId, (e) => call(scannedByUserId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }

  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$UserNullableRelationFilter(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeWhereInput<TRes>
    implements CopyWith$Input$QrCodeWhereInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeWhereInput(this._res);

  TRes _res;

  call({
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringFilter? guestId,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get path =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy =>
      CopyWith$Input$UserNullableRelationFilter.stub(_res);
}

class Input$QrCodeWhereUniqueInput {
  factory Input$QrCodeWhereUniqueInput({
    String? guestId,
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  }) =>
      Input$QrCodeWhereUniqueInput._({
        if (guestId != null) r'guestId': guestId,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (path != null) r'path': path,
        if (scannedAt != null) r'scannedAt': scannedAt,
        if (createdAt != null) r'createdAt': createdAt,
        if (scannedByUserId != null) r'scannedByUserId': scannedByUserId,
        if (guest != null) r'guest': guest,
        if (scannedBy != null) r'scannedBy': scannedBy,
      });

  Input$QrCodeWhereUniqueInput._(this._$data);

  factory Input$QrCodeWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as String?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$QrCodeWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = l$path == null
          ? null
          : Input$StringFilter.fromJson((l$path as Map<String, dynamic>));
    }
    if (data.containsKey('scannedAt')) {
      final l$scannedAt = data['scannedAt'];
      result$data['scannedAt'] = l$scannedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$scannedAt as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = data['scannedByUserId'];
      result$data['scannedByUserId'] = l$scannedByUserId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$scannedByUserId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    if (data.containsKey('scannedBy')) {
      final l$scannedBy = data['scannedBy'];
      result$data['scannedBy'] = l$scannedBy == null
          ? null
          : Input$UserNullableRelationFilter.fromJson(
              (l$scannedBy as Map<String, dynamic>));
    }
    return Input$QrCodeWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get guestId => (_$data['guestId'] as String?);
  List<Input$QrCodeWhereInput>? get AND =>
      (_$data['AND'] as List<Input$QrCodeWhereInput>?);
  List<Input$QrCodeWhereInput>? get OR =>
      (_$data['OR'] as List<Input$QrCodeWhereInput>?);
  List<Input$QrCodeWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$QrCodeWhereInput>?);
  Input$StringFilter? get path => (_$data['path'] as Input$StringFilter?);
  Input$DateTimeNullableFilter? get scannedAt =>
      (_$data['scannedAt'] as Input$DateTimeNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$StringNullableFilter? get scannedByUserId =>
      (_$data['scannedByUserId'] as Input$StringNullableFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Input$UserNullableRelationFilter? get scannedBy =>
      (_$data['scannedBy'] as Input$UserNullableRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path?.toJson();
    }
    if (_$data.containsKey('scannedAt')) {
      final l$scannedAt = scannedAt;
      result$data['scannedAt'] = l$scannedAt?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('scannedByUserId')) {
      final l$scannedByUserId = scannedByUserId;
      result$data['scannedByUserId'] = l$scannedByUserId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    if (_$data.containsKey('scannedBy')) {
      final l$scannedBy = scannedBy;
      result$data['scannedBy'] = l$scannedBy?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$QrCodeWhereUniqueInput<Input$QrCodeWhereUniqueInput>
      get copyWith => CopyWith$Input$QrCodeWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$QrCodeWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$scannedAt = scannedAt;
    final lOther$scannedAt = other.scannedAt;
    if (_$data.containsKey('scannedAt') !=
        other._$data.containsKey('scannedAt')) {
      return false;
    }
    if (l$scannedAt != lOther$scannedAt) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$scannedByUserId = scannedByUserId;
    final lOther$scannedByUserId = other.scannedByUserId;
    if (_$data.containsKey('scannedByUserId') !=
        other._$data.containsKey('scannedByUserId')) {
      return false;
    }
    if (l$scannedByUserId != lOther$scannedByUserId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    final l$scannedBy = scannedBy;
    final lOther$scannedBy = other.scannedBy;
    if (_$data.containsKey('scannedBy') !=
        other._$data.containsKey('scannedBy')) {
      return false;
    }
    if (l$scannedBy != lOther$scannedBy) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$guestId = guestId;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$path = path;
    final l$scannedAt = scannedAt;
    final l$createdAt = createdAt;
    final l$scannedByUserId = scannedByUserId;
    final l$guest = guest;
    final l$scannedBy = scannedBy;
    return Object.hashAll([
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('scannedAt') ? l$scannedAt : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('scannedByUserId') ? l$scannedByUserId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
      _$data.containsKey('scannedBy') ? l$scannedBy : const {},
    ]);
  }
}

abstract class CopyWith$Input$QrCodeWhereUniqueInput<TRes> {
  factory CopyWith$Input$QrCodeWhereUniqueInput(
    Input$QrCodeWhereUniqueInput instance,
    TRes Function(Input$QrCodeWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$QrCodeWhereUniqueInput;

  factory CopyWith$Input$QrCodeWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$QrCodeWhereUniqueInput;

  TRes call({
    String? guestId,
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  });
  TRes AND(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$QrCodeWhereInput>? Function(
              Iterable<
                  CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get path;
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy;
}

class _CopyWithImpl$Input$QrCodeWhereUniqueInput<TRes>
    implements CopyWith$Input$QrCodeWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$QrCodeWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$QrCodeWhereUniqueInput _instance;

  final TRes Function(Input$QrCodeWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? guestId = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? path = _undefined,
    Object? scannedAt = _undefined,
    Object? createdAt = _undefined,
    Object? scannedByUserId = _undefined,
    Object? guest = _undefined,
    Object? scannedBy = _undefined,
  }) =>
      _then(Input$QrCodeWhereUniqueInput._({
        ..._instance._$data,
        if (guestId != _undefined) 'guestId': (guestId as String?),
        if (AND != _undefined) 'AND': (AND as List<Input$QrCodeWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$QrCodeWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$QrCodeWhereInput>?),
        if (path != _undefined) 'path': (path as Input$StringFilter?),
        if (scannedAt != _undefined)
          'scannedAt': (scannedAt as Input$DateTimeNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (scannedByUserId != _undefined)
          'scannedByUserId': (scannedByUserId as Input$StringNullableFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
        if (scannedBy != _undefined)
          'scannedBy': (scannedBy as Input$UserNullableRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$QrCodeWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$QrCodeWhereInput<Input$QrCodeWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$QrCodeWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get path {
    final local$path = _instance.path;
    return local$path == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$path, (e) => call(path: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt {
    final local$scannedAt = _instance.scannedAt;
    return local$scannedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$scannedAt, (e) => call(scannedAt: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId {
    final local$scannedByUserId = _instance.scannedByUserId;
    return local$scannedByUserId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$scannedByUserId, (e) => call(scannedByUserId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }

  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy {
    final local$scannedBy = _instance.scannedBy;
    return local$scannedBy == null
        ? CopyWith$Input$UserNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$UserNullableRelationFilter(
            local$scannedBy, (e) => call(scannedBy: e));
  }
}

class _CopyWithStubImpl$Input$QrCodeWhereUniqueInput<TRes>
    implements CopyWith$Input$QrCodeWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$QrCodeWhereUniqueInput(this._res);

  TRes _res;

  call({
    String? guestId,
    List<Input$QrCodeWhereInput>? AND,
    List<Input$QrCodeWhereInput>? OR,
    List<Input$QrCodeWhereInput>? NOT,
    Input$StringFilter? path,
    Input$DateTimeNullableFilter? scannedAt,
    Input$DateTimeFilter? createdAt,
    Input$StringNullableFilter? scannedByUserId,
    Input$GuestRelationFilter? guest,
    Input$UserNullableRelationFilter? scannedBy,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get path =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get scannedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get scannedByUserId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
  CopyWith$Input$UserNullableRelationFilter<TRes> get scannedBy =>
      CopyWith$Input$UserNullableRelationFilter.stub(_res);
}

class Input$SortOrderInput {
  factory Input$SortOrderInput({
    required Enum$SortOrder sort,
    Enum$NullsOrder? nulls,
  }) =>
      Input$SortOrderInput._({
        r'sort': sort,
        if (nulls != null) r'nulls': nulls,
      });

  Input$SortOrderInput._(this._$data);

  factory Input$SortOrderInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$sort = data['sort'];
    result$data['sort'] = fromJson$Enum$SortOrder((l$sort as String));
    if (data.containsKey('nulls')) {
      final l$nulls = data['nulls'];
      result$data['nulls'] = l$nulls == null
          ? null
          : fromJson$Enum$NullsOrder((l$nulls as String));
    }
    return Input$SortOrderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder get sort => (_$data['sort'] as Enum$SortOrder);
  Enum$NullsOrder? get nulls => (_$data['nulls'] as Enum$NullsOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$sort = sort;
    result$data['sort'] = toJson$Enum$SortOrder(l$sort);
    if (_$data.containsKey('nulls')) {
      final l$nulls = nulls;
      result$data['nulls'] =
          l$nulls == null ? null : toJson$Enum$NullsOrder(l$nulls);
    }
    return result$data;
  }

  CopyWith$Input$SortOrderInput<Input$SortOrderInput> get copyWith =>
      CopyWith$Input$SortOrderInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SortOrderInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$sort = sort;
    final lOther$sort = other.sort;
    if (l$sort != lOther$sort) {
      return false;
    }
    final l$nulls = nulls;
    final lOther$nulls = other.nulls;
    if (_$data.containsKey('nulls') != other._$data.containsKey('nulls')) {
      return false;
    }
    if (l$nulls != lOther$nulls) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$sort = sort;
    final l$nulls = nulls;
    return Object.hashAll([
      l$sort,
      _$data.containsKey('nulls') ? l$nulls : const {},
    ]);
  }
}

abstract class CopyWith$Input$SortOrderInput<TRes> {
  factory CopyWith$Input$SortOrderInput(
    Input$SortOrderInput instance,
    TRes Function(Input$SortOrderInput) then,
  ) = _CopyWithImpl$Input$SortOrderInput;

  factory CopyWith$Input$SortOrderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SortOrderInput;

  TRes call({
    Enum$SortOrder? sort,
    Enum$NullsOrder? nulls,
  });
}

class _CopyWithImpl$Input$SortOrderInput<TRes>
    implements CopyWith$Input$SortOrderInput<TRes> {
  _CopyWithImpl$Input$SortOrderInput(
    this._instance,
    this._then,
  );

  final Input$SortOrderInput _instance;

  final TRes Function(Input$SortOrderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? sort = _undefined,
    Object? nulls = _undefined,
  }) =>
      _then(Input$SortOrderInput._({
        ..._instance._$data,
        if (sort != _undefined && sort != null)
          'sort': (sort as Enum$SortOrder),
        if (nulls != _undefined) 'nulls': (nulls as Enum$NullsOrder?),
      }));
}

class _CopyWithStubImpl$Input$SortOrderInput<TRes>
    implements CopyWith$Input$SortOrderInput<TRes> {
  _CopyWithStubImpl$Input$SortOrderInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? sort,
    Enum$NullsOrder? nulls,
  }) =>
      _res;
}

class Input$StringFieldUpdateOperationsInput {
  factory Input$StringFieldUpdateOperationsInput({String? $set}) =>
      Input$StringFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$StringFieldUpdateOperationsInput._(this._$data);

  factory Input$StringFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$StringFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<
          Input$StringFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$StringFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$StringFieldUpdateOperationsInput(
    Input$StringFieldUpdateOperationsInput instance,
    TRes Function(Input$StringFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$StringFieldUpdateOperationsInput;

  factory CopyWith$Input$StringFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$StringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$StringFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$StringFieldUpdateOperationsInput _instance;

  final TRes Function(Input$StringFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$StringFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$StringFilter {
  factory Input$StringFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      Input$StringFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$StringFilter._(this._$data);

  factory Input$StringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$StringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringFilter? get not =>
      (_$data['not'] as Input$NestedStringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$StringFilter<Input$StringFilter> get copyWith =>
      CopyWith$Input$StringFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringFilter<TRes> {
  factory CopyWith$Input$StringFilter(
    Input$StringFilter instance,
    TRes Function(Input$StringFilter) then,
  ) = _CopyWithImpl$Input$StringFilter;

  factory CopyWith$Input$StringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  });
  CopyWith$Input$NestedStringFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithImpl$Input$StringFilter(
    this._instance,
    this._then,
  );

  final Input$StringFilter _instance;

  final TRes Function(Input$StringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$StringFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined) 'not': (not as Input$NestedStringFilter?),
      }));
  CopyWith$Input$NestedStringFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithStubImpl$Input$StringFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringFilter<TRes> get not =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$StringNullableFilter {
  factory Input$StringNullableFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  }) =>
      Input$StringNullableFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$StringNullableFilter._(this._$data);

  factory Input$StringNullableFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringNullableFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$StringNullableFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringNullableFilter? get not =>
      (_$data['not'] as Input$NestedStringNullableFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$StringNullableFilter<Input$StringNullableFilter>
      get copyWith => CopyWith$Input$StringNullableFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringNullableFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringNullableFilter<TRes> {
  factory CopyWith$Input$StringNullableFilter(
    Input$StringNullableFilter instance,
    TRes Function(Input$StringNullableFilter) then,
  ) = _CopyWithImpl$Input$StringNullableFilter;

  factory CopyWith$Input$StringNullableFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringNullableFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  });
  CopyWith$Input$NestedStringNullableFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringNullableFilter<TRes>
    implements CopyWith$Input$StringNullableFilter<TRes> {
  _CopyWithImpl$Input$StringNullableFilter(
    this._instance,
    this._then,
  );

  final Input$StringNullableFilter _instance;

  final TRes Function(Input$StringNullableFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$StringNullableFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringNullableFilter?),
      }));
  CopyWith$Input$NestedStringNullableFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringNullableFilter(
            local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringNullableFilter<TRes>
    implements CopyWith$Input$StringNullableFilter<TRes> {
  _CopyWithStubImpl$Input$StringNullableFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringNullableFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringNullableFilter<TRes> get not =>
      CopyWith$Input$NestedStringNullableFilter.stub(_res);
}

class Input$UserCountAggregateInput {
  factory Input$UserCountAggregateInput({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
    bool? $_all,
  }) =>
      Input$UserCountAggregateInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if ($_all != null) r'_all': $_all,
      });

  Input$UserCountAggregateInput._(this._$data);

  factory Input$UserCountAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = (l$fullName as bool?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as bool?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as bool?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as bool?);
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = (l$guestInfoId as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$UserCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get fullName => (_$data['fullName'] as bool?);
  bool? get email => (_$data['email'] as bool?);
  bool? get password => (_$data['password'] as bool?);
  bool? get whatsapp => (_$data['whatsapp'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get role => (_$data['role'] as bool?);
  bool? get guestInfoId => (_$data['guestInfoId'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$UserCountAggregateInput<Input$UserCountAggregateInput>
      get copyWith => CopyWith$Input$UserCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCountAggregateInput<TRes> {
  factory CopyWith$Input$UserCountAggregateInput(
    Input$UserCountAggregateInput instance,
    TRes Function(Input$UserCountAggregateInput) then,
  ) = _CopyWithImpl$Input$UserCountAggregateInput;

  factory CopyWith$Input$UserCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCountAggregateInput;

  TRes call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$UserCountAggregateInput<TRes>
    implements CopyWith$Input$UserCountAggregateInput<TRes> {
  _CopyWithImpl$Input$UserCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$UserCountAggregateInput _instance;

  final TRes Function(Input$UserCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$UserCountAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (fullName != _undefined) 'fullName': (fullName as bool?),
        if (email != _undefined) 'email': (email as bool?),
        if (password != _undefined) 'password': (password as bool?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (role != _undefined) 'role': (role as bool?),
        if (guestInfoId != _undefined) 'guestInfoId': (guestInfoId as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$UserCountAggregateInput<TRes>
    implements CopyWith$Input$UserCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$UserCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
    bool? $_all,
  }) =>
      _res;
}

class Input$UserCreateInput {
  factory Input$UserCreateInput({
    String? id,
    required String fullName,
    String? email,
    required String password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    required Enum$UserRole role,
    String? guestInfoId,
    Input$GuestCreateNestedOneWithoutUserInput? guestInfo,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? QrCode,
  }) =>
      Input$UserCreateInput._({
        if (id != null) r'id': id,
        r'fullName': fullName,
        if (email != null) r'email': email,
        r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (guestInfo != null) r'guestInfo': guestInfo,
        if (QrCode != null) r'QrCode': QrCode,
      });

  Input$UserCreateInput._(this._$data);

  factory Input$UserCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$UserRole((l$role as String));
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = (l$guestInfoId as String?);
    }
    if (data.containsKey('guestInfo')) {
      final l$guestInfo = data['guestInfo'];
      result$data['guestInfo'] = l$guestInfo == null
          ? null
          : Input$GuestCreateNestedOneWithoutUserInput.fromJson(
              (l$guestInfo as Map<String, dynamic>));
    }
    if (data.containsKey('QrCode')) {
      final l$QrCode = data['QrCode'];
      result$data['QrCode'] = l$QrCode == null
          ? null
          : Input$QrCodeCreateNestedManyWithoutScannedByInput.fromJson(
              (l$QrCode as Map<String, dynamic>));
    }
    return Input$UserCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get fullName => (_$data['fullName'] as String);
  String? get email => (_$data['email'] as String?);
  String get password => (_$data['password'] as String);
  String? get whatsapp => (_$data['whatsapp'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$UserRole get role => (_$data['role'] as Enum$UserRole);
  String? get guestInfoId => (_$data['guestInfoId'] as String?);
  Input$GuestCreateNestedOneWithoutUserInput? get guestInfo =>
      (_$data['guestInfo'] as Input$GuestCreateNestedOneWithoutUserInput?);
  Input$QrCodeCreateNestedManyWithoutScannedByInput? get QrCode =>
      (_$data['QrCode'] as Input$QrCodeCreateNestedManyWithoutScannedByInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    final l$password = password;
    result$data['password'] = l$password;
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    final l$role = role;
    result$data['role'] = toJson$Enum$UserRole(l$role);
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId;
    }
    if (_$data.containsKey('guestInfo')) {
      final l$guestInfo = guestInfo;
      result$data['guestInfo'] = l$guestInfo?.toJson();
    }
    if (_$data.containsKey('QrCode')) {
      final l$QrCode = QrCode;
      result$data['QrCode'] = l$QrCode?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserCreateInput<Input$UserCreateInput> get copyWith =>
      CopyWith$Input$UserCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$guestInfo = guestInfo;
    final lOther$guestInfo = other.guestInfo;
    if (_$data.containsKey('guestInfo') !=
        other._$data.containsKey('guestInfo')) {
      return false;
    }
    if (l$guestInfo != lOther$guestInfo) {
      return false;
    }
    final l$QrCode = QrCode;
    final lOther$QrCode = other.QrCode;
    if (_$data.containsKey('QrCode') != other._$data.containsKey('QrCode')) {
      return false;
    }
    if (l$QrCode != lOther$QrCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$guestInfo = guestInfo;
    final l$QrCode = QrCode;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$fullName,
      _$data.containsKey('email') ? l$email : const {},
      l$password,
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      l$role,
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('guestInfo') ? l$guestInfo : const {},
      _$data.containsKey('QrCode') ? l$QrCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateInput<TRes> {
  factory CopyWith$Input$UserCreateInput(
    Input$UserCreateInput instance,
    TRes Function(Input$UserCreateInput) then,
  ) = _CopyWithImpl$Input$UserCreateInput;

  factory CopyWith$Input$UserCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateInput;

  TRes call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    String? guestInfoId,
    Input$GuestCreateNestedOneWithoutUserInput? guestInfo,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? QrCode,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> get guestInfo;
  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> get QrCode;
}

class _CopyWithImpl$Input$UserCreateInput<TRes>
    implements CopyWith$Input$UserCreateInput<TRes> {
  _CopyWithImpl$Input$UserCreateInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateInput _instance;

  final TRes Function(Input$UserCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? guestInfo = _undefined,
    Object? QrCode = _undefined,
  }) =>
      _then(Input$UserCreateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (fullName != _undefined && fullName != null)
          'fullName': (fullName as String),
        if (email != _undefined) 'email': (email as String?),
        if (password != _undefined && password != null)
          'password': (password as String),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (role != _undefined && role != null) 'role': (role as Enum$UserRole),
        if (guestInfoId != _undefined) 'guestInfoId': (guestInfoId as String?),
        if (guestInfo != _undefined)
          'guestInfo':
              (guestInfo as Input$GuestCreateNestedOneWithoutUserInput?),
        if (QrCode != _undefined)
          'QrCode':
              (QrCode as Input$QrCodeCreateNestedManyWithoutScannedByInput?),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> get guestInfo {
    final local$guestInfo = _instance.guestInfo;
    return local$guestInfo == null
        ? CopyWith$Input$GuestCreateNestedOneWithoutUserInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedOneWithoutUserInput(
            local$guestInfo, (e) => call(guestInfo: e));
  }

  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> get QrCode {
    final local$QrCode = _instance.QrCode;
    return local$QrCode == null
        ? CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput(
            local$QrCode, (e) => call(QrCode: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateInput<TRes>
    implements CopyWith$Input$UserCreateInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateInput(this._res);

  TRes _res;

  call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    String? guestInfoId,
    Input$GuestCreateNestedOneWithoutUserInput? guestInfo,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? QrCode,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> get guestInfo =>
      CopyWith$Input$GuestCreateNestedOneWithoutUserInput.stub(_res);
  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> get QrCode =>
      CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput.stub(_res);
}

class Input$UserCreateManyInput {
  factory Input$UserCreateManyInput({
    String? id,
    required String fullName,
    String? email,
    required String password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    required Enum$UserRole role,
    String? guestInfoId,
  }) =>
      Input$UserCreateManyInput._({
        if (id != null) r'id': id,
        r'fullName': fullName,
        if (email != null) r'email': email,
        r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
      });

  Input$UserCreateManyInput._(this._$data);

  factory Input$UserCreateManyInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$UserRole((l$role as String));
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = (l$guestInfoId as String?);
    }
    return Input$UserCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get fullName => (_$data['fullName'] as String);
  String? get email => (_$data['email'] as String?);
  String get password => (_$data['password'] as String);
  String? get whatsapp => (_$data['whatsapp'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$UserRole get role => (_$data['role'] as Enum$UserRole);
  String? get guestInfoId => (_$data['guestInfoId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    final l$password = password;
    result$data['password'] = l$password;
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    final l$role = role;
    result$data['role'] = toJson$Enum$UserRole(l$role);
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId;
    }
    return result$data;
  }

  CopyWith$Input$UserCreateManyInput<Input$UserCreateManyInput> get copyWith =>
      CopyWith$Input$UserCreateManyInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$fullName,
      _$data.containsKey('email') ? l$email : const {},
      l$password,
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      l$role,
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateManyInput<TRes> {
  factory CopyWith$Input$UserCreateManyInput(
    Input$UserCreateManyInput instance,
    TRes Function(Input$UserCreateManyInput) then,
  ) = _CopyWithImpl$Input$UserCreateManyInput;

  factory CopyWith$Input$UserCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateManyInput;

  TRes call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    String? guestInfoId,
  });
}

class _CopyWithImpl$Input$UserCreateManyInput<TRes>
    implements CopyWith$Input$UserCreateManyInput<TRes> {
  _CopyWithImpl$Input$UserCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateManyInput _instance;

  final TRes Function(Input$UserCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
  }) =>
      _then(Input$UserCreateManyInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (fullName != _undefined && fullName != null)
          'fullName': (fullName as String),
        if (email != _undefined) 'email': (email as String?),
        if (password != _undefined && password != null)
          'password': (password as String),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (role != _undefined && role != null) 'role': (role as Enum$UserRole),
        if (guestInfoId != _undefined) 'guestInfoId': (guestInfoId as String?),
      }));
}

class _CopyWithStubImpl$Input$UserCreateManyInput<TRes>
    implements CopyWith$Input$UserCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateManyInput(this._res);

  TRes _res;

  call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    String? guestInfoId,
  }) =>
      _res;
}

class Input$UserCreateNestedOneWithoutGuestInfoInput {
  factory Input$UserCreateNestedOneWithoutGuestInfoInput({
    Input$UserCreateWithoutGuestInfoInput? create,
    Input$UserCreateOrConnectWithoutGuestInfoInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  }) =>
      Input$UserCreateNestedOneWithoutGuestInfoInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$UserCreateNestedOneWithoutGuestInfoInput._(this._$data);

  factory Input$UserCreateNestedOneWithoutGuestInfoInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$UserCreateWithoutGuestInfoInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$UserCreateOrConnectWithoutGuestInfoInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$UserWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$UserCreateNestedOneWithoutGuestInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserCreateWithoutGuestInfoInput? get create =>
      (_$data['create'] as Input$UserCreateWithoutGuestInfoInput?);
  Input$UserCreateOrConnectWithoutGuestInfoInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$UserCreateOrConnectWithoutGuestInfoInput?);
  Input$UserWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$UserWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<
          Input$UserCreateNestedOneWithoutGuestInfoInput>
      get copyWith => CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateNestedOneWithoutGuestInfoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> {
  factory CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput(
    Input$UserCreateNestedOneWithoutGuestInfoInput instance,
    TRes Function(Input$UserCreateNestedOneWithoutGuestInfoInput) then,
  ) = _CopyWithImpl$Input$UserCreateNestedOneWithoutGuestInfoInput;

  factory CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserCreateNestedOneWithoutGuestInfoInput;

  TRes call({
    Input$UserCreateWithoutGuestInfoInput? create,
    Input$UserCreateOrConnectWithoutGuestInfoInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  });
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create;
  CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes>
      get connectOrCreate;
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> {
  _CopyWithImpl$Input$UserCreateNestedOneWithoutGuestInfoInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateNestedOneWithoutGuestInfoInput _instance;

  final TRes Function(Input$UserCreateNestedOneWithoutGuestInfoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$UserCreateNestedOneWithoutGuestInfoInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$UserCreateWithoutGuestInfoInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$UserCreateOrConnectWithoutGuestInfoInput?),
        if (connect != _undefined)
          'connect': (connect as Input$UserWhereUniqueInput?),
      }));
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$UserCreateWithoutGuestInfoInput.stub(_then(_instance))
        : CopyWith$Input$UserCreateWithoutGuestInfoInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$UserWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$UserWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserCreateNestedOneWithoutGuestInfoInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateNestedOneWithoutGuestInfoInput(this._res);

  TRes _res;

  call({
    Input$UserCreateWithoutGuestInfoInput? create,
    Input$UserCreateOrConnectWithoutGuestInfoInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
}

class Input$UserCreateNestedOneWithoutQrCodeInput {
  factory Input$UserCreateNestedOneWithoutQrCodeInput({
    Input$UserCreateWithoutQrCodeInput? create,
    Input$UserCreateOrConnectWithoutQrCodeInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  }) =>
      Input$UserCreateNestedOneWithoutQrCodeInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$UserCreateNestedOneWithoutQrCodeInput._(this._$data);

  factory Input$UserCreateNestedOneWithoutQrCodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$UserCreateWithoutQrCodeInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$UserCreateOrConnectWithoutQrCodeInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$UserWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$UserCreateNestedOneWithoutQrCodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserCreateWithoutQrCodeInput? get create =>
      (_$data['create'] as Input$UserCreateWithoutQrCodeInput?);
  Input$UserCreateOrConnectWithoutQrCodeInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$UserCreateOrConnectWithoutQrCodeInput?);
  Input$UserWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$UserWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput<
          Input$UserCreateNestedOneWithoutQrCodeInput>
      get copyWith => CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateNestedOneWithoutQrCodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput<TRes> {
  factory CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput(
    Input$UserCreateNestedOneWithoutQrCodeInput instance,
    TRes Function(Input$UserCreateNestedOneWithoutQrCodeInput) then,
  ) = _CopyWithImpl$Input$UserCreateNestedOneWithoutQrCodeInput;

  factory CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateNestedOneWithoutQrCodeInput;

  TRes call({
    Input$UserCreateWithoutQrCodeInput? create,
    Input$UserCreateOrConnectWithoutQrCodeInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  });
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create;
  CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes>
      get connectOrCreate;
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$UserCreateNestedOneWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput<TRes> {
  _CopyWithImpl$Input$UserCreateNestedOneWithoutQrCodeInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateNestedOneWithoutQrCodeInput _instance;

  final TRes Function(Input$UserCreateNestedOneWithoutQrCodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$UserCreateNestedOneWithoutQrCodeInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$UserCreateWithoutQrCodeInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate':
              (connectOrCreate as Input$UserCreateOrConnectWithoutQrCodeInput?),
        if (connect != _undefined)
          'connect': (connect as Input$UserWhereUniqueInput?),
      }));
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$UserCreateWithoutQrCodeInput.stub(_then(_instance))
        : CopyWith$Input$UserCreateWithoutQrCodeInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$UserWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$UserWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateNestedOneWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserCreateNestedOneWithoutQrCodeInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateNestedOneWithoutQrCodeInput(this._res);

  TRes _res;

  call({
    Input$UserCreateWithoutQrCodeInput? create,
    Input$UserCreateOrConnectWithoutQrCodeInput? connectOrCreate,
    Input$UserWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutQrCodeInput.stub(_res);
  CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput.stub(_res);
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
}

class Input$UserCreateOrConnectWithoutGuestInfoInput {
  factory Input$UserCreateOrConnectWithoutGuestInfoInput({
    required Input$UserWhereUniqueInput where,
    required Input$UserCreateWithoutGuestInfoInput create,
  }) =>
      Input$UserCreateOrConnectWithoutGuestInfoInput._({
        r'where': where,
        r'create': create,
      });

  Input$UserCreateOrConnectWithoutGuestInfoInput._(this._$data);

  factory Input$UserCreateOrConnectWithoutGuestInfoInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$UserWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$UserCreateWithoutGuestInfoInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$UserCreateOrConnectWithoutGuestInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereUniqueInput get where =>
      (_$data['where'] as Input$UserWhereUniqueInput);
  Input$UserCreateWithoutGuestInfoInput get create =>
      (_$data['create'] as Input$UserCreateWithoutGuestInfoInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<
          Input$UserCreateOrConnectWithoutGuestInfoInput>
      get copyWith => CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateOrConnectWithoutGuestInfoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes> {
  factory CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput(
    Input$UserCreateOrConnectWithoutGuestInfoInput instance,
    TRes Function(Input$UserCreateOrConnectWithoutGuestInfoInput) then,
  ) = _CopyWithImpl$Input$UserCreateOrConnectWithoutGuestInfoInput;

  factory CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserCreateOrConnectWithoutGuestInfoInput;

  TRes call({
    Input$UserWhereUniqueInput? where,
    Input$UserCreateWithoutGuestInfoInput? create,
  });
  CopyWith$Input$UserWhereUniqueInput<TRes> get where;
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create;
}

class _CopyWithImpl$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes> {
  _CopyWithImpl$Input$UserCreateOrConnectWithoutGuestInfoInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateOrConnectWithoutGuestInfoInput _instance;

  final TRes Function(Input$UserCreateOrConnectWithoutGuestInfoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$UserCreateOrConnectWithoutGuestInfoInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$UserWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$UserCreateWithoutGuestInfoInput),
      }));
  CopyWith$Input$UserWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$UserWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$UserCreateWithoutGuestInfoInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateOrConnectWithoutGuestInfoInput(this._res);

  TRes _res;

  call({
    Input$UserWhereUniqueInput? where,
    Input$UserCreateWithoutGuestInfoInput? create,
  }) =>
      _res;
  CopyWith$Input$UserWhereUniqueInput<TRes> get where =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutGuestInfoInput.stub(_res);
}

class Input$UserCreateOrConnectWithoutQrCodeInput {
  factory Input$UserCreateOrConnectWithoutQrCodeInput({
    required Input$UserWhereUniqueInput where,
    required Input$UserCreateWithoutQrCodeInput create,
  }) =>
      Input$UserCreateOrConnectWithoutQrCodeInput._({
        r'where': where,
        r'create': create,
      });

  Input$UserCreateOrConnectWithoutQrCodeInput._(this._$data);

  factory Input$UserCreateOrConnectWithoutQrCodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$UserWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$UserCreateWithoutQrCodeInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$UserCreateOrConnectWithoutQrCodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereUniqueInput get where =>
      (_$data['where'] as Input$UserWhereUniqueInput);
  Input$UserCreateWithoutQrCodeInput get create =>
      (_$data['create'] as Input$UserCreateWithoutQrCodeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<
          Input$UserCreateOrConnectWithoutQrCodeInput>
      get copyWith => CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateOrConnectWithoutQrCodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes> {
  factory CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput(
    Input$UserCreateOrConnectWithoutQrCodeInput instance,
    TRes Function(Input$UserCreateOrConnectWithoutQrCodeInput) then,
  ) = _CopyWithImpl$Input$UserCreateOrConnectWithoutQrCodeInput;

  factory CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateOrConnectWithoutQrCodeInput;

  TRes call({
    Input$UserWhereUniqueInput? where,
    Input$UserCreateWithoutQrCodeInput? create,
  });
  CopyWith$Input$UserWhereUniqueInput<TRes> get where;
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create;
}

class _CopyWithImpl$Input$UserCreateOrConnectWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes> {
  _CopyWithImpl$Input$UserCreateOrConnectWithoutQrCodeInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateOrConnectWithoutQrCodeInput _instance;

  final TRes Function(Input$UserCreateOrConnectWithoutQrCodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$UserCreateOrConnectWithoutQrCodeInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$UserWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$UserCreateWithoutQrCodeInput),
      }));
  CopyWith$Input$UserWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$UserWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$UserCreateWithoutQrCodeInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateOrConnectWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateOrConnectWithoutQrCodeInput(this._res);

  TRes _res;

  call({
    Input$UserWhereUniqueInput? where,
    Input$UserCreateWithoutQrCodeInput? create,
  }) =>
      _res;
  CopyWith$Input$UserWhereUniqueInput<TRes> get where =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutQrCodeInput.stub(_res);
}

class Input$UserCreateWithoutGuestInfoInput {
  factory Input$UserCreateWithoutGuestInfoInput({
    String? id,
    required String fullName,
    String? email,
    required String password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    required Enum$UserRole role,
    String? guestInfoId,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? QrCode,
  }) =>
      Input$UserCreateWithoutGuestInfoInput._({
        if (id != null) r'id': id,
        r'fullName': fullName,
        if (email != null) r'email': email,
        r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (QrCode != null) r'QrCode': QrCode,
      });

  Input$UserCreateWithoutGuestInfoInput._(this._$data);

  factory Input$UserCreateWithoutGuestInfoInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$UserRole((l$role as String));
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = (l$guestInfoId as String?);
    }
    if (data.containsKey('QrCode')) {
      final l$QrCode = data['QrCode'];
      result$data['QrCode'] = l$QrCode == null
          ? null
          : Input$QrCodeCreateNestedManyWithoutScannedByInput.fromJson(
              (l$QrCode as Map<String, dynamic>));
    }
    return Input$UserCreateWithoutGuestInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get fullName => (_$data['fullName'] as String);
  String? get email => (_$data['email'] as String?);
  String get password => (_$data['password'] as String);
  String? get whatsapp => (_$data['whatsapp'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$UserRole get role => (_$data['role'] as Enum$UserRole);
  String? get guestInfoId => (_$data['guestInfoId'] as String?);
  Input$QrCodeCreateNestedManyWithoutScannedByInput? get QrCode =>
      (_$data['QrCode'] as Input$QrCodeCreateNestedManyWithoutScannedByInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    final l$password = password;
    result$data['password'] = l$password;
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    final l$role = role;
    result$data['role'] = toJson$Enum$UserRole(l$role);
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId;
    }
    if (_$data.containsKey('QrCode')) {
      final l$QrCode = QrCode;
      result$data['QrCode'] = l$QrCode?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserCreateWithoutGuestInfoInput<
          Input$UserCreateWithoutGuestInfoInput>
      get copyWith => CopyWith$Input$UserCreateWithoutGuestInfoInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateWithoutGuestInfoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$QrCode = QrCode;
    final lOther$QrCode = other.QrCode;
    if (_$data.containsKey('QrCode') != other._$data.containsKey('QrCode')) {
      return false;
    }
    if (l$QrCode != lOther$QrCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$QrCode = QrCode;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$fullName,
      _$data.containsKey('email') ? l$email : const {},
      l$password,
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      l$role,
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('QrCode') ? l$QrCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> {
  factory CopyWith$Input$UserCreateWithoutGuestInfoInput(
    Input$UserCreateWithoutGuestInfoInput instance,
    TRes Function(Input$UserCreateWithoutGuestInfoInput) then,
  ) = _CopyWithImpl$Input$UserCreateWithoutGuestInfoInput;

  factory CopyWith$Input$UserCreateWithoutGuestInfoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateWithoutGuestInfoInput;

  TRes call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    String? guestInfoId,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? QrCode,
  });
  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> get QrCode;
}

class _CopyWithImpl$Input$UserCreateWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> {
  _CopyWithImpl$Input$UserCreateWithoutGuestInfoInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateWithoutGuestInfoInput _instance;

  final TRes Function(Input$UserCreateWithoutGuestInfoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? QrCode = _undefined,
  }) =>
      _then(Input$UserCreateWithoutGuestInfoInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (fullName != _undefined && fullName != null)
          'fullName': (fullName as String),
        if (email != _undefined) 'email': (email as String?),
        if (password != _undefined && password != null)
          'password': (password as String),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (role != _undefined && role != null) 'role': (role as Enum$UserRole),
        if (guestInfoId != _undefined) 'guestInfoId': (guestInfoId as String?),
        if (QrCode != _undefined)
          'QrCode':
              (QrCode as Input$QrCodeCreateNestedManyWithoutScannedByInput?),
      }));
  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> get QrCode {
    final local$QrCode = _instance.QrCode;
    return local$QrCode == null
        ? CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput(
            local$QrCode, (e) => call(QrCode: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateWithoutGuestInfoInput(this._res);

  TRes _res;

  call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    String? guestInfoId,
    Input$QrCodeCreateNestedManyWithoutScannedByInput? QrCode,
  }) =>
      _res;
  CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput<TRes> get QrCode =>
      CopyWith$Input$QrCodeCreateNestedManyWithoutScannedByInput.stub(_res);
}

class Input$UserCreateWithoutQrCodeInput {
  factory Input$UserCreateWithoutQrCodeInput({
    String? id,
    required String fullName,
    String? email,
    required String password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    required Enum$UserRole role,
    String? guestInfoId,
    Input$GuestCreateNestedOneWithoutUserInput? guestInfo,
  }) =>
      Input$UserCreateWithoutQrCodeInput._({
        if (id != null) r'id': id,
        r'fullName': fullName,
        if (email != null) r'email': email,
        r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (guestInfo != null) r'guestInfo': guestInfo,
      });

  Input$UserCreateWithoutQrCodeInput._(this._$data);

  factory Input$UserCreateWithoutQrCodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    final l$fullName = data['fullName'];
    result$data['fullName'] = (l$fullName as String);
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    final l$password = data['password'];
    result$data['password'] = (l$password as String);
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as String?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as String?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as String?);
    }
    final l$role = data['role'];
    result$data['role'] = fromJson$Enum$UserRole((l$role as String));
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = (l$guestInfoId as String?);
    }
    if (data.containsKey('guestInfo')) {
      final l$guestInfo = data['guestInfo'];
      result$data['guestInfo'] = l$guestInfo == null
          ? null
          : Input$GuestCreateNestedOneWithoutUserInput.fromJson(
              (l$guestInfo as Map<String, dynamic>));
    }
    return Input$UserCreateWithoutQrCodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String get fullName => (_$data['fullName'] as String);
  String? get email => (_$data['email'] as String?);
  String get password => (_$data['password'] as String);
  String? get whatsapp => (_$data['whatsapp'] as String?);
  String? get createdAt => (_$data['createdAt'] as String?);
  String? get updatedAt => (_$data['updatedAt'] as String?);
  String? get deletedAt => (_$data['deletedAt'] as String?);
  Enum$UserRole get role => (_$data['role'] as Enum$UserRole);
  String? get guestInfoId => (_$data['guestInfoId'] as String?);
  Input$GuestCreateNestedOneWithoutUserInput? get guestInfo =>
      (_$data['guestInfo'] as Input$GuestCreateNestedOneWithoutUserInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    final l$fullName = fullName;
    result$data['fullName'] = l$fullName;
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    final l$password = password;
    result$data['password'] = l$password;
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    final l$role = role;
    result$data['role'] = toJson$Enum$UserRole(l$role);
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId;
    }
    if (_$data.containsKey('guestInfo')) {
      final l$guestInfo = guestInfo;
      result$data['guestInfo'] = l$guestInfo?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserCreateWithoutQrCodeInput<
          Input$UserCreateWithoutQrCodeInput>
      get copyWith => CopyWith$Input$UserCreateWithoutQrCodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserCreateWithoutQrCodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$guestInfo = guestInfo;
    final lOther$guestInfo = other.guestInfo;
    if (_$data.containsKey('guestInfo') !=
        other._$data.containsKey('guestInfo')) {
      return false;
    }
    if (l$guestInfo != lOther$guestInfo) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$guestInfo = guestInfo;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      l$fullName,
      _$data.containsKey('email') ? l$email : const {},
      l$password,
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      l$role,
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('guestInfo') ? l$guestInfo : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> {
  factory CopyWith$Input$UserCreateWithoutQrCodeInput(
    Input$UserCreateWithoutQrCodeInput instance,
    TRes Function(Input$UserCreateWithoutQrCodeInput) then,
  ) = _CopyWithImpl$Input$UserCreateWithoutQrCodeInput;

  factory CopyWith$Input$UserCreateWithoutQrCodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserCreateWithoutQrCodeInput;

  TRes call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    String? guestInfoId,
    Input$GuestCreateNestedOneWithoutUserInput? guestInfo,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> get guestInfo;
}

class _CopyWithImpl$Input$UserCreateWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> {
  _CopyWithImpl$Input$UserCreateWithoutQrCodeInput(
    this._instance,
    this._then,
  );

  final Input$UserCreateWithoutQrCodeInput _instance;

  final TRes Function(Input$UserCreateWithoutQrCodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? guestInfo = _undefined,
  }) =>
      _then(Input$UserCreateWithoutQrCodeInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (fullName != _undefined && fullName != null)
          'fullName': (fullName as String),
        if (email != _undefined) 'email': (email as String?),
        if (password != _undefined && password != null)
          'password': (password as String),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as String?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as String?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as String?),
        if (role != _undefined && role != null) 'role': (role as Enum$UserRole),
        if (guestInfoId != _undefined) 'guestInfoId': (guestInfoId as String?),
        if (guestInfo != _undefined)
          'guestInfo':
              (guestInfo as Input$GuestCreateNestedOneWithoutUserInput?),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> get guestInfo {
    final local$guestInfo = _instance.guestInfo;
    return local$guestInfo == null
        ? CopyWith$Input$GuestCreateNestedOneWithoutUserInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestCreateNestedOneWithoutUserInput(
            local$guestInfo, (e) => call(guestInfo: e));
  }
}

class _CopyWithStubImpl$Input$UserCreateWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> {
  _CopyWithStubImpl$Input$UserCreateWithoutQrCodeInput(this._res);

  TRes _res;

  call({
    String? id,
    String? fullName,
    String? email,
    String? password,
    String? whatsapp,
    String? createdAt,
    String? updatedAt,
    String? deletedAt,
    Enum$UserRole? role,
    String? guestInfoId,
    Input$GuestCreateNestedOneWithoutUserInput? guestInfo,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutUserInput<TRes> get guestInfo =>
      CopyWith$Input$GuestCreateNestedOneWithoutUserInput.stub(_res);
}

class Input$UserMaxAggregateInput {
  factory Input$UserMaxAggregateInput({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
  }) =>
      Input$UserMaxAggregateInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
      });

  Input$UserMaxAggregateInput._(this._$data);

  factory Input$UserMaxAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = (l$fullName as bool?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as bool?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as bool?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as bool?);
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = (l$guestInfoId as bool?);
    }
    return Input$UserMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get fullName => (_$data['fullName'] as bool?);
  bool? get email => (_$data['email'] as bool?);
  bool? get password => (_$data['password'] as bool?);
  bool? get whatsapp => (_$data['whatsapp'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get role => (_$data['role'] as bool?);
  bool? get guestInfoId => (_$data['guestInfoId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId;
    }
    return result$data;
  }

  CopyWith$Input$UserMaxAggregateInput<Input$UserMaxAggregateInput>
      get copyWith => CopyWith$Input$UserMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserMaxAggregateInput<TRes> {
  factory CopyWith$Input$UserMaxAggregateInput(
    Input$UserMaxAggregateInput instance,
    TRes Function(Input$UserMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$UserMaxAggregateInput;

  factory CopyWith$Input$UserMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserMaxAggregateInput;

  TRes call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
  });
}

class _CopyWithImpl$Input$UserMaxAggregateInput<TRes>
    implements CopyWith$Input$UserMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$UserMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$UserMaxAggregateInput _instance;

  final TRes Function(Input$UserMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
  }) =>
      _then(Input$UserMaxAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (fullName != _undefined) 'fullName': (fullName as bool?),
        if (email != _undefined) 'email': (email as bool?),
        if (password != _undefined) 'password': (password as bool?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (role != _undefined) 'role': (role as bool?),
        if (guestInfoId != _undefined) 'guestInfoId': (guestInfoId as bool?),
      }));
}

class _CopyWithStubImpl$Input$UserMaxAggregateInput<TRes>
    implements CopyWith$Input$UserMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$UserMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
  }) =>
      _res;
}

class Input$UserMinAggregateInput {
  factory Input$UserMinAggregateInput({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
  }) =>
      Input$UserMinAggregateInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
      });

  Input$UserMinAggregateInput._(this._$data);

  factory Input$UserMinAggregateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = (l$fullName as bool?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as bool?);
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = (l$password as bool?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = (l$updatedAt as bool?);
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = (l$deletedAt as bool?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = (l$role as bool?);
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = (l$guestInfoId as bool?);
    }
    return Input$UserMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get fullName => (_$data['fullName'] as bool?);
  bool? get email => (_$data['email'] as bool?);
  bool? get password => (_$data['password'] as bool?);
  bool? get whatsapp => (_$data['whatsapp'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get updatedAt => (_$data['updatedAt'] as bool?);
  bool? get deletedAt => (_$data['deletedAt'] as bool?);
  bool? get role => (_$data['role'] as bool?);
  bool? get guestInfoId => (_$data['guestInfoId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt;
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role;
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId;
    }
    return result$data;
  }

  CopyWith$Input$UserMinAggregateInput<Input$UserMinAggregateInput>
      get copyWith => CopyWith$Input$UserMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserMinAggregateInput<TRes> {
  factory CopyWith$Input$UserMinAggregateInput(
    Input$UserMinAggregateInput instance,
    TRes Function(Input$UserMinAggregateInput) then,
  ) = _CopyWithImpl$Input$UserMinAggregateInput;

  factory CopyWith$Input$UserMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserMinAggregateInput;

  TRes call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
  });
}

class _CopyWithImpl$Input$UserMinAggregateInput<TRes>
    implements CopyWith$Input$UserMinAggregateInput<TRes> {
  _CopyWithImpl$Input$UserMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$UserMinAggregateInput _instance;

  final TRes Function(Input$UserMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
  }) =>
      _then(Input$UserMinAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (fullName != _undefined) 'fullName': (fullName as bool?),
        if (email != _undefined) 'email': (email as bool?),
        if (password != _undefined) 'password': (password as bool?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (updatedAt != _undefined) 'updatedAt': (updatedAt as bool?),
        if (deletedAt != _undefined) 'deletedAt': (deletedAt as bool?),
        if (role != _undefined) 'role': (role as bool?),
        if (guestInfoId != _undefined) 'guestInfoId': (guestInfoId as bool?),
      }));
}

class _CopyWithStubImpl$Input$UserMinAggregateInput<TRes>
    implements CopyWith$Input$UserMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$UserMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? fullName,
    bool? email,
    bool? password,
    bool? whatsapp,
    bool? createdAt,
    bool? updatedAt,
    bool? deletedAt,
    bool? role,
    bool? guestInfoId,
  }) =>
      _res;
}

class Input$UserNullableRelationFilter {
  factory Input$UserNullableRelationFilter({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  }) =>
      Input$UserNullableRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$UserNullableRelationFilter._(this._$data);

  factory Input$UserNullableRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$UserWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$UserWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$UserNullableRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereInput? get $is => (_$data['is'] as Input$UserWhereInput?);
  Input$UserWhereInput? get isNot => (_$data['isNot'] as Input$UserWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserNullableRelationFilter<Input$UserNullableRelationFilter>
      get copyWith => CopyWith$Input$UserNullableRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserNullableRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserNullableRelationFilter<TRes> {
  factory CopyWith$Input$UserNullableRelationFilter(
    Input$UserNullableRelationFilter instance,
    TRes Function(Input$UserNullableRelationFilter) then,
  ) = _CopyWithImpl$Input$UserNullableRelationFilter;

  factory CopyWith$Input$UserNullableRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserNullableRelationFilter;

  TRes call({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  });
  CopyWith$Input$UserWhereInput<TRes> get $is;
  CopyWith$Input$UserWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$UserNullableRelationFilter<TRes>
    implements CopyWith$Input$UserNullableRelationFilter<TRes> {
  _CopyWithImpl$Input$UserNullableRelationFilter(
    this._instance,
    this._then,
  );

  final Input$UserNullableRelationFilter _instance;

  final TRes Function(Input$UserNullableRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$UserNullableRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$UserWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$UserWhereInput?),
      }));
  CopyWith$Input$UserWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$UserNullableRelationFilter<TRes>
    implements CopyWith$Input$UserNullableRelationFilter<TRes> {
  _CopyWithStubImpl$Input$UserNullableRelationFilter(this._res);

  TRes _res;

  call({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$UserWhereInput<TRes> get $is =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get isNot =>
      CopyWith$Input$UserWhereInput.stub(_res);
}

class Input$UserOrderByWithRelationInput {
  factory Input$UserOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? fullName,
    Input$SortOrderInput? email,
    Enum$SortOrder? password,
    Input$SortOrderInput? whatsapp,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? deletedAt,
    Enum$SortOrder? role,
    Input$SortOrderInput? guestInfoId,
    Input$GuestOrderByWithRelationInput? guestInfo,
    Input$QrCodeOrderByRelationAggregateInput? QrCode,
  }) =>
      Input$UserOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (guestInfo != null) r'guestInfo': guestInfo,
        if (QrCode != null) r'QrCode': QrCode,
      });

  Input$UserOrderByWithRelationInput._(this._$data);

  factory Input$UserOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : fromJson$Enum$SortOrder((l$fullName as String));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$SortOrderInput.fromJson((l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : fromJson$Enum$SortOrder((l$password as String));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$SortOrderInput.fromJson((l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : fromJson$Enum$SortOrder((l$updatedAt as String));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] =
          l$role == null ? null : fromJson$Enum$SortOrder((l$role as String));
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = l$guestInfoId == null
          ? null
          : Input$SortOrderInput.fromJson(
              (l$guestInfoId as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfo')) {
      final l$guestInfo = data['guestInfo'];
      result$data['guestInfo'] = l$guestInfo == null
          ? null
          : Input$GuestOrderByWithRelationInput.fromJson(
              (l$guestInfo as Map<String, dynamic>));
    }
    if (data.containsKey('QrCode')) {
      final l$QrCode = data['QrCode'];
      result$data['QrCode'] = l$QrCode == null
          ? null
          : Input$QrCodeOrderByRelationAggregateInput.fromJson(
              (l$QrCode as Map<String, dynamic>));
    }
    return Input$UserOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get fullName => (_$data['fullName'] as Enum$SortOrder?);
  Input$SortOrderInput? get email => (_$data['email'] as Input$SortOrderInput?);
  Enum$SortOrder? get password => (_$data['password'] as Enum$SortOrder?);
  Input$SortOrderInput? get whatsapp =>
      (_$data['whatsapp'] as Input$SortOrderInput?);
  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);
  Enum$SortOrder? get updatedAt => (_$data['updatedAt'] as Enum$SortOrder?);
  Input$SortOrderInput? get deletedAt =>
      (_$data['deletedAt'] as Input$SortOrderInput?);
  Enum$SortOrder? get role => (_$data['role'] as Enum$SortOrder?);
  Input$SortOrderInput? get guestInfoId =>
      (_$data['guestInfoId'] as Input$SortOrderInput?);
  Input$GuestOrderByWithRelationInput? get guestInfo =>
      (_$data['guestInfo'] as Input$GuestOrderByWithRelationInput?);
  Input$QrCodeOrderByRelationAggregateInput? get QrCode =>
      (_$data['QrCode'] as Input$QrCodeOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] =
          l$fullName == null ? null : toJson$Enum$SortOrder(l$fullName);
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] =
          l$password == null ? null : toJson$Enum$SortOrder(l$password);
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] =
          l$updatedAt == null ? null : toJson$Enum$SortOrder(l$updatedAt);
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] =
          l$role == null ? null : toJson$Enum$SortOrder(l$role);
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId?.toJson();
    }
    if (_$data.containsKey('guestInfo')) {
      final l$guestInfo = guestInfo;
      result$data['guestInfo'] = l$guestInfo?.toJson();
    }
    if (_$data.containsKey('QrCode')) {
      final l$QrCode = QrCode;
      result$data['QrCode'] = l$QrCode?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserOrderByWithRelationInput<
          Input$UserOrderByWithRelationInput>
      get copyWith => CopyWith$Input$UserOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$guestInfo = guestInfo;
    final lOther$guestInfo = other.guestInfo;
    if (_$data.containsKey('guestInfo') !=
        other._$data.containsKey('guestInfo')) {
      return false;
    }
    if (l$guestInfo != lOther$guestInfo) {
      return false;
    }
    final l$QrCode = QrCode;
    final lOther$QrCode = other.QrCode;
    if (_$data.containsKey('QrCode') != other._$data.containsKey('QrCode')) {
      return false;
    }
    if (l$QrCode != lOther$QrCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$guestInfo = guestInfo;
    final l$QrCode = QrCode;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('guestInfo') ? l$guestInfo : const {},
      _$data.containsKey('QrCode') ? l$QrCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$UserOrderByWithRelationInput(
    Input$UserOrderByWithRelationInput instance,
    TRes Function(Input$UserOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$UserOrderByWithRelationInput;

  factory CopyWith$Input$UserOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? fullName,
    Input$SortOrderInput? email,
    Enum$SortOrder? password,
    Input$SortOrderInput? whatsapp,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? deletedAt,
    Enum$SortOrder? role,
    Input$SortOrderInput? guestInfoId,
    Input$GuestOrderByWithRelationInput? guestInfo,
    Input$QrCodeOrderByRelationAggregateInput? QrCode,
  });
  CopyWith$Input$SortOrderInput<TRes> get email;
  CopyWith$Input$SortOrderInput<TRes> get whatsapp;
  CopyWith$Input$SortOrderInput<TRes> get deletedAt;
  CopyWith$Input$SortOrderInput<TRes> get guestInfoId;
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guestInfo;
  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get QrCode;
}

class _CopyWithImpl$Input$UserOrderByWithRelationInput<TRes>
    implements CopyWith$Input$UserOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$UserOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$UserOrderByWithRelationInput _instance;

  final TRes Function(Input$UserOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? guestInfo = _undefined,
    Object? QrCode = _undefined,
  }) =>
      _then(Input$UserOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (fullName != _undefined) 'fullName': (fullName as Enum$SortOrder?),
        if (email != _undefined) 'email': (email as Input$SortOrderInput?),
        if (password != _undefined) 'password': (password as Enum$SortOrder?),
        if (whatsapp != _undefined)
          'whatsapp': (whatsapp as Input$SortOrderInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Enum$SortOrder?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$SortOrderInput?),
        if (role != _undefined) 'role': (role as Enum$SortOrder?),
        if (guestInfoId != _undefined)
          'guestInfoId': (guestInfoId as Input$SortOrderInput?),
        if (guestInfo != _undefined)
          'guestInfo': (guestInfo as Input$GuestOrderByWithRelationInput?),
        if (QrCode != _undefined)
          'QrCode': (QrCode as Input$QrCodeOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$SortOrderInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(local$email, (e) => call(email: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$SortOrderInput<TRes> get guestInfoId {
    final local$guestInfoId = _instance.guestInfoId;
    return local$guestInfoId == null
        ? CopyWith$Input$SortOrderInput.stub(_then(_instance))
        : CopyWith$Input$SortOrderInput(
            local$guestInfoId, (e) => call(guestInfoId: e));
  }

  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guestInfo {
    final local$guestInfo = _instance.guestInfo;
    return local$guestInfo == null
        ? CopyWith$Input$GuestOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$GuestOrderByWithRelationInput(
            local$guestInfo, (e) => call(guestInfo: e));
  }

  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get QrCode {
    final local$QrCode = _instance.QrCode;
    return local$QrCode == null
        ? CopyWith$Input$QrCodeOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeOrderByRelationAggregateInput(
            local$QrCode, (e) => call(QrCode: e));
  }
}

class _CopyWithStubImpl$Input$UserOrderByWithRelationInput<TRes>
    implements CopyWith$Input$UserOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$UserOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? fullName,
    Input$SortOrderInput? email,
    Enum$SortOrder? password,
    Input$SortOrderInput? whatsapp,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? updatedAt,
    Input$SortOrderInput? deletedAt,
    Enum$SortOrder? role,
    Input$SortOrderInput? guestInfoId,
    Input$GuestOrderByWithRelationInput? guestInfo,
    Input$QrCodeOrderByRelationAggregateInput? QrCode,
  }) =>
      _res;
  CopyWith$Input$SortOrderInput<TRes> get email =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get whatsapp =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get deletedAt =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$SortOrderInput<TRes> get guestInfoId =>
      CopyWith$Input$SortOrderInput.stub(_res);
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guestInfo =>
      CopyWith$Input$GuestOrderByWithRelationInput.stub(_res);
  CopyWith$Input$QrCodeOrderByRelationAggregateInput<TRes> get QrCode =>
      CopyWith$Input$QrCodeOrderByRelationAggregateInput.stub(_res);
}

class Input$UserRelationFilter {
  factory Input$UserRelationFilter({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  }) =>
      Input$UserRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$UserRelationFilter._(this._$data);

  factory Input$UserRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$UserWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$UserWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$UserRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereInput? get $is => (_$data['is'] as Input$UserWhereInput?);
  Input$UserWhereInput? get isNot => (_$data['isNot'] as Input$UserWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserRelationFilter<Input$UserRelationFilter> get copyWith =>
      CopyWith$Input$UserRelationFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserRelationFilter<TRes> {
  factory CopyWith$Input$UserRelationFilter(
    Input$UserRelationFilter instance,
    TRes Function(Input$UserRelationFilter) then,
  ) = _CopyWithImpl$Input$UserRelationFilter;

  factory CopyWith$Input$UserRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$UserRelationFilter;

  TRes call({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  });
  CopyWith$Input$UserWhereInput<TRes> get $is;
  CopyWith$Input$UserWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$UserRelationFilter<TRes>
    implements CopyWith$Input$UserRelationFilter<TRes> {
  _CopyWithImpl$Input$UserRelationFilter(
    this._instance,
    this._then,
  );

  final Input$UserRelationFilter _instance;

  final TRes Function(Input$UserRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$UserRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$UserWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$UserWhereInput?),
      }));
  CopyWith$Input$UserWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$UserRelationFilter<TRes>
    implements CopyWith$Input$UserRelationFilter<TRes> {
  _CopyWithStubImpl$Input$UserRelationFilter(this._res);

  TRes _res;

  call({
    Input$UserWhereInput? $is,
    Input$UserWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$UserWhereInput<TRes> get $is =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get isNot =>
      CopyWith$Input$UserWhereInput.stub(_res);
}

class Input$UserUpdateInput {
  factory Input$UserUpdateInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$GuestUpdateOneWithoutUserNestedInput? guestInfo,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? QrCode,
  }) =>
      Input$UserUpdateInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (guestInfo != null) r'guestInfo': guestInfo,
        if (QrCode != null) r'QrCode': QrCode,
      });

  Input$UserUpdateInput._(this._$data);

  factory Input$UserUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = l$guestInfoId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$guestInfoId as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfo')) {
      final l$guestInfo = data['guestInfo'];
      result$data['guestInfo'] = l$guestInfo == null
          ? null
          : Input$GuestUpdateOneWithoutUserNestedInput.fromJson(
              (l$guestInfo as Map<String, dynamic>));
    }
    if (data.containsKey('QrCode')) {
      final l$QrCode = data['QrCode'];
      result$data['QrCode'] = l$QrCode == null
          ? null
          : Input$QrCodeUpdateManyWithoutScannedByNestedInput.fromJson(
              (l$QrCode as Map<String, dynamic>));
    }
    return Input$UserUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get fullName =>
      (_$data['fullName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get email =>
      (_$data['email'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get password =>
      (_$data['password'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$EnumUserRoleFieldUpdateOperationsInput? get role =>
      (_$data['role'] as Input$EnumUserRoleFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get guestInfoId =>
      (_$data['guestInfoId']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$GuestUpdateOneWithoutUserNestedInput? get guestInfo =>
      (_$data['guestInfo'] as Input$GuestUpdateOneWithoutUserNestedInput?);
  Input$QrCodeUpdateManyWithoutScannedByNestedInput? get QrCode =>
      (_$data['QrCode'] as Input$QrCodeUpdateManyWithoutScannedByNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId?.toJson();
    }
    if (_$data.containsKey('guestInfo')) {
      final l$guestInfo = guestInfo;
      result$data['guestInfo'] = l$guestInfo?.toJson();
    }
    if (_$data.containsKey('QrCode')) {
      final l$QrCode = QrCode;
      result$data['QrCode'] = l$QrCode?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateInput<Input$UserUpdateInput> get copyWith =>
      CopyWith$Input$UserUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$guestInfo = guestInfo;
    final lOther$guestInfo = other.guestInfo;
    if (_$data.containsKey('guestInfo') !=
        other._$data.containsKey('guestInfo')) {
      return false;
    }
    if (l$guestInfo != lOther$guestInfo) {
      return false;
    }
    final l$QrCode = QrCode;
    final lOther$QrCode = other.QrCode;
    if (_$data.containsKey('QrCode') != other._$data.containsKey('QrCode')) {
      return false;
    }
    if (l$QrCode != lOther$QrCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$guestInfo = guestInfo;
    final l$QrCode = QrCode;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('guestInfo') ? l$guestInfo : const {},
      _$data.containsKey('QrCode') ? l$QrCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateInput<TRes> {
  factory CopyWith$Input$UserUpdateInput(
    Input$UserUpdateInput instance,
    TRes Function(Input$UserUpdateInput) then,
  ) = _CopyWithImpl$Input$UserUpdateInput;

  factory CopyWith$Input$UserUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$GuestUpdateOneWithoutUserNestedInput? guestInfo,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? QrCode,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get guestInfoId;
  CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> get guestInfo;
  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> get QrCode;
}

class _CopyWithImpl$Input$UserUpdateInput<TRes>
    implements CopyWith$Input$UserUpdateInput<TRes> {
  _CopyWithImpl$Input$UserUpdateInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateInput _instance;

  final TRes Function(Input$UserUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? guestInfo = _undefined,
    Object? QrCode = _undefined,
  }) =>
      _then(Input$UserUpdateInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFieldUpdateOperationsInput?),
        if (email != _undefined)
          'email': (email as Input$NullableStringFieldUpdateOperationsInput?),
        if (password != _undefined)
          'password': (password as Input$StringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (role != _undefined)
          'role': (role as Input$EnumUserRoleFieldUpdateOperationsInput?),
        if (guestInfoId != _undefined)
          'guestInfoId':
              (guestInfoId as Input$NullableStringFieldUpdateOperationsInput?),
        if (guestInfo != _undefined)
          'guestInfo':
              (guestInfo as Input$GuestUpdateOneWithoutUserNestedInput?),
        if (QrCode != _undefined)
          'QrCode':
              (QrCode as Input$QrCodeUpdateManyWithoutScannedByNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get guestInfoId {
    final local$guestInfoId = _instance.guestInfoId;
    return local$guestInfoId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$guestInfoId, (e) => call(guestInfoId: e));
  }

  CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> get guestInfo {
    final local$guestInfo = _instance.guestInfo;
    return local$guestInfo == null
        ? CopyWith$Input$GuestUpdateOneWithoutUserNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneWithoutUserNestedInput(
            local$guestInfo, (e) => call(guestInfo: e));
  }

  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> get QrCode {
    final local$QrCode = _instance.QrCode;
    return local$QrCode == null
        ? CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
            local$QrCode, (e) => call(QrCode: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateInput<TRes>
    implements CopyWith$Input$UserUpdateInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$GuestUpdateOneWithoutUserNestedInput? guestInfo,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? QrCode,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role =>
      CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get guestInfoId =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> get guestInfo =>
      CopyWith$Input$GuestUpdateOneWithoutUserNestedInput.stub(_res);
  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> get QrCode =>
      CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput.stub(_res);
}

class Input$UserUpdateManyMutationInput {
  factory Input$UserUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
  }) =>
      Input$UserUpdateManyMutationInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
      });

  Input$UserUpdateManyMutationInput._(this._$data);

  factory Input$UserUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = l$guestInfoId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$guestInfoId as Map<String, dynamic>));
    }
    return Input$UserUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get fullName =>
      (_$data['fullName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get email =>
      (_$data['email'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get password =>
      (_$data['password'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$EnumUserRoleFieldUpdateOperationsInput? get role =>
      (_$data['role'] as Input$EnumUserRoleFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get guestInfoId =>
      (_$data['guestInfoId']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateManyMutationInput<Input$UserUpdateManyMutationInput>
      get copyWith => CopyWith$Input$UserUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$UserUpdateManyMutationInput(
    Input$UserUpdateManyMutationInput instance,
    TRes Function(Input$UserUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$UserUpdateManyMutationInput;

  factory CopyWith$Input$UserUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get guestInfoId;
}

class _CopyWithImpl$Input$UserUpdateManyMutationInput<TRes>
    implements CopyWith$Input$UserUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$UserUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateManyMutationInput _instance;

  final TRes Function(Input$UserUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
  }) =>
      _then(Input$UserUpdateManyMutationInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFieldUpdateOperationsInput?),
        if (email != _undefined)
          'email': (email as Input$NullableStringFieldUpdateOperationsInput?),
        if (password != _undefined)
          'password': (password as Input$StringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (role != _undefined)
          'role': (role as Input$EnumUserRoleFieldUpdateOperationsInput?),
        if (guestInfoId != _undefined)
          'guestInfoId':
              (guestInfoId as Input$NullableStringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get guestInfoId {
    final local$guestInfoId = _instance.guestInfoId;
    return local$guestInfoId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$guestInfoId, (e) => call(guestInfoId: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateManyMutationInput<TRes>
    implements CopyWith$Input$UserUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role =>
      CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get guestInfoId =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
}

class Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput {
  factory Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput({
    Input$UserCreateWithoutGuestInfoInput? create,
    Input$UserCreateOrConnectWithoutGuestInfoInput? connectOrCreate,
    Input$UserUpsertWithoutGuestInfoInput? upsert,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutGuestInfoInput? update,
  }) =>
      Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput._(this._$data);

  factory Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$UserCreateWithoutGuestInfoInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$UserCreateOrConnectWithoutGuestInfoInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$UserUpsertWithoutGuestInfoInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$UserWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$UserUpdateToOneWithWhereWithoutGuestInfoInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserCreateWithoutGuestInfoInput? get create =>
      (_$data['create'] as Input$UserCreateWithoutGuestInfoInput?);
  Input$UserCreateOrConnectWithoutGuestInfoInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$UserCreateOrConnectWithoutGuestInfoInput?);
  Input$UserUpsertWithoutGuestInfoInput? get upsert =>
      (_$data['upsert'] as Input$UserUpsertWithoutGuestInfoInput?);
  Input$UserWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$UserWhereUniqueInput?);
  Input$UserUpdateToOneWithWhereWithoutGuestInfoInput? get update =>
      (_$data['update']
          as Input$UserUpdateToOneWithWhereWithoutGuestInfoInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<
          Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput>
      get copyWith =>
          CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<
    TRes> {
  factory CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput(
    Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput instance,
    TRes Function(Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput) then,
  ) = _CopyWithImpl$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput;

  factory CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput;

  TRes call({
    Input$UserCreateWithoutGuestInfoInput? create,
    Input$UserCreateOrConnectWithoutGuestInfoInput? connectOrCreate,
    Input$UserUpsertWithoutGuestInfoInput? upsert,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutGuestInfoInput? update,
  });
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create;
  CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes>
      get connectOrCreate;
  CopyWith$Input$UserUpsertWithoutGuestInfoInput<TRes> get upsert;
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect;
  CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<TRes> get update;
}

class _CopyWithImpl$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes>
    implements
        CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes> {
  _CopyWithImpl$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput _instance;

  final TRes Function(Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$UserCreateWithoutGuestInfoInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$UserCreateOrConnectWithoutGuestInfoInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$UserUpsertWithoutGuestInfoInput?),
        if (connect != _undefined)
          'connect': (connect as Input$UserWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$UserUpdateToOneWithWhereWithoutGuestInfoInput?),
      }));
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$UserCreateWithoutGuestInfoInput.stub(_then(_instance))
        : CopyWith$Input$UserCreateWithoutGuestInfoInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$UserUpsertWithoutGuestInfoInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$UserUpsertWithoutGuestInfoInput.stub(_then(_instance))
        : CopyWith$Input$UserUpsertWithoutGuestInfoInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$UserWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$UserWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<
        TRes>
    implements
        CopyWith$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateOneRequiredWithoutGuestInfoNestedInput(
      this._res);

  TRes _res;

  call({
    Input$UserCreateWithoutGuestInfoInput? create,
    Input$UserCreateOrConnectWithoutGuestInfoInput? connectOrCreate,
    Input$UserUpsertWithoutGuestInfoInput? upsert,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutGuestInfoInput? update,
  }) =>
      _res;
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$UserCreateOrConnectWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$UserUpsertWithoutGuestInfoInput<TRes> get upsert =>
      CopyWith$Input$UserUpsertWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
  CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<TRes>
      get update =>
          CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput.stub(
              _res);
}

class Input$UserUpdateOneWithoutQrCodeNestedInput {
  factory Input$UserUpdateOneWithoutQrCodeNestedInput({
    Input$UserCreateWithoutQrCodeInput? create,
    Input$UserCreateOrConnectWithoutQrCodeInput? connectOrCreate,
    Input$UserUpsertWithoutQrCodeInput? upsert,
    Input$UserWhereInput? disconnect,
    Input$UserWhereInput? delete,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutQrCodeInput? update,
  }) =>
      Input$UserUpdateOneWithoutQrCodeNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$UserUpdateOneWithoutQrCodeNestedInput._(this._$data);

  factory Input$UserUpdateOneWithoutQrCodeNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$UserCreateWithoutQrCodeInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$UserCreateOrConnectWithoutQrCodeInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$UserUpsertWithoutQrCodeInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = l$disconnect == null
          ? null
          : Input$UserWhereInput.fromJson(
              (l$disconnect as Map<String, dynamic>));
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = l$delete == null
          ? null
          : Input$UserWhereInput.fromJson((l$delete as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$UserWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$UserUpdateToOneWithWhereWithoutQrCodeInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$UserUpdateOneWithoutQrCodeNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserCreateWithoutQrCodeInput? get create =>
      (_$data['create'] as Input$UserCreateWithoutQrCodeInput?);
  Input$UserCreateOrConnectWithoutQrCodeInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$UserCreateOrConnectWithoutQrCodeInput?);
  Input$UserUpsertWithoutQrCodeInput? get upsert =>
      (_$data['upsert'] as Input$UserUpsertWithoutQrCodeInput?);
  Input$UserWhereInput? get disconnect =>
      (_$data['disconnect'] as Input$UserWhereInput?);
  Input$UserWhereInput? get delete =>
      (_$data['delete'] as Input$UserWhereInput?);
  Input$UserWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$UserWhereUniqueInput?);
  Input$UserUpdateToOneWithWhereWithoutQrCodeInput? get update =>
      (_$data['update'] as Input$UserUpdateToOneWithWhereWithoutQrCodeInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.toJson();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput<
          Input$UserUpdateOneWithoutQrCodeNestedInput>
      get copyWith => CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateOneWithoutQrCodeNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('disconnect') ? l$disconnect : const {},
      _$data.containsKey('delete') ? l$delete : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput<TRes> {
  factory CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput(
    Input$UserUpdateOneWithoutQrCodeNestedInput instance,
    TRes Function(Input$UserUpdateOneWithoutQrCodeNestedInput) then,
  ) = _CopyWithImpl$Input$UserUpdateOneWithoutQrCodeNestedInput;

  factory CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateOneWithoutQrCodeNestedInput;

  TRes call({
    Input$UserCreateWithoutQrCodeInput? create,
    Input$UserCreateOrConnectWithoutQrCodeInput? connectOrCreate,
    Input$UserUpsertWithoutQrCodeInput? upsert,
    Input$UserWhereInput? disconnect,
    Input$UserWhereInput? delete,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutQrCodeInput? update,
  });
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create;
  CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes>
      get connectOrCreate;
  CopyWith$Input$UserUpsertWithoutQrCodeInput<TRes> get upsert;
  CopyWith$Input$UserWhereInput<TRes> get disconnect;
  CopyWith$Input$UserWhereInput<TRes> get delete;
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect;
  CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<TRes> get update;
}

class _CopyWithImpl$Input$UserUpdateOneWithoutQrCodeNestedInput<TRes>
    implements CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput<TRes> {
  _CopyWithImpl$Input$UserUpdateOneWithoutQrCodeNestedInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateOneWithoutQrCodeNestedInput _instance;

  final TRes Function(Input$UserUpdateOneWithoutQrCodeNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$UserUpdateOneWithoutQrCodeNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$UserCreateWithoutQrCodeInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate':
              (connectOrCreate as Input$UserCreateOrConnectWithoutQrCodeInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$UserUpsertWithoutQrCodeInput?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as Input$UserWhereInput?),
        if (delete != _undefined) 'delete': (delete as Input$UserWhereInput?),
        if (connect != _undefined)
          'connect': (connect as Input$UserWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$UserUpdateToOneWithWhereWithoutQrCodeInput?),
      }));
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$UserCreateWithoutQrCodeInput.stub(_then(_instance))
        : CopyWith$Input$UserCreateWithoutQrCodeInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput.stub(
            _then(_instance))
        : CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$UserUpsertWithoutQrCodeInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$UserUpsertWithoutQrCodeInput.stub(_then(_instance))
        : CopyWith$Input$UserUpsertWithoutQrCodeInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get disconnect {
    final local$disconnect = _instance.disconnect;
    return local$disconnect == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(
            local$disconnect, (e) => call(disconnect: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get delete {
    final local$delete = _instance.delete;
    return local$delete == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$delete, (e) => call(delete: e));
  }

  CopyWith$Input$UserWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$UserWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput.stub(
            _then(_instance))
        : CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateOneWithoutQrCodeNestedInput<TRes>
    implements CopyWith$Input$UserUpdateOneWithoutQrCodeNestedInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateOneWithoutQrCodeNestedInput(this._res);

  TRes _res;

  call({
    Input$UserCreateWithoutQrCodeInput? create,
    Input$UserCreateOrConnectWithoutQrCodeInput? connectOrCreate,
    Input$UserUpsertWithoutQrCodeInput? upsert,
    Input$UserWhereInput? disconnect,
    Input$UserWhereInput? delete,
    Input$UserWhereUniqueInput? connect,
    Input$UserUpdateToOneWithWhereWithoutQrCodeInput? update,
  }) =>
      _res;
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutQrCodeInput.stub(_res);
  CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$UserCreateOrConnectWithoutQrCodeInput.stub(_res);
  CopyWith$Input$UserUpsertWithoutQrCodeInput<TRes> get upsert =>
      CopyWith$Input$UserUpsertWithoutQrCodeInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get disconnect =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get delete =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$UserWhereUniqueInput.stub(_res);
  CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<TRes> get update =>
      CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput.stub(_res);
}

class Input$UserUpdateToOneWithWhereWithoutGuestInfoInput {
  factory Input$UserUpdateToOneWithWhereWithoutGuestInfoInput({
    Input$UserWhereInput? where,
    required Input$UserUpdateWithoutGuestInfoInput data,
  }) =>
      Input$UserUpdateToOneWithWhereWithoutGuestInfoInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$UserUpdateToOneWithWhereWithoutGuestInfoInput._(this._$data);

  factory Input$UserUpdateToOneWithWhereWithoutGuestInfoInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$UserWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$UserUpdateWithoutGuestInfoInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$UserUpdateToOneWithWhereWithoutGuestInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereInput? get where => (_$data['where'] as Input$UserWhereInput?);
  Input$UserUpdateWithoutGuestInfoInput get data =>
      (_$data['data'] as Input$UserUpdateWithoutGuestInfoInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<
          Input$UserUpdateToOneWithWhereWithoutGuestInfoInput>
      get copyWith =>
          CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateToOneWithWhereWithoutGuestInfoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<
    TRes> {
  factory CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput(
    Input$UserUpdateToOneWithWhereWithoutGuestInfoInput instance,
    TRes Function(Input$UserUpdateToOneWithWhereWithoutGuestInfoInput) then,
  ) = _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput;

  factory CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput;

  TRes call({
    Input$UserWhereInput? where,
    Input$UserUpdateWithoutGuestInfoInput? data,
  });
  CopyWith$Input$UserWhereInput<TRes> get where;
  CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> get data;
}

class _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<TRes>
    implements
        CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<TRes> {
  _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateToOneWithWhereWithoutGuestInfoInput _instance;

  final TRes Function(Input$UserUpdateToOneWithWhereWithoutGuestInfoInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserUpdateToOneWithWhereWithoutGuestInfoInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$UserWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$UserUpdateWithoutGuestInfoInput),
      }));
  CopyWith$Input$UserWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$UserUpdateWithoutGuestInfoInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<
        TRes>
    implements
        CopyWith$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutGuestInfoInput(
      this._res);

  TRes _res;

  call({
    Input$UserWhereInput? where,
    Input$UserUpdateWithoutGuestInfoInput? data,
  }) =>
      _res;
  CopyWith$Input$UserWhereInput<TRes> get where =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> get data =>
      CopyWith$Input$UserUpdateWithoutGuestInfoInput.stub(_res);
}

class Input$UserUpdateToOneWithWhereWithoutQrCodeInput {
  factory Input$UserUpdateToOneWithWhereWithoutQrCodeInput({
    Input$UserWhereInput? where,
    required Input$UserUpdateWithoutQrCodeInput data,
  }) =>
      Input$UserUpdateToOneWithWhereWithoutQrCodeInput._({
        if (where != null) r'where': where,
        r'data': data,
      });

  Input$UserUpdateToOneWithWhereWithoutQrCodeInput._(this._$data);

  factory Input$UserUpdateToOneWithWhereWithoutQrCodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$UserWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    final l$data = data['data'];
    result$data['data'] = Input$UserUpdateWithoutQrCodeInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$UserUpdateToOneWithWhereWithoutQrCodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserWhereInput? get where => (_$data['where'] as Input$UserWhereInput?);
  Input$UserUpdateWithoutQrCodeInput get data =>
      (_$data['data'] as Input$UserUpdateWithoutQrCodeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<
          Input$UserUpdateToOneWithWhereWithoutQrCodeInput>
      get copyWith => CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateToOneWithWhereWithoutQrCodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      _$data.containsKey('where') ? l$where : const {},
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<TRes> {
  factory CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput(
    Input$UserUpdateToOneWithWhereWithoutQrCodeInput instance,
    TRes Function(Input$UserUpdateToOneWithWhereWithoutQrCodeInput) then,
  ) = _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutQrCodeInput;

  factory CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutQrCodeInput;

  TRes call({
    Input$UserWhereInput? where,
    Input$UserUpdateWithoutQrCodeInput? data,
  });
  CopyWith$Input$UserWhereInput<TRes> get where;
  CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> get data;
}

class _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<TRes> {
  _CopyWithImpl$Input$UserUpdateToOneWithWhereWithoutQrCodeInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateToOneWithWhereWithoutQrCodeInput _instance;

  final TRes Function(Input$UserUpdateToOneWithWhereWithoutQrCodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$UserUpdateToOneWithWhereWithoutQrCodeInput._({
        ..._instance._$data,
        if (where != _undefined) 'where': (where as Input$UserWhereInput?),
        if (data != _undefined && data != null)
          'data': (data as Input$UserUpdateWithoutQrCodeInput),
      }));
  CopyWith$Input$UserWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$where, (e) => call(where: e));
  }

  CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$UserUpdateWithoutQrCodeInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserUpdateToOneWithWhereWithoutQrCodeInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateToOneWithWhereWithoutQrCodeInput(this._res);

  TRes _res;

  call({
    Input$UserWhereInput? where,
    Input$UserUpdateWithoutQrCodeInput? data,
  }) =>
      _res;
  CopyWith$Input$UserWhereInput<TRes> get where =>
      CopyWith$Input$UserWhereInput.stub(_res);
  CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> get data =>
      CopyWith$Input$UserUpdateWithoutQrCodeInput.stub(_res);
}

class Input$UserUpdateWithoutGuestInfoInput {
  factory Input$UserUpdateWithoutGuestInfoInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? QrCode,
  }) =>
      Input$UserUpdateWithoutGuestInfoInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (QrCode != null) r'QrCode': QrCode,
      });

  Input$UserUpdateWithoutGuestInfoInput._(this._$data);

  factory Input$UserUpdateWithoutGuestInfoInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = l$guestInfoId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$guestInfoId as Map<String, dynamic>));
    }
    if (data.containsKey('QrCode')) {
      final l$QrCode = data['QrCode'];
      result$data['QrCode'] = l$QrCode == null
          ? null
          : Input$QrCodeUpdateManyWithoutScannedByNestedInput.fromJson(
              (l$QrCode as Map<String, dynamic>));
    }
    return Input$UserUpdateWithoutGuestInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get fullName =>
      (_$data['fullName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get email =>
      (_$data['email'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get password =>
      (_$data['password'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$EnumUserRoleFieldUpdateOperationsInput? get role =>
      (_$data['role'] as Input$EnumUserRoleFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get guestInfoId =>
      (_$data['guestInfoId']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$QrCodeUpdateManyWithoutScannedByNestedInput? get QrCode =>
      (_$data['QrCode'] as Input$QrCodeUpdateManyWithoutScannedByNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId?.toJson();
    }
    if (_$data.containsKey('QrCode')) {
      final l$QrCode = QrCode;
      result$data['QrCode'] = l$QrCode?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateWithoutGuestInfoInput<
          Input$UserUpdateWithoutGuestInfoInput>
      get copyWith => CopyWith$Input$UserUpdateWithoutGuestInfoInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateWithoutGuestInfoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$QrCode = QrCode;
    final lOther$QrCode = other.QrCode;
    if (_$data.containsKey('QrCode') != other._$data.containsKey('QrCode')) {
      return false;
    }
    if (l$QrCode != lOther$QrCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$QrCode = QrCode;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('QrCode') ? l$QrCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> {
  factory CopyWith$Input$UserUpdateWithoutGuestInfoInput(
    Input$UserUpdateWithoutGuestInfoInput instance,
    TRes Function(Input$UserUpdateWithoutGuestInfoInput) then,
  ) = _CopyWithImpl$Input$UserUpdateWithoutGuestInfoInput;

  factory CopyWith$Input$UserUpdateWithoutGuestInfoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateWithoutGuestInfoInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? QrCode,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get guestInfoId;
  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> get QrCode;
}

class _CopyWithImpl$Input$UserUpdateWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> {
  _CopyWithImpl$Input$UserUpdateWithoutGuestInfoInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateWithoutGuestInfoInput _instance;

  final TRes Function(Input$UserUpdateWithoutGuestInfoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? QrCode = _undefined,
  }) =>
      _then(Input$UserUpdateWithoutGuestInfoInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFieldUpdateOperationsInput?),
        if (email != _undefined)
          'email': (email as Input$NullableStringFieldUpdateOperationsInput?),
        if (password != _undefined)
          'password': (password as Input$StringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (role != _undefined)
          'role': (role as Input$EnumUserRoleFieldUpdateOperationsInput?),
        if (guestInfoId != _undefined)
          'guestInfoId':
              (guestInfoId as Input$NullableStringFieldUpdateOperationsInput?),
        if (QrCode != _undefined)
          'QrCode':
              (QrCode as Input$QrCodeUpdateManyWithoutScannedByNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get guestInfoId {
    final local$guestInfoId = _instance.guestInfoId;
    return local$guestInfoId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$guestInfoId, (e) => call(guestInfoId: e));
  }

  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> get QrCode {
    final local$QrCode = _instance.QrCode;
    return local$QrCode == null
        ? CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput(
            local$QrCode, (e) => call(QrCode: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateWithoutGuestInfoInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$QrCodeUpdateManyWithoutScannedByNestedInput? QrCode,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role =>
      CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get guestInfoId =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput<TRes> get QrCode =>
      CopyWith$Input$QrCodeUpdateManyWithoutScannedByNestedInput.stub(_res);
}

class Input$UserUpdateWithoutQrCodeInput {
  factory Input$UserUpdateWithoutQrCodeInput({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$GuestUpdateOneWithoutUserNestedInput? guestInfo,
  }) =>
      Input$UserUpdateWithoutQrCodeInput._({
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (guestInfo != null) r'guestInfo': guestInfo,
      });

  Input$UserUpdateWithoutQrCodeInput._(this._$data);

  factory Input$UserUpdateWithoutQrCodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$password as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$NullableDateTimeFieldUpdateOperationsInput.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFieldUpdateOperationsInput.fromJson(
              (l$role as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = l$guestInfoId == null
          ? null
          : Input$NullableStringFieldUpdateOperationsInput.fromJson(
              (l$guestInfoId as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfo')) {
      final l$guestInfo = data['guestInfo'];
      result$data['guestInfo'] = l$guestInfo == null
          ? null
          : Input$GuestUpdateOneWithoutUserNestedInput.fromJson(
              (l$guestInfo as Map<String, dynamic>));
    }
    return Input$UserUpdateWithoutQrCodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get fullName =>
      (_$data['fullName'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get email =>
      (_$data['email'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get password =>
      (_$data['password'] as Input$StringFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get whatsapp =>
      (_$data['whatsapp'] as Input$NullableStringFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$NullableDateTimeFieldUpdateOperationsInput? get deletedAt =>
      (_$data['deletedAt']
          as Input$NullableDateTimeFieldUpdateOperationsInput?);
  Input$EnumUserRoleFieldUpdateOperationsInput? get role =>
      (_$data['role'] as Input$EnumUserRoleFieldUpdateOperationsInput?);
  Input$NullableStringFieldUpdateOperationsInput? get guestInfoId =>
      (_$data['guestInfoId']
          as Input$NullableStringFieldUpdateOperationsInput?);
  Input$GuestUpdateOneWithoutUserNestedInput? get guestInfo =>
      (_$data['guestInfo'] as Input$GuestUpdateOneWithoutUserNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId?.toJson();
    }
    if (_$data.containsKey('guestInfo')) {
      final l$guestInfo = guestInfo;
      result$data['guestInfo'] = l$guestInfo?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpdateWithoutQrCodeInput<
          Input$UserUpdateWithoutQrCodeInput>
      get copyWith => CopyWith$Input$UserUpdateWithoutQrCodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpdateWithoutQrCodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$guestInfo = guestInfo;
    final lOther$guestInfo = other.guestInfo;
    if (_$data.containsKey('guestInfo') !=
        other._$data.containsKey('guestInfo')) {
      return false;
    }
    if (l$guestInfo != lOther$guestInfo) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$guestInfo = guestInfo;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('guestInfo') ? l$guestInfo : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> {
  factory CopyWith$Input$UserUpdateWithoutQrCodeInput(
    Input$UserUpdateWithoutQrCodeInput instance,
    TRes Function(Input$UserUpdateWithoutQrCodeInput) then,
  ) = _CopyWithImpl$Input$UserUpdateWithoutQrCodeInput;

  factory CopyWith$Input$UserUpdateWithoutQrCodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpdateWithoutQrCodeInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$GuestUpdateOneWithoutUserNestedInput? guestInfo,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt;
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role;
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get guestInfoId;
  CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> get guestInfo;
}

class _CopyWithImpl$Input$UserUpdateWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> {
  _CopyWithImpl$Input$UserUpdateWithoutQrCodeInput(
    this._instance,
    this._then,
  );

  final Input$UserUpdateWithoutQrCodeInput _instance;

  final TRes Function(Input$UserUpdateWithoutQrCodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? guestInfo = _undefined,
  }) =>
      _then(Input$UserUpdateWithoutQrCodeInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$StringFieldUpdateOperationsInput?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFieldUpdateOperationsInput?),
        if (email != _undefined)
          'email': (email as Input$NullableStringFieldUpdateOperationsInput?),
        if (password != _undefined)
          'password': (password as Input$StringFieldUpdateOperationsInput?),
        if (whatsapp != _undefined)
          'whatsapp':
              (whatsapp as Input$NullableStringFieldUpdateOperationsInput?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (deletedAt != _undefined)
          'deletedAt':
              (deletedAt as Input$NullableDateTimeFieldUpdateOperationsInput?),
        if (role != _undefined)
          'role': (role as Input$EnumUserRoleFieldUpdateOperationsInput?),
        if (guestInfoId != _undefined)
          'guestInfoId':
              (guestInfoId as Input$NullableStringFieldUpdateOperationsInput?),
        if (guestInfo != _undefined)
          'guestInfo':
              (guestInfo as Input$GuestUpdateOneWithoutUserNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$password, (e) => call(password: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput(
            local$role, (e) => call(role: e));
  }

  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get guestInfoId {
    final local$guestInfoId = _instance.guestInfoId;
    return local$guestInfoId == null
        ? CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$NullableStringFieldUpdateOperationsInput(
            local$guestInfoId, (e) => call(guestInfoId: e));
  }

  CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> get guestInfo {
    final local$guestInfo = _instance.guestInfo;
    return local$guestInfo == null
        ? CopyWith$Input$GuestUpdateOneWithoutUserNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$GuestUpdateOneWithoutUserNestedInput(
            local$guestInfo, (e) => call(guestInfo: e));
  }
}

class _CopyWithStubImpl$Input$UserUpdateWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> {
  _CopyWithStubImpl$Input$UserUpdateWithoutQrCodeInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? fullName,
    Input$NullableStringFieldUpdateOperationsInput? email,
    Input$StringFieldUpdateOperationsInput? password,
    Input$NullableStringFieldUpdateOperationsInput? whatsapp,
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$DateTimeFieldUpdateOperationsInput? updatedAt,
    Input$NullableDateTimeFieldUpdateOperationsInput? deletedAt,
    Input$EnumUserRoleFieldUpdateOperationsInput? role,
    Input$NullableStringFieldUpdateOperationsInput? guestInfoId,
    Input$GuestUpdateOneWithoutUserNestedInput? guestInfo,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get fullName =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get email =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get password =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes> get whatsapp =>
      CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput<TRes>
      get deletedAt =>
          CopyWith$Input$NullableDateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput<TRes> get role =>
      CopyWith$Input$EnumUserRoleFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$NullableStringFieldUpdateOperationsInput<TRes>
      get guestInfoId =>
          CopyWith$Input$NullableStringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneWithoutUserNestedInput<TRes> get guestInfo =>
      CopyWith$Input$GuestUpdateOneWithoutUserNestedInput.stub(_res);
}

class Input$UserUpsertWithoutGuestInfoInput {
  factory Input$UserUpsertWithoutGuestInfoInput({
    required Input$UserUpdateWithoutGuestInfoInput update,
    required Input$UserCreateWithoutGuestInfoInput create,
    Input$UserWhereInput? where,
  }) =>
      Input$UserUpsertWithoutGuestInfoInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$UserUpsertWithoutGuestInfoInput._(this._$data);

  factory Input$UserUpsertWithoutGuestInfoInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$UserUpdateWithoutGuestInfoInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$UserCreateWithoutGuestInfoInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$UserWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$UserUpsertWithoutGuestInfoInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserUpdateWithoutGuestInfoInput get update =>
      (_$data['update'] as Input$UserUpdateWithoutGuestInfoInput);
  Input$UserCreateWithoutGuestInfoInput get create =>
      (_$data['create'] as Input$UserCreateWithoutGuestInfoInput);
  Input$UserWhereInput? get where => (_$data['where'] as Input$UserWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpsertWithoutGuestInfoInput<
          Input$UserUpsertWithoutGuestInfoInput>
      get copyWith => CopyWith$Input$UserUpsertWithoutGuestInfoInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpsertWithoutGuestInfoInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpsertWithoutGuestInfoInput<TRes> {
  factory CopyWith$Input$UserUpsertWithoutGuestInfoInput(
    Input$UserUpsertWithoutGuestInfoInput instance,
    TRes Function(Input$UserUpsertWithoutGuestInfoInput) then,
  ) = _CopyWithImpl$Input$UserUpsertWithoutGuestInfoInput;

  factory CopyWith$Input$UserUpsertWithoutGuestInfoInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpsertWithoutGuestInfoInput;

  TRes call({
    Input$UserUpdateWithoutGuestInfoInput? update,
    Input$UserCreateWithoutGuestInfoInput? create,
    Input$UserWhereInput? where,
  });
  CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> get update;
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create;
  CopyWith$Input$UserWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$UserUpsertWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserUpsertWithoutGuestInfoInput<TRes> {
  _CopyWithImpl$Input$UserUpsertWithoutGuestInfoInput(
    this._instance,
    this._then,
  );

  final Input$UserUpsertWithoutGuestInfoInput _instance;

  final TRes Function(Input$UserUpsertWithoutGuestInfoInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$UserUpsertWithoutGuestInfoInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$UserUpdateWithoutGuestInfoInput),
        if (create != _undefined && create != null)
          'create': (create as Input$UserCreateWithoutGuestInfoInput),
        if (where != _undefined) 'where': (where as Input$UserWhereInput?),
      }));
  CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$UserUpdateWithoutGuestInfoInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$UserCreateWithoutGuestInfoInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$UserUpsertWithoutGuestInfoInput<TRes>
    implements CopyWith$Input$UserUpsertWithoutGuestInfoInput<TRes> {
  _CopyWithStubImpl$Input$UserUpsertWithoutGuestInfoInput(this._res);

  TRes _res;

  call({
    Input$UserUpdateWithoutGuestInfoInput? update,
    Input$UserCreateWithoutGuestInfoInput? create,
    Input$UserWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$UserUpdateWithoutGuestInfoInput<TRes> get update =>
      CopyWith$Input$UserUpdateWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$UserCreateWithoutGuestInfoInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutGuestInfoInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get where =>
      CopyWith$Input$UserWhereInput.stub(_res);
}

class Input$UserUpsertWithoutQrCodeInput {
  factory Input$UserUpsertWithoutQrCodeInput({
    required Input$UserUpdateWithoutQrCodeInput update,
    required Input$UserCreateWithoutQrCodeInput create,
    Input$UserWhereInput? where,
  }) =>
      Input$UserUpsertWithoutQrCodeInput._({
        r'update': update,
        r'create': create,
        if (where != null) r'where': where,
      });

  Input$UserUpsertWithoutQrCodeInput._(this._$data);

  factory Input$UserUpsertWithoutQrCodeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$UserUpdateWithoutQrCodeInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$UserCreateWithoutQrCodeInput.fromJson(
        (l$create as Map<String, dynamic>));
    if (data.containsKey('where')) {
      final l$where = data['where'];
      result$data['where'] = l$where == null
          ? null
          : Input$UserWhereInput.fromJson((l$where as Map<String, dynamic>));
    }
    return Input$UserUpsertWithoutQrCodeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$UserUpdateWithoutQrCodeInput get update =>
      (_$data['update'] as Input$UserUpdateWithoutQrCodeInput);
  Input$UserCreateWithoutQrCodeInput get create =>
      (_$data['create'] as Input$UserCreateWithoutQrCodeInput);
  Input$UserWhereInput? get where => (_$data['where'] as Input$UserWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    if (_$data.containsKey('where')) {
      final l$where = where;
      result$data['where'] = l$where?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserUpsertWithoutQrCodeInput<
          Input$UserUpsertWithoutQrCodeInput>
      get copyWith => CopyWith$Input$UserUpsertWithoutQrCodeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserUpsertWithoutQrCodeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (_$data.containsKey('where') != other._$data.containsKey('where')) {
      return false;
    }
    if (l$where != lOther$where) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    final l$where = where;
    return Object.hashAll([
      l$update,
      l$create,
      _$data.containsKey('where') ? l$where : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserUpsertWithoutQrCodeInput<TRes> {
  factory CopyWith$Input$UserUpsertWithoutQrCodeInput(
    Input$UserUpsertWithoutQrCodeInput instance,
    TRes Function(Input$UserUpsertWithoutQrCodeInput) then,
  ) = _CopyWithImpl$Input$UserUpsertWithoutQrCodeInput;

  factory CopyWith$Input$UserUpsertWithoutQrCodeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserUpsertWithoutQrCodeInput;

  TRes call({
    Input$UserUpdateWithoutQrCodeInput? update,
    Input$UserCreateWithoutQrCodeInput? create,
    Input$UserWhereInput? where,
  });
  CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> get update;
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create;
  CopyWith$Input$UserWhereInput<TRes> get where;
}

class _CopyWithImpl$Input$UserUpsertWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserUpsertWithoutQrCodeInput<TRes> {
  _CopyWithImpl$Input$UserUpsertWithoutQrCodeInput(
    this._instance,
    this._then,
  );

  final Input$UserUpsertWithoutQrCodeInput _instance;

  final TRes Function(Input$UserUpsertWithoutQrCodeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
    Object? where = _undefined,
  }) =>
      _then(Input$UserUpsertWithoutQrCodeInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$UserUpdateWithoutQrCodeInput),
        if (create != _undefined && create != null)
          'create': (create as Input$UserCreateWithoutQrCodeInput),
        if (where != _undefined) 'where': (where as Input$UserWhereInput?),
      }));
  CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$UserUpdateWithoutQrCodeInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$UserCreateWithoutQrCodeInput(
        local$create, (e) => call(create: e));
  }

  CopyWith$Input$UserWhereInput<TRes> get where {
    final local$where = _instance.where;
    return local$where == null
        ? CopyWith$Input$UserWhereInput.stub(_then(_instance))
        : CopyWith$Input$UserWhereInput(local$where, (e) => call(where: e));
  }
}

class _CopyWithStubImpl$Input$UserUpsertWithoutQrCodeInput<TRes>
    implements CopyWith$Input$UserUpsertWithoutQrCodeInput<TRes> {
  _CopyWithStubImpl$Input$UserUpsertWithoutQrCodeInput(this._res);

  TRes _res;

  call({
    Input$UserUpdateWithoutQrCodeInput? update,
    Input$UserCreateWithoutQrCodeInput? create,
    Input$UserWhereInput? where,
  }) =>
      _res;
  CopyWith$Input$UserUpdateWithoutQrCodeInput<TRes> get update =>
      CopyWith$Input$UserUpdateWithoutQrCodeInput.stub(_res);
  CopyWith$Input$UserCreateWithoutQrCodeInput<TRes> get create =>
      CopyWith$Input$UserCreateWithoutQrCodeInput.stub(_res);
  CopyWith$Input$UserWhereInput<TRes> get where =>
      CopyWith$Input$UserWhereInput.stub(_res);
}

class Input$UserWhereInput {
  factory Input$UserWhereInput({
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? email,
    Input$StringFilter? password,
    Input$StringNullableFilter? whatsapp,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$StringNullableFilter? guestInfoId,
    Input$GuestNullableRelationFilter? guestInfo,
    Input$QrCodeListRelationFilter? QrCode,
  }) =>
      Input$UserWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (fullName != null) r'fullName': fullName,
        if (email != null) r'email': email,
        if (password != null) r'password': password,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (guestInfo != null) r'guestInfo': guestInfo,
        if (QrCode != null) r'QrCode': QrCode,
      });

  Input$UserWhereInput._(this._$data);

  factory Input$UserWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$StringFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFilter.fromJson((l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = l$email == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$email as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$StringFilter.fromJson((l$password as Map<String, dynamic>));
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = l$whatsapp == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$whatsapp as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFilter.fromJson((l$role as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = l$guestInfoId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$guestInfoId as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfo')) {
      final l$guestInfo = data['guestInfo'];
      result$data['guestInfo'] = l$guestInfo == null
          ? null
          : Input$GuestNullableRelationFilter.fromJson(
              (l$guestInfo as Map<String, dynamic>));
    }
    if (data.containsKey('QrCode')) {
      final l$QrCode = data['QrCode'];
      result$data['QrCode'] = l$QrCode == null
          ? null
          : Input$QrCodeListRelationFilter.fromJson(
              (l$QrCode as Map<String, dynamic>));
    }
    return Input$UserWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$UserWhereInput>? get AND =>
      (_$data['AND'] as List<Input$UserWhereInput>?);
  List<Input$UserWhereInput>? get OR =>
      (_$data['OR'] as List<Input$UserWhereInput>?);
  List<Input$UserWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$UserWhereInput>?);
  Input$StringFilter? get id => (_$data['id'] as Input$StringFilter?);
  Input$StringFilter? get fullName =>
      (_$data['fullName'] as Input$StringFilter?);
  Input$StringNullableFilter? get email =>
      (_$data['email'] as Input$StringNullableFilter?);
  Input$StringFilter? get password =>
      (_$data['password'] as Input$StringFilter?);
  Input$StringNullableFilter? get whatsapp =>
      (_$data['whatsapp'] as Input$StringNullableFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$DateTimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFilter?);
  Input$DateTimeNullableFilter? get deletedAt =>
      (_$data['deletedAt'] as Input$DateTimeNullableFilter?);
  Input$EnumUserRoleFilter? get role =>
      (_$data['role'] as Input$EnumUserRoleFilter?);
  Input$StringNullableFilter? get guestInfoId =>
      (_$data['guestInfoId'] as Input$StringNullableFilter?);
  Input$GuestNullableRelationFilter? get guestInfo =>
      (_$data['guestInfo'] as Input$GuestNullableRelationFilter?);
  Input$QrCodeListRelationFilter? get QrCode =>
      (_$data['QrCode'] as Input$QrCodeListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId?.toJson();
    }
    if (_$data.containsKey('guestInfo')) {
      final l$guestInfo = guestInfo;
      result$data['guestInfo'] = l$guestInfo?.toJson();
    }
    if (_$data.containsKey('QrCode')) {
      final l$QrCode = QrCode;
      result$data['QrCode'] = l$QrCode?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserWhereInput<Input$UserWhereInput> get copyWith =>
      CopyWith$Input$UserWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserWhereInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$guestInfo = guestInfo;
    final lOther$guestInfo = other.guestInfo;
    if (_$data.containsKey('guestInfo') !=
        other._$data.containsKey('guestInfo')) {
      return false;
    }
    if (l$guestInfo != lOther$guestInfo) {
      return false;
    }
    final l$QrCode = QrCode;
    final lOther$QrCode = other.QrCode;
    if (_$data.containsKey('QrCode') != other._$data.containsKey('QrCode')) {
      return false;
    }
    if (l$QrCode != lOther$QrCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$fullName = fullName;
    final l$email = email;
    final l$password = password;
    final l$whatsapp = whatsapp;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$guestInfo = guestInfo;
    final l$QrCode = QrCode;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('guestInfo') ? l$guestInfo : const {},
      _$data.containsKey('QrCode') ? l$QrCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserWhereInput<TRes> {
  factory CopyWith$Input$UserWhereInput(
    Input$UserWhereInput instance,
    TRes Function(Input$UserWhereInput) then,
  ) = _CopyWithImpl$Input$UserWhereInput;

  factory CopyWith$Input$UserWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserWhereInput;

  TRes call({
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? email,
    Input$StringFilter? password,
    Input$StringNullableFilter? whatsapp,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$StringNullableFilter? guestInfoId,
    Input$GuestNullableRelationFilter? guestInfo,
    Input$QrCodeListRelationFilter? QrCode,
  });
  TRes AND(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get fullName;
  CopyWith$Input$StringNullableFilter<TRes> get email;
  CopyWith$Input$StringFilter<TRes> get password;
  CopyWith$Input$StringNullableFilter<TRes> get whatsapp;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$DateTimeFilter<TRes> get updatedAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFilter<TRes> get role;
  CopyWith$Input$StringNullableFilter<TRes> get guestInfoId;
  CopyWith$Input$GuestNullableRelationFilter<TRes> get guestInfo;
  CopyWith$Input$QrCodeListRelationFilter<TRes> get QrCode;
}

class _CopyWithImpl$Input$UserWhereInput<TRes>
    implements CopyWith$Input$UserWhereInput<TRes> {
  _CopyWithImpl$Input$UserWhereInput(
    this._instance,
    this._then,
  );

  final Input$UserWhereInput _instance;

  final TRes Function(Input$UserWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? fullName = _undefined,
    Object? email = _undefined,
    Object? password = _undefined,
    Object? whatsapp = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? guestInfo = _undefined,
    Object? QrCode = _undefined,
  }) =>
      _then(Input$UserWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$UserWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$UserWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$UserWhereInput>?),
        if (id != _undefined) 'id': (id as Input$StringFilter?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFilter?),
        if (email != _undefined)
          'email': (email as Input$StringNullableFilter?),
        if (password != _undefined)
          'password': (password as Input$StringFilter?),
        if (whatsapp != _undefined)
          'whatsapp': (whatsapp as Input$StringNullableFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFilter?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$DateTimeNullableFilter?),
        if (role != _undefined) 'role': (role as Input$EnumUserRoleFilter?),
        if (guestInfoId != _undefined)
          'guestInfoId': (guestInfoId as Input$StringNullableFilter?),
        if (guestInfo != _undefined)
          'guestInfo': (guestInfo as Input$GuestNullableRelationFilter?),
        if (QrCode != _undefined)
          'QrCode': (QrCode as Input$QrCodeListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get email {
    final local$email = _instance.email;
    return local$email == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$email, (e) => call(email: e));
  }

  CopyWith$Input$StringFilter<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$password, (e) => call(password: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get whatsapp {
    final local$whatsapp = _instance.whatsapp;
    return local$whatsapp == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$whatsapp, (e) => call(whatsapp: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFilter<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$EnumUserRoleFilter(local$role, (e) => call(role: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get guestInfoId {
    final local$guestInfoId = _instance.guestInfoId;
    return local$guestInfoId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$guestInfoId, (e) => call(guestInfoId: e));
  }

  CopyWith$Input$GuestNullableRelationFilter<TRes> get guestInfo {
    final local$guestInfo = _instance.guestInfo;
    return local$guestInfo == null
        ? CopyWith$Input$GuestNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestNullableRelationFilter(
            local$guestInfo, (e) => call(guestInfo: e));
  }

  CopyWith$Input$QrCodeListRelationFilter<TRes> get QrCode {
    final local$QrCode = _instance.QrCode;
    return local$QrCode == null
        ? CopyWith$Input$QrCodeListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$QrCodeListRelationFilter(
            local$QrCode, (e) => call(QrCode: e));
  }
}

class _CopyWithStubImpl$Input$UserWhereInput<TRes>
    implements CopyWith$Input$UserWhereInput<TRes> {
  _CopyWithStubImpl$Input$UserWhereInput(this._res);

  TRes _res;

  call({
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? id,
    Input$StringFilter? fullName,
    Input$StringNullableFilter? email,
    Input$StringFilter? password,
    Input$StringNullableFilter? whatsapp,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$StringNullableFilter? guestInfoId,
    Input$GuestNullableRelationFilter? guestInfo,
    Input$QrCodeListRelationFilter? QrCode,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get id =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get fullName =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get email =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get password =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get whatsapp =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$EnumUserRoleFilter<TRes> get role =>
      CopyWith$Input$EnumUserRoleFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get guestInfoId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$GuestNullableRelationFilter<TRes> get guestInfo =>
      CopyWith$Input$GuestNullableRelationFilter.stub(_res);
  CopyWith$Input$QrCodeListRelationFilter<TRes> get QrCode =>
      CopyWith$Input$QrCodeListRelationFilter.stub(_res);
}

class Input$UserWhereUniqueInput {
  factory Input$UserWhereUniqueInput({
    String? id,
    String? email,
    String? whatsapp,
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? fullName,
    Input$StringFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$StringNullableFilter? guestInfoId,
    Input$GuestNullableRelationFilter? guestInfo,
    Input$QrCodeListRelationFilter? QrCode,
  }) =>
      Input$UserWhereUniqueInput._({
        if (id != null) r'id': id,
        if (email != null) r'email': email,
        if (whatsapp != null) r'whatsapp': whatsapp,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (fullName != null) r'fullName': fullName,
        if (password != null) r'password': password,
        if (createdAt != null) r'createdAt': createdAt,
        if (updatedAt != null) r'updatedAt': updatedAt,
        if (deletedAt != null) r'deletedAt': deletedAt,
        if (role != null) r'role': role,
        if (guestInfoId != null) r'guestInfoId': guestInfoId,
        if (guestInfo != null) r'guestInfo': guestInfo,
        if (QrCode != null) r'QrCode': QrCode,
      });

  Input$UserWhereUniqueInput._(this._$data);

  factory Input$UserWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    if (data.containsKey('whatsapp')) {
      final l$whatsapp = data['whatsapp'];
      result$data['whatsapp'] = (l$whatsapp as String?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map(
              (e) => Input$UserWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('fullName')) {
      final l$fullName = data['fullName'];
      result$data['fullName'] = l$fullName == null
          ? null
          : Input$StringFilter.fromJson((l$fullName as Map<String, dynamic>));
    }
    if (data.containsKey('password')) {
      final l$password = data['password'];
      result$data['password'] = l$password == null
          ? null
          : Input$StringFilter.fromJson((l$password as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('updatedAt')) {
      final l$updatedAt = data['updatedAt'];
      result$data['updatedAt'] = l$updatedAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$updatedAt as Map<String, dynamic>));
    }
    if (data.containsKey('deletedAt')) {
      final l$deletedAt = data['deletedAt'];
      result$data['deletedAt'] = l$deletedAt == null
          ? null
          : Input$DateTimeNullableFilter.fromJson(
              (l$deletedAt as Map<String, dynamic>));
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : Input$EnumUserRoleFilter.fromJson((l$role as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfoId')) {
      final l$guestInfoId = data['guestInfoId'];
      result$data['guestInfoId'] = l$guestInfoId == null
          ? null
          : Input$StringNullableFilter.fromJson(
              (l$guestInfoId as Map<String, dynamic>));
    }
    if (data.containsKey('guestInfo')) {
      final l$guestInfo = data['guestInfo'];
      result$data['guestInfo'] = l$guestInfo == null
          ? null
          : Input$GuestNullableRelationFilter.fromJson(
              (l$guestInfo as Map<String, dynamic>));
    }
    if (data.containsKey('QrCode')) {
      final l$QrCode = data['QrCode'];
      result$data['QrCode'] = l$QrCode == null
          ? null
          : Input$QrCodeListRelationFilter.fromJson(
              (l$QrCode as Map<String, dynamic>));
    }
    return Input$UserWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get id => (_$data['id'] as String?);
  String? get email => (_$data['email'] as String?);
  String? get whatsapp => (_$data['whatsapp'] as String?);
  List<Input$UserWhereInput>? get AND =>
      (_$data['AND'] as List<Input$UserWhereInput>?);
  List<Input$UserWhereInput>? get OR =>
      (_$data['OR'] as List<Input$UserWhereInput>?);
  List<Input$UserWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$UserWhereInput>?);
  Input$StringFilter? get fullName =>
      (_$data['fullName'] as Input$StringFilter?);
  Input$StringFilter? get password =>
      (_$data['password'] as Input$StringFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$DateTimeFilter? get updatedAt =>
      (_$data['updatedAt'] as Input$DateTimeFilter?);
  Input$DateTimeNullableFilter? get deletedAt =>
      (_$data['deletedAt'] as Input$DateTimeNullableFilter?);
  Input$EnumUserRoleFilter? get role =>
      (_$data['role'] as Input$EnumUserRoleFilter?);
  Input$StringNullableFilter? get guestInfoId =>
      (_$data['guestInfoId'] as Input$StringNullableFilter?);
  Input$GuestNullableRelationFilter? get guestInfo =>
      (_$data['guestInfo'] as Input$GuestNullableRelationFilter?);
  Input$QrCodeListRelationFilter? get QrCode =>
      (_$data['QrCode'] as Input$QrCodeListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    if (_$data.containsKey('whatsapp')) {
      final l$whatsapp = whatsapp;
      result$data['whatsapp'] = l$whatsapp;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('fullName')) {
      final l$fullName = fullName;
      result$data['fullName'] = l$fullName?.toJson();
    }
    if (_$data.containsKey('password')) {
      final l$password = password;
      result$data['password'] = l$password?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('updatedAt')) {
      final l$updatedAt = updatedAt;
      result$data['updatedAt'] = l$updatedAt?.toJson();
    }
    if (_$data.containsKey('deletedAt')) {
      final l$deletedAt = deletedAt;
      result$data['deletedAt'] = l$deletedAt?.toJson();
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role?.toJson();
    }
    if (_$data.containsKey('guestInfoId')) {
      final l$guestInfoId = guestInfoId;
      result$data['guestInfoId'] = l$guestInfoId?.toJson();
    }
    if (_$data.containsKey('guestInfo')) {
      final l$guestInfo = guestInfo;
      result$data['guestInfo'] = l$guestInfo?.toJson();
    }
    if (_$data.containsKey('QrCode')) {
      final l$QrCode = QrCode;
      result$data['QrCode'] = l$QrCode?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$UserWhereUniqueInput<Input$UserWhereUniqueInput>
      get copyWith => CopyWith$Input$UserWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$whatsapp = whatsapp;
    final lOther$whatsapp = other.whatsapp;
    if (_$data.containsKey('whatsapp') !=
        other._$data.containsKey('whatsapp')) {
      return false;
    }
    if (l$whatsapp != lOther$whatsapp) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$fullName = fullName;
    final lOther$fullName = other.fullName;
    if (_$data.containsKey('fullName') !=
        other._$data.containsKey('fullName')) {
      return false;
    }
    if (l$fullName != lOther$fullName) {
      return false;
    }
    final l$password = password;
    final lOther$password = other.password;
    if (_$data.containsKey('password') !=
        other._$data.containsKey('password')) {
      return false;
    }
    if (l$password != lOther$password) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$updatedAt = updatedAt;
    final lOther$updatedAt = other.updatedAt;
    if (_$data.containsKey('updatedAt') !=
        other._$data.containsKey('updatedAt')) {
      return false;
    }
    if (l$updatedAt != lOther$updatedAt) {
      return false;
    }
    final l$deletedAt = deletedAt;
    final lOther$deletedAt = other.deletedAt;
    if (_$data.containsKey('deletedAt') !=
        other._$data.containsKey('deletedAt')) {
      return false;
    }
    if (l$deletedAt != lOther$deletedAt) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$guestInfoId = guestInfoId;
    final lOther$guestInfoId = other.guestInfoId;
    if (_$data.containsKey('guestInfoId') !=
        other._$data.containsKey('guestInfoId')) {
      return false;
    }
    if (l$guestInfoId != lOther$guestInfoId) {
      return false;
    }
    final l$guestInfo = guestInfo;
    final lOther$guestInfo = other.guestInfo;
    if (_$data.containsKey('guestInfo') !=
        other._$data.containsKey('guestInfo')) {
      return false;
    }
    if (l$guestInfo != lOther$guestInfo) {
      return false;
    }
    final l$QrCode = QrCode;
    final lOther$QrCode = other.QrCode;
    if (_$data.containsKey('QrCode') != other._$data.containsKey('QrCode')) {
      return false;
    }
    if (l$QrCode != lOther$QrCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$email = email;
    final l$whatsapp = whatsapp;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$fullName = fullName;
    final l$password = password;
    final l$createdAt = createdAt;
    final l$updatedAt = updatedAt;
    final l$deletedAt = deletedAt;
    final l$role = role;
    final l$guestInfoId = guestInfoId;
    final l$guestInfo = guestInfo;
    final l$QrCode = QrCode;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('email') ? l$email : const {},
      _$data.containsKey('whatsapp') ? l$whatsapp : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('fullName') ? l$fullName : const {},
      _$data.containsKey('password') ? l$password : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('updatedAt') ? l$updatedAt : const {},
      _$data.containsKey('deletedAt') ? l$deletedAt : const {},
      _$data.containsKey('role') ? l$role : const {},
      _$data.containsKey('guestInfoId') ? l$guestInfoId : const {},
      _$data.containsKey('guestInfo') ? l$guestInfo : const {},
      _$data.containsKey('QrCode') ? l$QrCode : const {},
    ]);
  }
}

abstract class CopyWith$Input$UserWhereUniqueInput<TRes> {
  factory CopyWith$Input$UserWhereUniqueInput(
    Input$UserWhereUniqueInput instance,
    TRes Function(Input$UserWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$UserWhereUniqueInput;

  factory CopyWith$Input$UserWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UserWhereUniqueInput;

  TRes call({
    String? id,
    String? email,
    String? whatsapp,
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? fullName,
    Input$StringFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$StringNullableFilter? guestInfoId,
    Input$GuestNullableRelationFilter? guestInfo,
    Input$QrCodeListRelationFilter? QrCode,
  });
  TRes AND(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$UserWhereInput>? Function(
              Iterable<CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
          _fn);
  CopyWith$Input$StringFilter<TRes> get fullName;
  CopyWith$Input$StringFilter<TRes> get password;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$DateTimeFilter<TRes> get updatedAt;
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt;
  CopyWith$Input$EnumUserRoleFilter<TRes> get role;
  CopyWith$Input$StringNullableFilter<TRes> get guestInfoId;
  CopyWith$Input$GuestNullableRelationFilter<TRes> get guestInfo;
  CopyWith$Input$QrCodeListRelationFilter<TRes> get QrCode;
}

class _CopyWithImpl$Input$UserWhereUniqueInput<TRes>
    implements CopyWith$Input$UserWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$UserWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$UserWhereUniqueInput _instance;

  final TRes Function(Input$UserWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? email = _undefined,
    Object? whatsapp = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? fullName = _undefined,
    Object? password = _undefined,
    Object? createdAt = _undefined,
    Object? updatedAt = _undefined,
    Object? deletedAt = _undefined,
    Object? role = _undefined,
    Object? guestInfoId = _undefined,
    Object? guestInfo = _undefined,
    Object? QrCode = _undefined,
  }) =>
      _then(Input$UserWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as String?),
        if (email != _undefined) 'email': (email as String?),
        if (whatsapp != _undefined) 'whatsapp': (whatsapp as String?),
        if (AND != _undefined) 'AND': (AND as List<Input$UserWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$UserWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$UserWhereInput>?),
        if (fullName != _undefined)
          'fullName': (fullName as Input$StringFilter?),
        if (password != _undefined)
          'password': (password as Input$StringFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (updatedAt != _undefined)
          'updatedAt': (updatedAt as Input$DateTimeFilter?),
        if (deletedAt != _undefined)
          'deletedAt': (deletedAt as Input$DateTimeNullableFilter?),
        if (role != _undefined) 'role': (role as Input$EnumUserRoleFilter?),
        if (guestInfoId != _undefined)
          'guestInfoId': (guestInfoId as Input$StringNullableFilter?),
        if (guestInfo != _undefined)
          'guestInfo': (guestInfo as Input$GuestNullableRelationFilter?),
        if (QrCode != _undefined)
          'QrCode': (QrCode as Input$QrCodeListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$UserWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$UserWhereInput<Input$UserWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$UserWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$StringFilter<TRes> get fullName {
    final local$fullName = _instance.fullName;
    return local$fullName == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$fullName, (e) => call(fullName: e));
  }

  CopyWith$Input$StringFilter<TRes> get password {
    final local$password = _instance.password;
    return local$password == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$password, (e) => call(password: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get updatedAt {
    final local$updatedAt = _instance.updatedAt;
    return local$updatedAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$updatedAt, (e) => call(updatedAt: e));
  }

  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt {
    final local$deletedAt = _instance.deletedAt;
    return local$deletedAt == null
        ? CopyWith$Input$DateTimeNullableFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeNullableFilter(
            local$deletedAt, (e) => call(deletedAt: e));
  }

  CopyWith$Input$EnumUserRoleFilter<TRes> get role {
    final local$role = _instance.role;
    return local$role == null
        ? CopyWith$Input$EnumUserRoleFilter.stub(_then(_instance))
        : CopyWith$Input$EnumUserRoleFilter(local$role, (e) => call(role: e));
  }

  CopyWith$Input$StringNullableFilter<TRes> get guestInfoId {
    final local$guestInfoId = _instance.guestInfoId;
    return local$guestInfoId == null
        ? CopyWith$Input$StringNullableFilter.stub(_then(_instance))
        : CopyWith$Input$StringNullableFilter(
            local$guestInfoId, (e) => call(guestInfoId: e));
  }

  CopyWith$Input$GuestNullableRelationFilter<TRes> get guestInfo {
    final local$guestInfo = _instance.guestInfo;
    return local$guestInfo == null
        ? CopyWith$Input$GuestNullableRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestNullableRelationFilter(
            local$guestInfo, (e) => call(guestInfo: e));
  }

  CopyWith$Input$QrCodeListRelationFilter<TRes> get QrCode {
    final local$QrCode = _instance.QrCode;
    return local$QrCode == null
        ? CopyWith$Input$QrCodeListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$QrCodeListRelationFilter(
            local$QrCode, (e) => call(QrCode: e));
  }
}

class _CopyWithStubImpl$Input$UserWhereUniqueInput<TRes>
    implements CopyWith$Input$UserWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$UserWhereUniqueInput(this._res);

  TRes _res;

  call({
    String? id,
    String? email,
    String? whatsapp,
    List<Input$UserWhereInput>? AND,
    List<Input$UserWhereInput>? OR,
    List<Input$UserWhereInput>? NOT,
    Input$StringFilter? fullName,
    Input$StringFilter? password,
    Input$DateTimeFilter? createdAt,
    Input$DateTimeFilter? updatedAt,
    Input$DateTimeNullableFilter? deletedAt,
    Input$EnumUserRoleFilter? role,
    Input$StringNullableFilter? guestInfoId,
    Input$GuestNullableRelationFilter? guestInfo,
    Input$QrCodeListRelationFilter? QrCode,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$StringFilter<TRes> get fullName =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get password =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get updatedAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$DateTimeNullableFilter<TRes> get deletedAt =>
      CopyWith$Input$DateTimeNullableFilter.stub(_res);
  CopyWith$Input$EnumUserRoleFilter<TRes> get role =>
      CopyWith$Input$EnumUserRoleFilter.stub(_res);
  CopyWith$Input$StringNullableFilter<TRes> get guestInfoId =>
      CopyWith$Input$StringNullableFilter.stub(_res);
  CopyWith$Input$GuestNullableRelationFilter<TRes> get guestInfo =>
      CopyWith$Input$GuestNullableRelationFilter.stub(_res);
  CopyWith$Input$QrCodeListRelationFilter<TRes> get QrCode =>
      CopyWith$Input$QrCodeListRelationFilter.stub(_res);
}

class Input$WhatsappQueueAvgAggregateInput {
  factory Input$WhatsappQueueAvgAggregateInput({bool? id}) =>
      Input$WhatsappQueueAvgAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$WhatsappQueueAvgAggregateInput._(this._$data);

  factory Input$WhatsappQueueAvgAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    return Input$WhatsappQueueAvgAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueAvgAggregateInput<
          Input$WhatsappQueueAvgAggregateInput>
      get copyWith => CopyWith$Input$WhatsappQueueAvgAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueAvgAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$WhatsappQueueAvgAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappQueueAvgAggregateInput(
    Input$WhatsappQueueAvgAggregateInput instance,
    TRes Function(Input$WhatsappQueueAvgAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueAvgAggregateInput;

  factory CopyWith$Input$WhatsappQueueAvgAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueAvgAggregateInput;

  TRes call({bool? id});
}

class _CopyWithImpl$Input$WhatsappQueueAvgAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueAvgAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueAvgAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueAvgAggregateInput _instance;

  final TRes Function(Input$WhatsappQueueAvgAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$WhatsappQueueAvgAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueAvgAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueAvgAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueAvgAggregateInput(this._res);

  TRes _res;

  call({bool? id}) => _res;
}

class Input$WhatsappQueueCountAggregateInput {
  factory Input$WhatsappQueueCountAggregateInput({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  }) =>
      Input$WhatsappQueueCountAggregateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if ($_all != null) r'_all': $_all,
      });

  Input$WhatsappQueueCountAggregateInput._(this._$data);

  factory Input$WhatsappQueueCountAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    if (data.containsKey('_all')) {
      final l$$_all = data['_all'];
      result$data['_all'] = (l$$_all as bool?);
    }
    return Input$WhatsappQueueCountAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  bool? get $_all => (_$data['_all'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    if (_$data.containsKey('_all')) {
      final l$$_all = $_all;
      result$data['_all'] = l$$_all;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueCountAggregateInput<
          Input$WhatsappQueueCountAggregateInput>
      get copyWith => CopyWith$Input$WhatsappQueueCountAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueCountAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$$_all = $_all;
    final lOther$$_all = other.$_all;
    if (_$data.containsKey('_all') != other._$data.containsKey('_all')) {
      return false;
    }
    if (l$$_all != lOther$$_all) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$$_all = $_all;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('_all') ? l$$_all : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueCountAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappQueueCountAggregateInput(
    Input$WhatsappQueueCountAggregateInput instance,
    TRes Function(Input$WhatsappQueueCountAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueCountAggregateInput;

  factory CopyWith$Input$WhatsappQueueCountAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueCountAggregateInput;

  TRes call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  });
}

class _CopyWithImpl$Input$WhatsappQueueCountAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueCountAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueCountAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueCountAggregateInput _instance;

  final TRes Function(Input$WhatsappQueueCountAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? $_all = _undefined,
  }) =>
      _then(Input$WhatsappQueueCountAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
        if ($_all != _undefined) '_all': ($_all as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueCountAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueCountAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueCountAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
    bool? $_all,
  }) =>
      _res;
}

class Input$WhatsappQueueCreateInput {
  factory Input$WhatsappQueueCreateInput({
    String? createdAt,
    Enum$QueueStatus? status,
    required Input$GuestCreateNestedOneWithoutWhatsappQueueInput guest,
  }) =>
      Input$WhatsappQueueCreateInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        r'guest': guest,
      });

  Input$WhatsappQueueCreateInput._(this._$data);

  factory Input$WhatsappQueueCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    final l$guest = data['guest'];
    result$data['guest'] =
        Input$GuestCreateNestedOneWithoutWhatsappQueueInput.fromJson(
            (l$guest as Map<String, dynamic>));
    return Input$WhatsappQueueCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Input$GuestCreateNestedOneWithoutWhatsappQueueInput get guest =>
      (_$data['guest'] as Input$GuestCreateNestedOneWithoutWhatsappQueueInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    final l$guest = guest;
    result$data['guest'] = l$guest.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappQueueCreateInput<Input$WhatsappQueueCreateInput>
      get copyWith => CopyWith$Input$WhatsappQueueCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      l$guest,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueCreateInput<TRes> {
  factory CopyWith$Input$WhatsappQueueCreateInput(
    Input$WhatsappQueueCreateInput instance,
    TRes Function(Input$WhatsappQueueCreateInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueCreateInput;

  factory CopyWith$Input$WhatsappQueueCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueCreateInput;

  TRes call({
    String? createdAt,
    Enum$QueueStatus? status,
    Input$GuestCreateNestedOneWithoutWhatsappQueueInput? guest,
  });
  CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<TRes> get guest;
}

class _CopyWithImpl$Input$WhatsappQueueCreateInput<TRes>
    implements CopyWith$Input$WhatsappQueueCreateInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueCreateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueCreateInput _instance;

  final TRes Function(Input$WhatsappQueueCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappQueueCreateInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
        if (guest != _undefined && guest != null)
          'guest':
              (guest as Input$GuestCreateNestedOneWithoutWhatsappQueueInput),
      }));
  CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<TRes> get guest {
    final local$guest = _instance.guest;
    return CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput(
        local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueCreateInput<TRes>
    implements CopyWith$Input$WhatsappQueueCreateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueCreateInput(this._res);

  TRes _res;

  call({
    String? createdAt,
    Enum$QueueStatus? status,
    Input$GuestCreateNestedOneWithoutWhatsappQueueInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput<TRes>
      get guest =>
          CopyWith$Input$GuestCreateNestedOneWithoutWhatsappQueueInput.stub(
              _res);
}

class Input$WhatsappQueueCreateManyGuestInput {
  factory Input$WhatsappQueueCreateManyGuestInput({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      Input$WhatsappQueueCreateManyGuestInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$WhatsappQueueCreateManyGuestInput._(this._$data);

  factory Input$WhatsappQueueCreateManyGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    return Input$WhatsappQueueCreateManyGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueCreateManyGuestInput<
          Input$WhatsappQueueCreateManyGuestInput>
      get copyWith => CopyWith$Input$WhatsappQueueCreateManyGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueCreateManyGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueCreateManyGuestInput<TRes> {
  factory CopyWith$Input$WhatsappQueueCreateManyGuestInput(
    Input$WhatsappQueueCreateManyGuestInput instance,
    TRes Function(Input$WhatsappQueueCreateManyGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueCreateManyGuestInput;

  factory CopyWith$Input$WhatsappQueueCreateManyGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueCreateManyGuestInput;

  TRes call({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
  });
}

class _CopyWithImpl$Input$WhatsappQueueCreateManyGuestInput<TRes>
    implements CopyWith$Input$WhatsappQueueCreateManyGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueCreateManyGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueCreateManyGuestInput _instance;

  final TRes Function(Input$WhatsappQueueCreateManyGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$WhatsappQueueCreateManyGuestInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueCreateManyGuestInput<TRes>
    implements CopyWith$Input$WhatsappQueueCreateManyGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueCreateManyGuestInput(this._res);

  TRes _res;

  call({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      _res;
}

class Input$WhatsappQueueCreateManyGuestInputEnvelope {
  factory Input$WhatsappQueueCreateManyGuestInputEnvelope({
    required List<Input$WhatsappQueueCreateManyGuestInput> data,
    bool? skipDuplicates,
  }) =>
      Input$WhatsappQueueCreateManyGuestInputEnvelope._({
        r'data': data,
        if (skipDuplicates != null) r'skipDuplicates': skipDuplicates,
      });

  Input$WhatsappQueueCreateManyGuestInputEnvelope._(this._$data);

  factory Input$WhatsappQueueCreateManyGuestInputEnvelope.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$data = data['data'];
    result$data['data'] = (l$data as List<dynamic>)
        .map((e) => Input$WhatsappQueueCreateManyGuestInput.fromJson(
            (e as Map<String, dynamic>)))
        .toList();
    if (data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = data['skipDuplicates'];
      result$data['skipDuplicates'] = (l$skipDuplicates as bool?);
    }
    return Input$WhatsappQueueCreateManyGuestInputEnvelope._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappQueueCreateManyGuestInput> get data =>
      (_$data['data'] as List<Input$WhatsappQueueCreateManyGuestInput>);
  bool? get skipDuplicates => (_$data['skipDuplicates'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$data = data;
    result$data['data'] = l$data.map((e) => e.toJson()).toList();
    if (_$data.containsKey('skipDuplicates')) {
      final l$skipDuplicates = skipDuplicates;
      result$data['skipDuplicates'] = l$skipDuplicates;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<
          Input$WhatsappQueueCreateManyGuestInputEnvelope>
      get copyWith => CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueCreateManyGuestInputEnvelope) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data.length != lOther$data.length) {
      return false;
    }
    for (int i = 0; i < l$data.length; i++) {
      final l$data$entry = l$data[i];
      final lOther$data$entry = lOther$data[i];
      if (l$data$entry != lOther$data$entry) {
        return false;
      }
    }
    final l$skipDuplicates = skipDuplicates;
    final lOther$skipDuplicates = other.skipDuplicates;
    if (_$data.containsKey('skipDuplicates') !=
        other._$data.containsKey('skipDuplicates')) {
      return false;
    }
    if (l$skipDuplicates != lOther$skipDuplicates) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$data = data;
    final l$skipDuplicates = skipDuplicates;
    return Object.hashAll([
      Object.hashAll(l$data.map((v) => v)),
      _$data.containsKey('skipDuplicates') ? l$skipDuplicates : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes> {
  factory CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope(
    Input$WhatsappQueueCreateManyGuestInputEnvelope instance,
    TRes Function(Input$WhatsappQueueCreateManyGuestInputEnvelope) then,
  ) = _CopyWithImpl$Input$WhatsappQueueCreateManyGuestInputEnvelope;

  factory CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueCreateManyGuestInputEnvelope;

  TRes call({
    List<Input$WhatsappQueueCreateManyGuestInput>? data,
    bool? skipDuplicates,
  });
  TRes data(
      Iterable<Input$WhatsappQueueCreateManyGuestInput> Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueCreateManyGuestInput<
                      Input$WhatsappQueueCreateManyGuestInput>>)
          _fn);
}

class _CopyWithImpl$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes>
    implements CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes> {
  _CopyWithImpl$Input$WhatsappQueueCreateManyGuestInputEnvelope(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueCreateManyGuestInputEnvelope _instance;

  final TRes Function(Input$WhatsappQueueCreateManyGuestInputEnvelope) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? data = _undefined,
    Object? skipDuplicates = _undefined,
  }) =>
      _then(Input$WhatsappQueueCreateManyGuestInputEnvelope._({
        ..._instance._$data,
        if (data != _undefined && data != null)
          'data': (data as List<Input$WhatsappQueueCreateManyGuestInput>),
        if (skipDuplicates != _undefined)
          'skipDuplicates': (skipDuplicates as bool?),
      }));
  TRes data(
          Iterable<Input$WhatsappQueueCreateManyGuestInput> Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueCreateManyGuestInput<
                          Input$WhatsappQueueCreateManyGuestInput>>)
              _fn) =>
      call(
          data: _fn(_instance.data
              .map((e) => CopyWith$Input$WhatsappQueueCreateManyGuestInput(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes>
    implements CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueCreateManyGuestInputEnvelope(this._res);

  TRes _res;

  call({
    List<Input$WhatsappQueueCreateManyGuestInput>? data,
    bool? skipDuplicates,
  }) =>
      _res;
  data(_fn) => _res;
}

class Input$WhatsappQueueCreateManyInput {
  factory Input$WhatsappQueueCreateManyInput({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
    required String guestId,
  }) =>
      Input$WhatsappQueueCreateManyInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        r'guestId': guestId,
      });

  Input$WhatsappQueueCreateManyInput._(this._$data);

  factory Input$WhatsappQueueCreateManyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    final l$guestId = data['guestId'];
    result$data['guestId'] = (l$guestId as String);
    return Input$WhatsappQueueCreateManyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  String get guestId => (_$data['guestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    final l$guestId = guestId;
    result$data['guestId'] = l$guestId;
    return result$data;
  }

  CopyWith$Input$WhatsappQueueCreateManyInput<
          Input$WhatsappQueueCreateManyInput>
      get copyWith => CopyWith$Input$WhatsappQueueCreateManyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueCreateManyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      l$guestId,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueCreateManyInput<TRes> {
  factory CopyWith$Input$WhatsappQueueCreateManyInput(
    Input$WhatsappQueueCreateManyInput instance,
    TRes Function(Input$WhatsappQueueCreateManyInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueCreateManyInput;

  factory CopyWith$Input$WhatsappQueueCreateManyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueCreateManyInput;

  TRes call({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
    String? guestId,
  });
}

class _CopyWithImpl$Input$WhatsappQueueCreateManyInput<TRes>
    implements CopyWith$Input$WhatsappQueueCreateManyInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueCreateManyInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueCreateManyInput _instance;

  final TRes Function(Input$WhatsappQueueCreateManyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$WhatsappQueueCreateManyInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
        if (guestId != _undefined && guestId != null)
          'guestId': (guestId as String),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueCreateManyInput<TRes>
    implements CopyWith$Input$WhatsappQueueCreateManyInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueCreateManyInput(this._res);

  TRes _res;

  call({
    int? id,
    String? createdAt,
    Enum$QueueStatus? status,
    String? guestId,
  }) =>
      _res;
}

class Input$WhatsappQueueCreateNestedManyWithoutGuestInput {
  factory Input$WhatsappQueueCreateNestedManyWithoutGuestInput({
    List<Input$WhatsappQueueCreateWithoutGuestInput>? create,
    List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$WhatsappQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappQueueWhereUniqueInput>? connect,
  }) =>
      Input$WhatsappQueueCreateNestedManyWithoutGuestInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (createMany != null) r'createMany': createMany,
        if (connect != null) r'connect': connect,
      });

  Input$WhatsappQueueCreateNestedManyWithoutGuestInput._(this._$data);

  factory Input$WhatsappQueueCreateNestedManyWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueCreateWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$WhatsappQueueCreateOrConnectWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$WhatsappQueueCreateManyGuestInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$WhatsappQueueCreateNestedManyWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappQueueCreateWithoutGuestInput>? get create =>
      (_$data['create'] as List<Input$WhatsappQueueCreateWithoutGuestInput>?);
  List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>?);
  Input$WhatsappQueueCreateManyGuestInputEnvelope? get createMany =>
      (_$data['createMany']
          as Input$WhatsappQueueCreateManyGuestInputEnvelope?);
  List<Input$WhatsappQueueWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$WhatsappQueueWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<
          Input$WhatsappQueueCreateNestedManyWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueCreateNestedManyWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$createMany = createMany;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput(
    Input$WhatsappQueueCreateNestedManyWithoutGuestInput instance,
    TRes Function(Input$WhatsappQueueCreateNestedManyWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueCreateNestedManyWithoutGuestInput;

  factory CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueCreateNestedManyWithoutGuestInput;

  TRes call({
    List<Input$WhatsappQueueCreateWithoutGuestInput>? create,
    List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$WhatsappQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappQueueWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$WhatsappQueueCreateWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<
                      Input$WhatsappQueueCreateWithoutGuestInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<
                      Input$WhatsappQueueCreateOrConnectWithoutGuestInput>>?)
          _fn);
  CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes> get createMany;
  TRes connect(
      Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereUniqueInput<
                      Input$WhatsappQueueWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes>
    implements
        CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueCreateNestedManyWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueCreateNestedManyWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappQueueCreateNestedManyWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? createMany = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$WhatsappQueueCreateNestedManyWithoutGuestInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$WhatsappQueueCreateWithoutGuestInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$WhatsappQueueCreateManyGuestInputEnvelope?),
        if (connect != _undefined)
          'connect': (connect as List<Input$WhatsappQueueWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$WhatsappQueueCreateWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<
                          Input$WhatsappQueueCreateWithoutGuestInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$WhatsappQueueCreateWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<
                          Input$WhatsappQueueCreateOrConnectWithoutGuestInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes>
      get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes connect(
          Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereUniqueInput<
                          Input$WhatsappQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$WhatsappQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueCreateNestedManyWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueCreateNestedManyWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    List<Input$WhatsappQueueCreateWithoutGuestInput>? create,
    List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    Input$WhatsappQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappQueueWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes>
      get createMany =>
          CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope.stub(_res);
  connect(_fn) => _res;
}

class Input$WhatsappQueueCreateOrConnectWithoutGuestInput {
  factory Input$WhatsappQueueCreateOrConnectWithoutGuestInput({
    required Input$WhatsappQueueWhereUniqueInput where,
    required Input$WhatsappQueueCreateWithoutGuestInput create,
  }) =>
      Input$WhatsappQueueCreateOrConnectWithoutGuestInput._({
        r'where': where,
        r'create': create,
      });

  Input$WhatsappQueueCreateOrConnectWithoutGuestInput._(this._$data);

  factory Input$WhatsappQueueCreateOrConnectWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$WhatsappQueueWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$WhatsappQueueCreateWithoutGuestInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$WhatsappQueueCreateOrConnectWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappQueueWhereUniqueInput get where =>
      (_$data['where'] as Input$WhatsappQueueWhereUniqueInput);
  Input$WhatsappQueueCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$WhatsappQueueCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<
          Input$WhatsappQueueCreateOrConnectWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueCreateOrConnectWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput(
    Input$WhatsappQueueCreateOrConnectWithoutGuestInput instance,
    TRes Function(Input$WhatsappQueueCreateOrConnectWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueCreateOrConnectWithoutGuestInput;

  factory CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueCreateOrConnectWithoutGuestInput;

  TRes call({
    Input$WhatsappQueueWhereUniqueInput? where,
    Input$WhatsappQueueCreateWithoutGuestInput? create,
  });
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where;
  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<TRes>
    implements
        CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueCreateOrConnectWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueCreateOrConnectWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappQueueCreateOrConnectWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$WhatsappQueueCreateOrConnectWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$WhatsappQueueWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$WhatsappQueueCreateWithoutGuestInput),
      }));
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$WhatsappQueueWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$WhatsappQueueCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueCreateOrConnectWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$WhatsappQueueWhereUniqueInput? where,
    Input$WhatsappQueueCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where =>
      CopyWith$Input$WhatsappQueueWhereUniqueInput.stub(_res);
  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$WhatsappQueueCreateWithoutGuestInput.stub(_res);
}

class Input$WhatsappQueueCreateWithoutGuestInput {
  factory Input$WhatsappQueueCreateWithoutGuestInput({
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      Input$WhatsappQueueCreateWithoutGuestInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$WhatsappQueueCreateWithoutGuestInput._(this._$data);

  factory Input$WhatsappQueueCreateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as String?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$QueueStatus((l$status as String));
    }
    return Input$WhatsappQueueCreateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get createdAt => (_$data['createdAt'] as String?);
  Enum$QueueStatus? get status => (_$data['status'] as Enum$QueueStatus?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$QueueStatus(l$status);
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<
          Input$WhatsappQueueCreateWithoutGuestInput>
      get copyWith => CopyWith$Input$WhatsappQueueCreateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueCreateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> {
  factory CopyWith$Input$WhatsappQueueCreateWithoutGuestInput(
    Input$WhatsappQueueCreateWithoutGuestInput instance,
    TRes Function(Input$WhatsappQueueCreateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueCreateWithoutGuestInput;

  factory CopyWith$Input$WhatsappQueueCreateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueCreateWithoutGuestInput;

  TRes call({
    String? createdAt,
    Enum$QueueStatus? status,
  });
}

class _CopyWithImpl$Input$WhatsappQueueCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueCreateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueCreateWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappQueueCreateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$WhatsappQueueCreateWithoutGuestInput._({
        ..._instance._$data,
        if (createdAt != _undefined) 'createdAt': (createdAt as String?),
        if (status != _undefined) 'status': (status as Enum$QueueStatus?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueCreateWithoutGuestInput<TRes>
    implements CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueCreateWithoutGuestInput(this._res);

  TRes _res;

  call({
    String? createdAt,
    Enum$QueueStatus? status,
  }) =>
      _res;
}

class Input$WhatsappQueueListRelationFilter {
  factory Input$WhatsappQueueListRelationFilter({
    Input$WhatsappQueueWhereInput? every,
    Input$WhatsappQueueWhereInput? some,
    Input$WhatsappQueueWhereInput? none,
  }) =>
      Input$WhatsappQueueListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$WhatsappQueueListRelationFilter._(this._$data);

  factory Input$WhatsappQueueListRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$WhatsappQueueWhereInput.fromJson(
              (l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$WhatsappQueueWhereInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$WhatsappQueueWhereInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    return Input$WhatsappQueueListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappQueueWhereInput? get every =>
      (_$data['every'] as Input$WhatsappQueueWhereInput?);
  Input$WhatsappQueueWhereInput? get some =>
      (_$data['some'] as Input$WhatsappQueueWhereInput?);
  Input$WhatsappQueueWhereInput? get none =>
      (_$data['none'] as Input$WhatsappQueueWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueListRelationFilter<
          Input$WhatsappQueueListRelationFilter>
      get copyWith => CopyWith$Input$WhatsappQueueListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueListRelationFilter<TRes> {
  factory CopyWith$Input$WhatsappQueueListRelationFilter(
    Input$WhatsappQueueListRelationFilter instance,
    TRes Function(Input$WhatsappQueueListRelationFilter) then,
  ) = _CopyWithImpl$Input$WhatsappQueueListRelationFilter;

  factory CopyWith$Input$WhatsappQueueListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueListRelationFilter;

  TRes call({
    Input$WhatsappQueueWhereInput? every,
    Input$WhatsappQueueWhereInput? some,
    Input$WhatsappQueueWhereInput? none,
  });
  CopyWith$Input$WhatsappQueueWhereInput<TRes> get every;
  CopyWith$Input$WhatsappQueueWhereInput<TRes> get some;
  CopyWith$Input$WhatsappQueueWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$WhatsappQueueListRelationFilter<TRes>
    implements CopyWith$Input$WhatsappQueueListRelationFilter<TRes> {
  _CopyWithImpl$Input$WhatsappQueueListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueListRelationFilter _instance;

  final TRes Function(Input$WhatsappQueueListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$WhatsappQueueListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined)
          'every': (every as Input$WhatsappQueueWhereInput?),
        if (some != _undefined)
          'some': (some as Input$WhatsappQueueWhereInput?),
        if (none != _undefined)
          'none': (none as Input$WhatsappQueueWhereInput?),
      }));
  CopyWith$Input$WhatsappQueueWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$WhatsappQueueWhereInput.stub(_then(_instance))
        : CopyWith$Input$WhatsappQueueWhereInput(
            local$every, (e) => call(every: e));
  }

  CopyWith$Input$WhatsappQueueWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$WhatsappQueueWhereInput.stub(_then(_instance))
        : CopyWith$Input$WhatsappQueueWhereInput(
            local$some, (e) => call(some: e));
  }

  CopyWith$Input$WhatsappQueueWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$WhatsappQueueWhereInput.stub(_then(_instance))
        : CopyWith$Input$WhatsappQueueWhereInput(
            local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueListRelationFilter<TRes>
    implements CopyWith$Input$WhatsappQueueListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueListRelationFilter(this._res);

  TRes _res;

  call({
    Input$WhatsappQueueWhereInput? every,
    Input$WhatsappQueueWhereInput? some,
    Input$WhatsappQueueWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$WhatsappQueueWhereInput<TRes> get every =>
      CopyWith$Input$WhatsappQueueWhereInput.stub(_res);
  CopyWith$Input$WhatsappQueueWhereInput<TRes> get some =>
      CopyWith$Input$WhatsappQueueWhereInput.stub(_res);
  CopyWith$Input$WhatsappQueueWhereInput<TRes> get none =>
      CopyWith$Input$WhatsappQueueWhereInput.stub(_res);
}

class Input$WhatsappQueueMaxAggregateInput {
  factory Input$WhatsappQueueMaxAggregateInput({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      Input$WhatsappQueueMaxAggregateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$WhatsappQueueMaxAggregateInput._(this._$data);

  factory Input$WhatsappQueueMaxAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    return Input$WhatsappQueueMaxAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueMaxAggregateInput<
          Input$WhatsappQueueMaxAggregateInput>
      get copyWith => CopyWith$Input$WhatsappQueueMaxAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueMaxAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueMaxAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappQueueMaxAggregateInput(
    Input$WhatsappQueueMaxAggregateInput instance,
    TRes Function(Input$WhatsappQueueMaxAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueMaxAggregateInput;

  factory CopyWith$Input$WhatsappQueueMaxAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueMaxAggregateInput;

  TRes call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  });
}

class _CopyWithImpl$Input$WhatsappQueueMaxAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueMaxAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueMaxAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueMaxAggregateInput _instance;

  final TRes Function(Input$WhatsappQueueMaxAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$WhatsappQueueMaxAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueMaxAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueMaxAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueMaxAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      _res;
}

class Input$WhatsappQueueMinAggregateInput {
  factory Input$WhatsappQueueMinAggregateInput({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      Input$WhatsappQueueMinAggregateInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$WhatsappQueueMinAggregateInput._(this._$data);

  factory Input$WhatsappQueueMinAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = (l$createdAt as bool?);
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = (l$status as bool?);
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = (l$guestId as bool?);
    }
    return Input$WhatsappQueueMinAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  bool? get createdAt => (_$data['createdAt'] as bool?);
  bool? get status => (_$data['status'] as bool?);
  bool? get guestId => (_$data['guestId'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt;
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status;
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueMinAggregateInput<
          Input$WhatsappQueueMinAggregateInput>
      get copyWith => CopyWith$Input$WhatsappQueueMinAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueMinAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueMinAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappQueueMinAggregateInput(
    Input$WhatsappQueueMinAggregateInput instance,
    TRes Function(Input$WhatsappQueueMinAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueMinAggregateInput;

  factory CopyWith$Input$WhatsappQueueMinAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueMinAggregateInput;

  TRes call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  });
}

class _CopyWithImpl$Input$WhatsappQueueMinAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueMinAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueMinAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueMinAggregateInput _instance;

  final TRes Function(Input$WhatsappQueueMinAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$WhatsappQueueMinAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
        if (createdAt != _undefined) 'createdAt': (createdAt as bool?),
        if (status != _undefined) 'status': (status as bool?),
        if (guestId != _undefined) 'guestId': (guestId as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueMinAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueMinAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueMinAggregateInput(this._res);

  TRes _res;

  call({
    bool? id,
    bool? createdAt,
    bool? status,
    bool? guestId,
  }) =>
      _res;
}

class Input$WhatsappQueueOrderByRelationAggregateInput {
  factory Input$WhatsappQueueOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$WhatsappQueueOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$WhatsappQueueOrderByRelationAggregateInput._(this._$data);

  factory Input$WhatsappQueueOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$WhatsappQueueOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput<
          Input$WhatsappQueueOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput(
    Input$WhatsappQueueOrderByRelationAggregateInput instance,
    TRes Function(Input$WhatsappQueueOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueOrderByRelationAggregateInput;

  factory CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$WhatsappQueueOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueOrderByRelationAggregateInput _instance;

  final TRes Function(Input$WhatsappQueueOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$WhatsappQueueOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$WhatsappQueueOrderByWithRelationInput {
  factory Input$WhatsappQueueOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  }) =>
      Input$WhatsappQueueOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$WhatsappQueueOrderByWithRelationInput._(this._$data);

  factory Input$WhatsappQueueOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : fromJson$Enum$SortOrder((l$createdAt as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$SortOrder((l$status as String));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : fromJson$Enum$SortOrder((l$guestId as String));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestOrderByWithRelationInput.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$WhatsappQueueOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get createdAt => (_$data['createdAt'] as Enum$SortOrder?);
  Enum$SortOrder? get status => (_$data['status'] as Enum$SortOrder?);
  Enum$SortOrder? get guestId => (_$data['guestId'] as Enum$SortOrder?);
  Input$GuestOrderByWithRelationInput? get guest =>
      (_$data['guest'] as Input$GuestOrderByWithRelationInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] =
          l$createdAt == null ? null : toJson$Enum$SortOrder(l$createdAt);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$SortOrder(l$status);
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] =
          l$guestId == null ? null : toJson$Enum$SortOrder(l$guestId);
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueOrderByWithRelationInput<
          Input$WhatsappQueueOrderByWithRelationInput>
      get copyWith => CopyWith$Input$WhatsappQueueOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$WhatsappQueueOrderByWithRelationInput(
    Input$WhatsappQueueOrderByWithRelationInput instance,
    TRes Function(Input$WhatsappQueueOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueOrderByWithRelationInput;

  factory CopyWith$Input$WhatsappQueueOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  });
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest;
}

class _CopyWithImpl$Input$WhatsappQueueOrderByWithRelationInput<TRes>
    implements CopyWith$Input$WhatsappQueueOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueOrderByWithRelationInput _instance;

  final TRes Function(Input$WhatsappQueueOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappQueueOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Enum$SortOrder?),
        if (status != _undefined) 'status': (status as Enum$SortOrder?),
        if (guestId != _undefined) 'guestId': (guestId as Enum$SortOrder?),
        if (guest != _undefined)
          'guest': (guest as Input$GuestOrderByWithRelationInput?),
      }));
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$GuestOrderByWithRelationInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueOrderByWithRelationInput<TRes>
    implements CopyWith$Input$WhatsappQueueOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? createdAt,
    Enum$SortOrder? status,
    Enum$SortOrder? guestId,
    Input$GuestOrderByWithRelationInput? guest,
  }) =>
      _res;
  CopyWith$Input$GuestOrderByWithRelationInput<TRes> get guest =>
      CopyWith$Input$GuestOrderByWithRelationInput.stub(_res);
}

class Input$WhatsappQueueScalarWhereInput {
  factory Input$WhatsappQueueScalarWhereInput({
    List<Input$WhatsappQueueScalarWhereInput>? AND,
    List<Input$WhatsappQueueScalarWhereInput>? OR,
    List<Input$WhatsappQueueScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  }) =>
      Input$WhatsappQueueScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
      });

  Input$WhatsappQueueScalarWhereInput._(this._$data);

  factory Input$WhatsappQueueScalarWhereInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    return Input$WhatsappQueueScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappQueueScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$WhatsappQueueScalarWhereInput>?);
  List<Input$WhatsappQueueScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$WhatsappQueueScalarWhereInput>?);
  List<Input$WhatsappQueueScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$WhatsappQueueScalarWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueScalarWhereInput<
          Input$WhatsappQueueScalarWhereInput>
      get copyWith => CopyWith$Input$WhatsappQueueScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueScalarWhereInput<TRes> {
  factory CopyWith$Input$WhatsappQueueScalarWhereInput(
    Input$WhatsappQueueScalarWhereInput instance,
    TRes Function(Input$WhatsappQueueScalarWhereInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueScalarWhereInput;

  factory CopyWith$Input$WhatsappQueueScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueScalarWhereInput;

  TRes call({
    List<Input$WhatsappQueueScalarWhereInput>? AND,
    List<Input$WhatsappQueueScalarWhereInput>? OR,
    List<Input$WhatsappQueueScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  });
  TRes AND(
      Iterable<Input$WhatsappQueueScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueScalarWhereInput<
                      Input$WhatsappQueueScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$WhatsappQueueScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueScalarWhereInput<
                      Input$WhatsappQueueScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$WhatsappQueueScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueScalarWhereInput<
                      Input$WhatsappQueueScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
}

class _CopyWithImpl$Input$WhatsappQueueScalarWhereInput<TRes>
    implements CopyWith$Input$WhatsappQueueScalarWhereInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueScalarWhereInput _instance;

  final TRes Function(Input$WhatsappQueueScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
  }) =>
      _then(Input$WhatsappQueueScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$WhatsappQueueScalarWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$WhatsappQueueScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$WhatsappQueueScalarWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
      }));
  TRes AND(
          Iterable<Input$WhatsappQueueScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueScalarWhereInput<
                          Input$WhatsappQueueScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$WhatsappQueueScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$WhatsappQueueScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueScalarWhereInput<
                          Input$WhatsappQueueScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$WhatsappQueueScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$WhatsappQueueScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueScalarWhereInput<
                          Input$WhatsappQueueScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$WhatsappQueueScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueScalarWhereInput<TRes>
    implements CopyWith$Input$WhatsappQueueScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$WhatsappQueueScalarWhereInput>? AND,
    List<Input$WhatsappQueueScalarWhereInput>? OR,
    List<Input$WhatsappQueueScalarWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
}

class Input$WhatsappQueueSumAggregateInput {
  factory Input$WhatsappQueueSumAggregateInput({bool? id}) =>
      Input$WhatsappQueueSumAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$WhatsappQueueSumAggregateInput._(this._$data);

  factory Input$WhatsappQueueSumAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as bool?);
    }
    return Input$WhatsappQueueSumAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get id => (_$data['id'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueSumAggregateInput<
          Input$WhatsappQueueSumAggregateInput>
      get copyWith => CopyWith$Input$WhatsappQueueSumAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueSumAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$WhatsappQueueSumAggregateInput<TRes> {
  factory CopyWith$Input$WhatsappQueueSumAggregateInput(
    Input$WhatsappQueueSumAggregateInput instance,
    TRes Function(Input$WhatsappQueueSumAggregateInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueSumAggregateInput;

  factory CopyWith$Input$WhatsappQueueSumAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueSumAggregateInput;

  TRes call({bool? id});
}

class _CopyWithImpl$Input$WhatsappQueueSumAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueSumAggregateInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueSumAggregateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueSumAggregateInput _instance;

  final TRes Function(Input$WhatsappQueueSumAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$WhatsappQueueSumAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as bool?),
      }));
}

class _CopyWithStubImpl$Input$WhatsappQueueSumAggregateInput<TRes>
    implements CopyWith$Input$WhatsappQueueSumAggregateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueSumAggregateInput(this._res);

  TRes _res;

  call({bool? id}) => _res;
}

class Input$WhatsappQueueUpdateInput {
  factory Input$WhatsappQueueUpdateInput({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput? guest,
  }) =>
      Input$WhatsappQueueUpdateInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guest != null) r'guest': guest,
      });

  Input$WhatsappQueueUpdateInput._(this._$data);

  factory Input$WhatsappQueueUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput
              .fromJson((l$guest as Map<String, dynamic>));
    }
    return Input$WhatsappQueueUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput? get guest =>
      (_$data['guest']
          as Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueUpdateInput<Input$WhatsappQueueUpdateInput>
      get copyWith => CopyWith$Input$WhatsappQueueUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueUpdateInput<TRes> {
  factory CopyWith$Input$WhatsappQueueUpdateInput(
    Input$WhatsappQueueUpdateInput instance,
    TRes Function(Input$WhatsappQueueUpdateInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueUpdateInput;

  factory CopyWith$Input$WhatsappQueueUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueUpdateInput;

  TRes call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput? guest,
  });
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
  CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<TRes>
      get guest;
}

class _CopyWithImpl$Input$WhatsappQueueUpdateInput<TRes>
    implements CopyWith$Input$WhatsappQueueUpdateInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueUpdateInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueUpdateInput _instance;

  final TRes Function(Input$WhatsappQueueUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappQueueUpdateInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
        if (guest != _undefined)
          'guest': (guest
              as Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput?),
      }));
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<TRes>
      get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueUpdateInput<TRes>
    implements CopyWith$Input$WhatsappQueueUpdateInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueUpdateInput(this._res);

  TRes _res;

  call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
    Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput? guest,
  }) =>
      _res;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput<TRes>
      get guest =>
          CopyWith$Input$GuestUpdateOneRequiredWithoutWhatsappQueueNestedInput
              .stub(_res);
}

class Input$WhatsappQueueUpdateManyMutationInput {
  factory Input$WhatsappQueueUpdateManyMutationInput({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      Input$WhatsappQueueUpdateManyMutationInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$WhatsappQueueUpdateManyMutationInput._(this._$data);

  factory Input$WhatsappQueueUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    return Input$WhatsappQueueUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueUpdateManyMutationInput<
          Input$WhatsappQueueUpdateManyMutationInput>
      get copyWith => CopyWith$Input$WhatsappQueueUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$WhatsappQueueUpdateManyMutationInput(
    Input$WhatsappQueueUpdateManyMutationInput instance,
    TRes Function(Input$WhatsappQueueUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueUpdateManyMutationInput;

  factory CopyWith$Input$WhatsappQueueUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueUpdateManyMutationInput;

  TRes call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  });
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
}

class _CopyWithImpl$Input$WhatsappQueueUpdateManyMutationInput<TRes>
    implements CopyWith$Input$WhatsappQueueUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueUpdateManyMutationInput _instance;

  final TRes Function(Input$WhatsappQueueUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$WhatsappQueueUpdateManyMutationInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueUpdateManyMutationInput<TRes>
    implements CopyWith$Input$WhatsappQueueUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      _res;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
}

class Input$WhatsappQueueUpdateManyWithoutGuestNestedInput {
  factory Input$WhatsappQueueUpdateManyWithoutGuestNestedInput({
    List<Input$WhatsappQueueCreateWithoutGuestInput>? create,
    List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$WhatsappQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappQueueWhereUniqueInput>? $set,
    List<Input$WhatsappQueueWhereUniqueInput>? disconnect,
    List<Input$WhatsappQueueWhereUniqueInput>? delete,
    List<Input$WhatsappQueueWhereUniqueInput>? connect,
    List<Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$WhatsappQueueScalarWhereInput>? deleteMany,
  }) =>
      Input$WhatsappQueueUpdateManyWithoutGuestNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (createMany != null) r'createMany': createMany,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$WhatsappQueueUpdateManyWithoutGuestNestedInput._(this._$data);

  factory Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueCreateWithoutGuestInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$WhatsappQueueCreateOrConnectWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createMany')) {
      final l$createMany = data['createMany'];
      result$data['createMany'] = l$createMany == null
          ? null
          : Input$WhatsappQueueCreateManyGuestInputEnvelope.fromJson(
              (l$createMany as Map<String, dynamic>));
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$WhatsappQueueUpdateManyWithoutGuestNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappQueueCreateWithoutGuestInput>? get create =>
      (_$data['create'] as List<Input$WhatsappQueueCreateWithoutGuestInput>?);
  List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>?);
  List<Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>? get upsert =>
      (_$data['upsert']
          as List<Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>?);
  Input$WhatsappQueueCreateManyGuestInputEnvelope? get createMany =>
      (_$data['createMany']
          as Input$WhatsappQueueCreateManyGuestInputEnvelope?);
  List<Input$WhatsappQueueWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$WhatsappQueueWhereUniqueInput>?);
  List<Input$WhatsappQueueWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$WhatsappQueueWhereUniqueInput>?);
  List<Input$WhatsappQueueWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$WhatsappQueueWhereUniqueInput>?);
  List<Input$WhatsappQueueWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$WhatsappQueueWhereUniqueInput>?);
  List<Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>? get update =>
      (_$data['update']
          as List<Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>?);
  List<Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>?
      get updateMany => (_$data['updateMany']
          as List<Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>?);
  List<Input$WhatsappQueueScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$WhatsappQueueScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createMany')) {
      final l$createMany = createMany;
      result$data['createMany'] = l$createMany?.toJson();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<
          Input$WhatsappQueueUpdateManyWithoutGuestNestedInput>
      get copyWith =>
          CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueUpdateManyWithoutGuestNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$createMany = createMany;
    final lOther$createMany = other.createMany;
    if (_$data.containsKey('createMany') !=
        other._$data.containsKey('createMany')) {
      return false;
    }
    if (l$createMany != lOther$createMany) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$createMany = createMany;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('createMany') ? l$createMany : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<
    TRes> {
  factory CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput(
    Input$WhatsappQueueUpdateManyWithoutGuestNestedInput instance,
    TRes Function(Input$WhatsappQueueUpdateManyWithoutGuestNestedInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput;

  factory CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput;

  TRes call({
    List<Input$WhatsappQueueCreateWithoutGuestInput>? create,
    List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$WhatsappQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappQueueWhereUniqueInput>? $set,
    List<Input$WhatsappQueueWhereUniqueInput>? disconnect,
    List<Input$WhatsappQueueWhereUniqueInput>? delete,
    List<Input$WhatsappQueueWhereUniqueInput>? connect,
    List<Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$WhatsappQueueScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$WhatsappQueueCreateWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<
                      Input$WhatsappQueueCreateWithoutGuestInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<
                      Input$WhatsappQueueCreateOrConnectWithoutGuestInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput<
                      Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>>?)
          _fn);
  CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes> get createMany;
  TRes $set(
      Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereUniqueInput<
                      Input$WhatsappQueueWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereUniqueInput<
                      Input$WhatsappQueueWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereUniqueInput<
                      Input$WhatsappQueueWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereUniqueInput<
                      Input$WhatsappQueueWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput<
                      Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput<
                      Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$WhatsappQueueScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueScalarWhereInput<
                      Input$WhatsappQueueScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes>
    implements
        CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueUpdateManyWithoutGuestNestedInput _instance;

  final TRes Function(Input$WhatsappQueueUpdateManyWithoutGuestNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? createMany = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$WhatsappQueueUpdateManyWithoutGuestNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$WhatsappQueueCreateWithoutGuestInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>?),
        if (createMany != _undefined)
          'createMany':
              (createMany as Input$WhatsappQueueCreateManyGuestInputEnvelope?),
        if ($set != _undefined)
          'set': ($set as List<Input$WhatsappQueueWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$WhatsappQueueWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$WhatsappQueueWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$WhatsappQueueWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$WhatsappQueueScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$WhatsappQueueCreateWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<
                          Input$WhatsappQueueCreateWithoutGuestInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$WhatsappQueueCreateWithoutGuestInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput<
                          Input$WhatsappQueueCreateOrConnectWithoutGuestInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$WhatsappQueueCreateOrConnectWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput<
                          Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes>
      get createMany {
    final local$createMany = _instance.createMany;
    return local$createMany == null
        ? CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope.stub(
            _then(_instance))
        : CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope(
            local$createMany, (e) => call(createMany: e));
  }

  TRes $set(
          Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereUniqueInput<
                          Input$WhatsappQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$WhatsappQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereUniqueInput<
                          Input$WhatsappQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$WhatsappQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereUniqueInput<
                          Input$WhatsappQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$WhatsappQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$WhatsappQueueWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereUniqueInput<
                          Input$WhatsappQueueWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$WhatsappQueueWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput<
                          Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput<
                          Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$WhatsappQueueScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueScalarWhereInput<
                          Input$WhatsappQueueScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$WhatsappQueueScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueUpdateManyWithoutGuestNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$WhatsappQueueCreateWithoutGuestInput>? create,
    List<Input$WhatsappQueueCreateOrConnectWithoutGuestInput>? connectOrCreate,
    List<Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>? upsert,
    Input$WhatsappQueueCreateManyGuestInputEnvelope? createMany,
    List<Input$WhatsappQueueWhereUniqueInput>? $set,
    List<Input$WhatsappQueueWhereUniqueInput>? disconnect,
    List<Input$WhatsappQueueWhereUniqueInput>? delete,
    List<Input$WhatsappQueueWhereUniqueInput>? connect,
    List<Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>? update,
    List<Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>? updateMany,
    List<Input$WhatsappQueueScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope<TRes>
      get createMany =>
          CopyWith$Input$WhatsappQueueCreateManyGuestInputEnvelope.stub(_res);
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput {
  factory Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput({
    required Input$WhatsappQueueScalarWhereInput where,
    required Input$WhatsappQueueUpdateManyMutationInput data,
  }) =>
      Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput._({
        r'where': where,
        r'data': data,
      });

  Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput._(this._$data);

  factory Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$WhatsappQueueScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$WhatsappQueueUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappQueueScalarWhereInput get where =>
      (_$data['where'] as Input$WhatsappQueueScalarWhereInput);
  Input$WhatsappQueueUpdateManyMutationInput get data =>
      (_$data['data'] as Input$WhatsappQueueUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput<
          Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput(
    Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput instance,
    TRes Function(Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput;

  factory CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput;

  TRes call({
    Input$WhatsappQueueScalarWhereInput? where,
    Input$WhatsappQueueUpdateManyMutationInput? data,
  });
  CopyWith$Input$WhatsappQueueScalarWhereInput<TRes> get where;
  CopyWith$Input$WhatsappQueueUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$WhatsappQueueScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$WhatsappQueueUpdateManyMutationInput),
      }));
  CopyWith$Input$WhatsappQueueScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$WhatsappQueueScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$WhatsappQueueUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$WhatsappQueueUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueUpdateManyWithWhereWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$WhatsappQueueScalarWhereInput? where,
    Input$WhatsappQueueUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$WhatsappQueueScalarWhereInput<TRes> get where =>
      CopyWith$Input$WhatsappQueueScalarWhereInput.stub(_res);
  CopyWith$Input$WhatsappQueueUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$WhatsappQueueUpdateManyMutationInput.stub(_res);
}

class Input$WhatsappQueueUpdateWithoutGuestInput {
  factory Input$WhatsappQueueUpdateWithoutGuestInput({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      Input$WhatsappQueueUpdateWithoutGuestInput._({
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
      });

  Input$WhatsappQueueUpdateWithoutGuestInput._(this._$data);

  factory Input$WhatsappQueueUpdateWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFieldUpdateOperationsInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    return Input$WhatsappQueueUpdateWithoutGuestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$DateTimeFieldUpdateOperationsInput? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$EnumQueueStatusFieldUpdateOperationsInput? get status =>
      (_$data['status'] as Input$EnumQueueStatusFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<
          Input$WhatsappQueueUpdateWithoutGuestInput>
      get copyWith => CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueUpdateWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$createdAt = createdAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> {
  factory CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput(
    Input$WhatsappQueueUpdateWithoutGuestInput instance,
    TRes Function(Input$WhatsappQueueUpdateWithoutGuestInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueUpdateWithoutGuestInput;

  factory CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueUpdateWithoutGuestInput;

  TRes call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  });
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status;
}

class _CopyWithImpl$Input$WhatsappQueueUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueUpdateWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueUpdateWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappQueueUpdateWithoutGuestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? createdAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$WhatsappQueueUpdateWithoutGuestInput._({
        ..._instance._$data,
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFieldUpdateOperationsInput?),
        if (status != _undefined)
          'status':
              (status as Input$EnumQueueStatusFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueUpdateWithoutGuestInput<TRes>
    implements CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueUpdateWithoutGuestInput(this._res);

  TRes _res;

  call({
    Input$DateTimeFieldUpdateOperationsInput? createdAt,
    Input$EnumQueueStatusFieldUpdateOperationsInput? status,
  }) =>
      _res;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get createdAt =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFieldUpdateOperationsInput.stub(_res);
}

class Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput {
  factory Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput({
    required Input$WhatsappQueueWhereUniqueInput where,
    required Input$WhatsappQueueUpdateWithoutGuestInput data,
  }) =>
      Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput._({
        r'where': where,
        r'data': data,
      });

  Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput._(this._$data);

  factory Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$WhatsappQueueWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$WhatsappQueueUpdateWithoutGuestInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappQueueWhereUniqueInput get where =>
      (_$data['where'] as Input$WhatsappQueueWhereUniqueInput);
  Input$WhatsappQueueUpdateWithoutGuestInput get data =>
      (_$data['data'] as Input$WhatsappQueueUpdateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput<
          Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput(
    Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput instance,
    TRes Function(Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput)
        then,
  ) = _CopyWithImpl$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput;

  factory CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput;

  TRes call({
    Input$WhatsappQueueWhereUniqueInput? where,
    Input$WhatsappQueueUpdateWithoutGuestInput? data,
  });
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where;
  CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> get data;
}

class _CopyWithImpl$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput<
            TRes> {
  _CopyWithImpl$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$WhatsappQueueWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$WhatsappQueueUpdateWithoutGuestInput),
      }));
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$WhatsappQueueWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput<
            TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueUpdateWithWhereUniqueWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$WhatsappQueueWhereUniqueInput? where,
    Input$WhatsappQueueUpdateWithoutGuestInput? data,
  }) =>
      _res;
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where =>
      CopyWith$Input$WhatsappQueueWhereUniqueInput.stub(_res);
  CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> get data =>
      CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput.stub(_res);
}

class Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput {
  factory Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput({
    required Input$WhatsappQueueWhereUniqueInput where,
    required Input$WhatsappQueueUpdateWithoutGuestInput update,
    required Input$WhatsappQueueCreateWithoutGuestInput create,
  }) =>
      Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput._(this._$data);

  factory Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$WhatsappQueueWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$WhatsappQueueUpdateWithoutGuestInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$WhatsappQueueCreateWithoutGuestInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$WhatsappQueueWhereUniqueInput get where =>
      (_$data['where'] as Input$WhatsappQueueWhereUniqueInput);
  Input$WhatsappQueueUpdateWithoutGuestInput get update =>
      (_$data['update'] as Input$WhatsappQueueUpdateWithoutGuestInput);
  Input$WhatsappQueueCreateWithoutGuestInput get create =>
      (_$data['create'] as Input$WhatsappQueueCreateWithoutGuestInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput<
          Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput>
      get copyWith =>
          CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput<
    TRes> {
  factory CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput(
    Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput instance,
    TRes Function(Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput)
        then,
  ) = _CopyWithImpl$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput;

  factory CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput;

  TRes call({
    Input$WhatsappQueueWhereUniqueInput? where,
    Input$WhatsappQueueUpdateWithoutGuestInput? update,
    Input$WhatsappQueueCreateWithoutGuestInput? create,
  });
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where;
  CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> get update;
  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> get create;
}

class _CopyWithImpl$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput<
            TRes> {
  _CopyWithImpl$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput _instance;

  final TRes Function(Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$WhatsappQueueWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$WhatsappQueueUpdateWithoutGuestInput),
        if (create != _undefined && create != null)
          'create': (create as Input$WhatsappQueueCreateWithoutGuestInput),
      }));
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$WhatsappQueueWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$WhatsappQueueCreateWithoutGuestInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput<
        TRes>
    implements
        CopyWith$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput<
            TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueUpsertWithWhereUniqueWithoutGuestInput(
      this._res);

  TRes _res;

  call({
    Input$WhatsappQueueWhereUniqueInput? where,
    Input$WhatsappQueueUpdateWithoutGuestInput? update,
    Input$WhatsappQueueCreateWithoutGuestInput? create,
  }) =>
      _res;
  CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> get where =>
      CopyWith$Input$WhatsappQueueWhereUniqueInput.stub(_res);
  CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput<TRes> get update =>
      CopyWith$Input$WhatsappQueueUpdateWithoutGuestInput.stub(_res);
  CopyWith$Input$WhatsappQueueCreateWithoutGuestInput<TRes> get create =>
      CopyWith$Input$WhatsappQueueCreateWithoutGuestInput.stub(_res);
}

class Input$WhatsappQueueWhereInput {
  factory Input$WhatsappQueueWhereInput({
    List<Input$WhatsappQueueWhereInput>? AND,
    List<Input$WhatsappQueueWhereInput>? OR,
    List<Input$WhatsappQueueWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      Input$WhatsappQueueWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$WhatsappQueueWhereInput._(this._$data);

  factory Input$WhatsappQueueWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$WhatsappQueueWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$WhatsappQueueWhereInput>? get AND =>
      (_$data['AND'] as List<Input$WhatsappQueueWhereInput>?);
  List<Input$WhatsappQueueWhereInput>? get OR =>
      (_$data['OR'] as List<Input$WhatsappQueueWhereInput>?);
  List<Input$WhatsappQueueWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$WhatsappQueueWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueWhereInput<Input$WhatsappQueueWhereInput>
      get copyWith => CopyWith$Input$WhatsappQueueWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueWhereInput<TRes> {
  factory CopyWith$Input$WhatsappQueueWhereInput(
    Input$WhatsappQueueWhereInput instance,
    TRes Function(Input$WhatsappQueueWhereInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueWhereInput;

  factory CopyWith$Input$WhatsappQueueWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueWhereInput;

  TRes call({
    List<Input$WhatsappQueueWhereInput>? AND,
    List<Input$WhatsappQueueWhereInput>? OR,
    List<Input$WhatsappQueueWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  });
  TRes AND(
      Iterable<Input$WhatsappQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereInput<
                      Input$WhatsappQueueWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$WhatsappQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereInput<
                      Input$WhatsappQueueWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$WhatsappQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereInput<
                      Input$WhatsappQueueWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
}

class _CopyWithImpl$Input$WhatsappQueueWhereInput<TRes>
    implements CopyWith$Input$WhatsappQueueWhereInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueWhereInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueWhereInput _instance;

  final TRes Function(Input$WhatsappQueueWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappQueueWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$WhatsappQueueWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$WhatsappQueueWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$WhatsappQueueWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$WhatsappQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereInput<
                          Input$WhatsappQueueWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$WhatsappQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$WhatsappQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereInput<
                          Input$WhatsappQueueWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$WhatsappQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$WhatsappQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereInput<
                          Input$WhatsappQueueWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$WhatsappQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueWhereInput<TRes>
    implements CopyWith$Input$WhatsappQueueWhereInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueWhereInput(this._res);

  TRes _res;

  call({
    List<Input$WhatsappQueueWhereInput>? AND,
    List<Input$WhatsappQueueWhereInput>? OR,
    List<Input$WhatsappQueueWhereInput>? NOT,
    Input$IntFilter? id,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
}

class Input$WhatsappQueueWhereUniqueInput {
  factory Input$WhatsappQueueWhereUniqueInput({
    int? id,
    List<Input$WhatsappQueueWhereInput>? AND,
    List<Input$WhatsappQueueWhereInput>? OR,
    List<Input$WhatsappQueueWhereInput>? NOT,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      Input$WhatsappQueueWhereUniqueInput._({
        if (id != null) r'id': id,
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (createdAt != null) r'createdAt': createdAt,
        if (status != null) r'status': status,
        if (guestId != null) r'guestId': guestId,
        if (guest != null) r'guest': guest,
      });

  Input$WhatsappQueueWhereUniqueInput._(this._$data);

  factory Input$WhatsappQueueWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$WhatsappQueueWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('createdAt')) {
      final l$createdAt = data['createdAt'];
      result$data['createdAt'] = l$createdAt == null
          ? null
          : Input$DateTimeFilter.fromJson(
              (l$createdAt as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$EnumQueueStatusFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('guestId')) {
      final l$guestId = data['guestId'];
      result$data['guestId'] = l$guestId == null
          ? null
          : Input$StringFilter.fromJson((l$guestId as Map<String, dynamic>));
    }
    if (data.containsKey('guest')) {
      final l$guest = data['guest'];
      result$data['guest'] = l$guest == null
          ? null
          : Input$GuestRelationFilter.fromJson(
              (l$guest as Map<String, dynamic>));
    }
    return Input$WhatsappQueueWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  List<Input$WhatsappQueueWhereInput>? get AND =>
      (_$data['AND'] as List<Input$WhatsappQueueWhereInput>?);
  List<Input$WhatsappQueueWhereInput>? get OR =>
      (_$data['OR'] as List<Input$WhatsappQueueWhereInput>?);
  List<Input$WhatsappQueueWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$WhatsappQueueWhereInput>?);
  Input$DateTimeFilter? get createdAt =>
      (_$data['createdAt'] as Input$DateTimeFilter?);
  Input$EnumQueueStatusFilter? get status =>
      (_$data['status'] as Input$EnumQueueStatusFilter?);
  Input$StringFilter? get guestId => (_$data['guestId'] as Input$StringFilter?);
  Input$GuestRelationFilter? get guest =>
      (_$data['guest'] as Input$GuestRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('createdAt')) {
      final l$createdAt = createdAt;
      result$data['createdAt'] = l$createdAt?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('guestId')) {
      final l$guestId = guestId;
      result$data['guestId'] = l$guestId?.toJson();
    }
    if (_$data.containsKey('guest')) {
      final l$guest = guest;
      result$data['guest'] = l$guest?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$WhatsappQueueWhereUniqueInput<
          Input$WhatsappQueueWhereUniqueInput>
      get copyWith => CopyWith$Input$WhatsappQueueWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WhatsappQueueWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$createdAt = createdAt;
    final lOther$createdAt = other.createdAt;
    if (_$data.containsKey('createdAt') !=
        other._$data.containsKey('createdAt')) {
      return false;
    }
    if (l$createdAt != lOther$createdAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$guestId = guestId;
    final lOther$guestId = other.guestId;
    if (_$data.containsKey('guestId') != other._$data.containsKey('guestId')) {
      return false;
    }
    if (l$guestId != lOther$guestId) {
      return false;
    }
    final l$guest = guest;
    final lOther$guest = other.guest;
    if (_$data.containsKey('guest') != other._$data.containsKey('guest')) {
      return false;
    }
    if (l$guest != lOther$guest) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$createdAt = createdAt;
    final l$status = status;
    final l$guestId = guestId;
    final l$guest = guest;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('createdAt') ? l$createdAt : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('guestId') ? l$guestId : const {},
      _$data.containsKey('guest') ? l$guest : const {},
    ]);
  }
}

abstract class CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> {
  factory CopyWith$Input$WhatsappQueueWhereUniqueInput(
    Input$WhatsappQueueWhereUniqueInput instance,
    TRes Function(Input$WhatsappQueueWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$WhatsappQueueWhereUniqueInput;

  factory CopyWith$Input$WhatsappQueueWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$WhatsappQueueWhereUniqueInput;

  TRes call({
    int? id,
    List<Input$WhatsappQueueWhereInput>? AND,
    List<Input$WhatsappQueueWhereInput>? OR,
    List<Input$WhatsappQueueWhereInput>? NOT,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  });
  TRes AND(
      Iterable<Input$WhatsappQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereInput<
                      Input$WhatsappQueueWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$WhatsappQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereInput<
                      Input$WhatsappQueueWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$WhatsappQueueWhereInput>? Function(
              Iterable<
                  CopyWith$Input$WhatsappQueueWhereInput<
                      Input$WhatsappQueueWhereInput>>?)
          _fn);
  CopyWith$Input$DateTimeFilter<TRes> get createdAt;
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status;
  CopyWith$Input$StringFilter<TRes> get guestId;
  CopyWith$Input$GuestRelationFilter<TRes> get guest;
}

class _CopyWithImpl$Input$WhatsappQueueWhereUniqueInput<TRes>
    implements CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$WhatsappQueueWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$WhatsappQueueWhereUniqueInput _instance;

  final TRes Function(Input$WhatsappQueueWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? createdAt = _undefined,
    Object? status = _undefined,
    Object? guestId = _undefined,
    Object? guest = _undefined,
  }) =>
      _then(Input$WhatsappQueueWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
        if (AND != _undefined)
          'AND': (AND as List<Input$WhatsappQueueWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$WhatsappQueueWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$WhatsappQueueWhereInput>?),
        if (createdAt != _undefined)
          'createdAt': (createdAt as Input$DateTimeFilter?),
        if (status != _undefined)
          'status': (status as Input$EnumQueueStatusFilter?),
        if (guestId != _undefined) 'guestId': (guestId as Input$StringFilter?),
        if (guest != _undefined) 'guest': (guest as Input$GuestRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$WhatsappQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereInput<
                          Input$WhatsappQueueWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$WhatsappQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$WhatsappQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereInput<
                          Input$WhatsappQueueWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$WhatsappQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$WhatsappQueueWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$WhatsappQueueWhereInput<
                          Input$WhatsappQueueWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$WhatsappQueueWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$DateTimeFilter<TRes> get createdAt {
    final local$createdAt = _instance.createdAt;
    return local$createdAt == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(
            local$createdAt, (e) => call(createdAt: e));
  }

  CopyWith$Input$EnumQueueStatusFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$EnumQueueStatusFilter.stub(_then(_instance))
        : CopyWith$Input$EnumQueueStatusFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$StringFilter<TRes> get guestId {
    final local$guestId = _instance.guestId;
    return local$guestId == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$guestId, (e) => call(guestId: e));
  }

  CopyWith$Input$GuestRelationFilter<TRes> get guest {
    final local$guest = _instance.guest;
    return local$guest == null
        ? CopyWith$Input$GuestRelationFilter.stub(_then(_instance))
        : CopyWith$Input$GuestRelationFilter(
            local$guest, (e) => call(guest: e));
  }
}

class _CopyWithStubImpl$Input$WhatsappQueueWhereUniqueInput<TRes>
    implements CopyWith$Input$WhatsappQueueWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$WhatsappQueueWhereUniqueInput(this._res);

  TRes _res;

  call({
    int? id,
    List<Input$WhatsappQueueWhereInput>? AND,
    List<Input$WhatsappQueueWhereInput>? OR,
    List<Input$WhatsappQueueWhereInput>? NOT,
    Input$DateTimeFilter? createdAt,
    Input$EnumQueueStatusFilter? status,
    Input$StringFilter? guestId,
    Input$GuestRelationFilter? guest,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$DateTimeFilter<TRes> get createdAt =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$EnumQueueStatusFilter<TRes> get status =>
      CopyWith$Input$EnumQueueStatusFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get guestId =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$GuestRelationFilter<TRes> get guest =>
      CopyWith$Input$GuestRelationFilter.stub(_res);
}

enum Enum$ConfirmationStatus { UNCONFIRMED, CONFIRMED, REJECTED, $unknown }

String toJson$Enum$ConfirmationStatus(Enum$ConfirmationStatus e) {
  switch (e) {
    case Enum$ConfirmationStatus.UNCONFIRMED:
      return r'UNCONFIRMED';
    case Enum$ConfirmationStatus.CONFIRMED:
      return r'CONFIRMED';
    case Enum$ConfirmationStatus.REJECTED:
      return r'REJECTED';
    case Enum$ConfirmationStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ConfirmationStatus fromJson$Enum$ConfirmationStatus(String value) {
  switch (value) {
    case r'UNCONFIRMED':
      return Enum$ConfirmationStatus.UNCONFIRMED;
    case r'CONFIRMED':
      return Enum$ConfirmationStatus.CONFIRMED;
    case r'REJECTED':
      return Enum$ConfirmationStatus.REJECTED;
    default:
      return Enum$ConfirmationStatus.$unknown;
  }
}

enum Enum$EmailQueueScalarFieldEnum { id, createdAt, status, guestId, $unknown }

String toJson$Enum$EmailQueueScalarFieldEnum(Enum$EmailQueueScalarFieldEnum e) {
  switch (e) {
    case Enum$EmailQueueScalarFieldEnum.id:
      return r'id';
    case Enum$EmailQueueScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$EmailQueueScalarFieldEnum.status:
      return r'status';
    case Enum$EmailQueueScalarFieldEnum.guestId:
      return r'guestId';
    case Enum$EmailQueueScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$EmailQueueScalarFieldEnum fromJson$Enum$EmailQueueScalarFieldEnum(
    String value) {
  switch (value) {
    case r'id':
      return Enum$EmailQueueScalarFieldEnum.id;
    case r'createdAt':
      return Enum$EmailQueueScalarFieldEnum.createdAt;
    case r'status':
      return Enum$EmailQueueScalarFieldEnum.status;
    case r'guestId':
      return Enum$EmailQueueScalarFieldEnum.guestId;
    default:
      return Enum$EmailQueueScalarFieldEnum.$unknown;
  }
}

enum Enum$GuestScalarFieldEnum {
  userId,
  category1,
  category2,
  personInCharge,
  $class,
  seat,
  rejectionReason,
  description,
  parties,
  confirmationStatus,
  $unknown
}

String toJson$Enum$GuestScalarFieldEnum(Enum$GuestScalarFieldEnum e) {
  switch (e) {
    case Enum$GuestScalarFieldEnum.userId:
      return r'userId';
    case Enum$GuestScalarFieldEnum.category1:
      return r'category1';
    case Enum$GuestScalarFieldEnum.category2:
      return r'category2';
    case Enum$GuestScalarFieldEnum.personInCharge:
      return r'personInCharge';
    case Enum$GuestScalarFieldEnum.$class:
      return r'class';
    case Enum$GuestScalarFieldEnum.seat:
      return r'seat';
    case Enum$GuestScalarFieldEnum.rejectionReason:
      return r'rejectionReason';
    case Enum$GuestScalarFieldEnum.description:
      return r'description';
    case Enum$GuestScalarFieldEnum.parties:
      return r'parties';
    case Enum$GuestScalarFieldEnum.confirmationStatus:
      return r'confirmationStatus';
    case Enum$GuestScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$GuestScalarFieldEnum fromJson$Enum$GuestScalarFieldEnum(String value) {
  switch (value) {
    case r'userId':
      return Enum$GuestScalarFieldEnum.userId;
    case r'category1':
      return Enum$GuestScalarFieldEnum.category1;
    case r'category2':
      return Enum$GuestScalarFieldEnum.category2;
    case r'personInCharge':
      return Enum$GuestScalarFieldEnum.personInCharge;
    case r'class':
      return Enum$GuestScalarFieldEnum.$class;
    case r'seat':
      return Enum$GuestScalarFieldEnum.seat;
    case r'rejectionReason':
      return Enum$GuestScalarFieldEnum.rejectionReason;
    case r'description':
      return Enum$GuestScalarFieldEnum.description;
    case r'parties':
      return Enum$GuestScalarFieldEnum.parties;
    case r'confirmationStatus':
      return Enum$GuestScalarFieldEnum.confirmationStatus;
    default:
      return Enum$GuestScalarFieldEnum.$unknown;
  }
}

enum Enum$NullsOrder { first, last, $unknown }

String toJson$Enum$NullsOrder(Enum$NullsOrder e) {
  switch (e) {
    case Enum$NullsOrder.first:
      return r'first';
    case Enum$NullsOrder.last:
      return r'last';
    case Enum$NullsOrder.$unknown:
      return r'$unknown';
  }
}

Enum$NullsOrder fromJson$Enum$NullsOrder(String value) {
  switch (value) {
    case r'first':
      return Enum$NullsOrder.first;
    case r'last':
      return Enum$NullsOrder.last;
    default:
      return Enum$NullsOrder.$unknown;
  }
}

enum Enum$QueueStatus { WAITING, SENDING, SENT, FAILED, $unknown }

String toJson$Enum$QueueStatus(Enum$QueueStatus e) {
  switch (e) {
    case Enum$QueueStatus.WAITING:
      return r'WAITING';
    case Enum$QueueStatus.SENDING:
      return r'SENDING';
    case Enum$QueueStatus.SENT:
      return r'SENT';
    case Enum$QueueStatus.FAILED:
      return r'FAILED';
    case Enum$QueueStatus.$unknown:
      return r'$unknown';
  }
}

Enum$QueueStatus fromJson$Enum$QueueStatus(String value) {
  switch (value) {
    case r'WAITING':
      return Enum$QueueStatus.WAITING;
    case r'SENDING':
      return Enum$QueueStatus.SENDING;
    case r'SENT':
      return Enum$QueueStatus.SENT;
    case r'FAILED':
      return Enum$QueueStatus.FAILED;
    default:
      return Enum$QueueStatus.$unknown;
  }
}

enum Enum$RatioEnum {
  SQUARE,
  MODERN,
  MODERN_PORTRAIT,
  OLD,
  OLD_PORTRAIT,
  BANNER,
  ULTRA_WIDE,
  SUPER_WIDE,
  $unknown
}

String toJson$Enum$RatioEnum(Enum$RatioEnum e) {
  switch (e) {
    case Enum$RatioEnum.SQUARE:
      return r'SQUARE';
    case Enum$RatioEnum.MODERN:
      return r'MODERN';
    case Enum$RatioEnum.MODERN_PORTRAIT:
      return r'MODERN_PORTRAIT';
    case Enum$RatioEnum.OLD:
      return r'OLD';
    case Enum$RatioEnum.OLD_PORTRAIT:
      return r'OLD_PORTRAIT';
    case Enum$RatioEnum.BANNER:
      return r'BANNER';
    case Enum$RatioEnum.ULTRA_WIDE:
      return r'ULTRA_WIDE';
    case Enum$RatioEnum.SUPER_WIDE:
      return r'SUPER_WIDE';
    case Enum$RatioEnum.$unknown:
      return r'$unknown';
  }
}

Enum$RatioEnum fromJson$Enum$RatioEnum(String value) {
  switch (value) {
    case r'SQUARE':
      return Enum$RatioEnum.SQUARE;
    case r'MODERN':
      return Enum$RatioEnum.MODERN;
    case r'MODERN_PORTRAIT':
      return Enum$RatioEnum.MODERN_PORTRAIT;
    case r'OLD':
      return Enum$RatioEnum.OLD;
    case r'OLD_PORTRAIT':
      return Enum$RatioEnum.OLD_PORTRAIT;
    case r'BANNER':
      return Enum$RatioEnum.BANNER;
    case r'ULTRA_WIDE':
      return Enum$RatioEnum.ULTRA_WIDE;
    case r'SUPER_WIDE':
      return Enum$RatioEnum.SUPER_WIDE;
    default:
      return Enum$RatioEnum.$unknown;
  }
}

enum Enum$SortOrder { asc, desc, $unknown }

String toJson$Enum$SortOrder(Enum$SortOrder e) {
  switch (e) {
    case Enum$SortOrder.asc:
      return r'asc';
    case Enum$SortOrder.desc:
      return r'desc';
    case Enum$SortOrder.$unknown:
      return r'$unknown';
  }
}

Enum$SortOrder fromJson$Enum$SortOrder(String value) {
  switch (value) {
    case r'asc':
      return Enum$SortOrder.asc;
    case r'desc':
      return Enum$SortOrder.desc;
    default:
      return Enum$SortOrder.$unknown;
  }
}

enum Enum$UserRole { ADMIN, SUPERUSER, GUEST, $unknown }

String toJson$Enum$UserRole(Enum$UserRole e) {
  switch (e) {
    case Enum$UserRole.ADMIN:
      return r'ADMIN';
    case Enum$UserRole.SUPERUSER:
      return r'SUPERUSER';
    case Enum$UserRole.GUEST:
      return r'GUEST';
    case Enum$UserRole.$unknown:
      return r'$unknown';
  }
}

Enum$UserRole fromJson$Enum$UserRole(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$UserRole.ADMIN;
    case r'SUPERUSER':
      return Enum$UserRole.SUPERUSER;
    case r'GUEST':
      return Enum$UserRole.GUEST;
    default:
      return Enum$UserRole.$unknown;
  }
}

enum Enum$UserScalarFieldEnum {
  id,
  fullName,
  email,
  password,
  whatsapp,
  createdAt,
  updatedAt,
  deletedAt,
  role,
  guestInfoId,
  $unknown
}

String toJson$Enum$UserScalarFieldEnum(Enum$UserScalarFieldEnum e) {
  switch (e) {
    case Enum$UserScalarFieldEnum.id:
      return r'id';
    case Enum$UserScalarFieldEnum.fullName:
      return r'fullName';
    case Enum$UserScalarFieldEnum.email:
      return r'email';
    case Enum$UserScalarFieldEnum.password:
      return r'password';
    case Enum$UserScalarFieldEnum.whatsapp:
      return r'whatsapp';
    case Enum$UserScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$UserScalarFieldEnum.updatedAt:
      return r'updatedAt';
    case Enum$UserScalarFieldEnum.deletedAt:
      return r'deletedAt';
    case Enum$UserScalarFieldEnum.role:
      return r'role';
    case Enum$UserScalarFieldEnum.guestInfoId:
      return r'guestInfoId';
    case Enum$UserScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$UserScalarFieldEnum fromJson$Enum$UserScalarFieldEnum(String value) {
  switch (value) {
    case r'id':
      return Enum$UserScalarFieldEnum.id;
    case r'fullName':
      return Enum$UserScalarFieldEnum.fullName;
    case r'email':
      return Enum$UserScalarFieldEnum.email;
    case r'password':
      return Enum$UserScalarFieldEnum.password;
    case r'whatsapp':
      return Enum$UserScalarFieldEnum.whatsapp;
    case r'createdAt':
      return Enum$UserScalarFieldEnum.createdAt;
    case r'updatedAt':
      return Enum$UserScalarFieldEnum.updatedAt;
    case r'deletedAt':
      return Enum$UserScalarFieldEnum.deletedAt;
    case r'role':
      return Enum$UserScalarFieldEnum.role;
    case r'guestInfoId':
      return Enum$UserScalarFieldEnum.guestInfoId;
    default:
      return Enum$UserScalarFieldEnum.$unknown;
  }
}

enum Enum$WhatsappQueueScalarFieldEnum {
  id,
  createdAt,
  status,
  guestId,
  $unknown
}

String toJson$Enum$WhatsappQueueScalarFieldEnum(
    Enum$WhatsappQueueScalarFieldEnum e) {
  switch (e) {
    case Enum$WhatsappQueueScalarFieldEnum.id:
      return r'id';
    case Enum$WhatsappQueueScalarFieldEnum.createdAt:
      return r'createdAt';
    case Enum$WhatsappQueueScalarFieldEnum.status:
      return r'status';
    case Enum$WhatsappQueueScalarFieldEnum.guestId:
      return r'guestId';
    case Enum$WhatsappQueueScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$WhatsappQueueScalarFieldEnum fromJson$Enum$WhatsappQueueScalarFieldEnum(
    String value) {
  switch (value) {
    case r'id':
      return Enum$WhatsappQueueScalarFieldEnum.id;
    case r'createdAt':
      return Enum$WhatsappQueueScalarFieldEnum.createdAt;
    case r'status':
      return Enum$WhatsappQueueScalarFieldEnum.status;
    case r'guestId':
      return Enum$WhatsappQueueScalarFieldEnum.guestId;
    default:
      return Enum$WhatsappQueueScalarFieldEnum.$unknown;
  }
}

enum Enum$__TypeKind {
  SCALAR,
  OBJECT,
  INTERFACE,
  UNION,
  ENUM,
  INPUT_OBJECT,
  LIST,
  NON_NULL,
  $unknown
}

String toJson$Enum$__TypeKind(Enum$__TypeKind e) {
  switch (e) {
    case Enum$__TypeKind.SCALAR:
      return r'SCALAR';
    case Enum$__TypeKind.OBJECT:
      return r'OBJECT';
    case Enum$__TypeKind.INTERFACE:
      return r'INTERFACE';
    case Enum$__TypeKind.UNION:
      return r'UNION';
    case Enum$__TypeKind.ENUM:
      return r'ENUM';
    case Enum$__TypeKind.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__TypeKind.LIST:
      return r'LIST';
    case Enum$__TypeKind.NON_NULL:
      return r'NON_NULL';
    case Enum$__TypeKind.$unknown:
      return r'$unknown';
  }
}

Enum$__TypeKind fromJson$Enum$__TypeKind(String value) {
  switch (value) {
    case r'SCALAR':
      return Enum$__TypeKind.SCALAR;
    case r'OBJECT':
      return Enum$__TypeKind.OBJECT;
    case r'INTERFACE':
      return Enum$__TypeKind.INTERFACE;
    case r'UNION':
      return Enum$__TypeKind.UNION;
    case r'ENUM':
      return Enum$__TypeKind.ENUM;
    case r'INPUT_OBJECT':
      return Enum$__TypeKind.INPUT_OBJECT;
    case r'LIST':
      return Enum$__TypeKind.LIST;
    case r'NON_NULL':
      return Enum$__TypeKind.NON_NULL;
    default:
      return Enum$__TypeKind.$unknown;
  }
}

enum Enum$__DirectiveLocation {
  QUERY,
  MUTATION,
  SUBSCRIPTION,
  FIELD,
  FRAGMENT_DEFINITION,
  FRAGMENT_SPREAD,
  INLINE_FRAGMENT,
  VARIABLE_DEFINITION,
  SCHEMA,
  SCALAR,
  OBJECT,
  FIELD_DEFINITION,
  ARGUMENT_DEFINITION,
  INTERFACE,
  UNION,
  ENUM,
  ENUM_VALUE,
  INPUT_OBJECT,
  INPUT_FIELD_DEFINITION,
  $unknown
}

String toJson$Enum$__DirectiveLocation(Enum$__DirectiveLocation e) {
  switch (e) {
    case Enum$__DirectiveLocation.QUERY:
      return r'QUERY';
    case Enum$__DirectiveLocation.MUTATION:
      return r'MUTATION';
    case Enum$__DirectiveLocation.SUBSCRIPTION:
      return r'SUBSCRIPTION';
    case Enum$__DirectiveLocation.FIELD:
      return r'FIELD';
    case Enum$__DirectiveLocation.FRAGMENT_DEFINITION:
      return r'FRAGMENT_DEFINITION';
    case Enum$__DirectiveLocation.FRAGMENT_SPREAD:
      return r'FRAGMENT_SPREAD';
    case Enum$__DirectiveLocation.INLINE_FRAGMENT:
      return r'INLINE_FRAGMENT';
    case Enum$__DirectiveLocation.VARIABLE_DEFINITION:
      return r'VARIABLE_DEFINITION';
    case Enum$__DirectiveLocation.SCHEMA:
      return r'SCHEMA';
    case Enum$__DirectiveLocation.SCALAR:
      return r'SCALAR';
    case Enum$__DirectiveLocation.OBJECT:
      return r'OBJECT';
    case Enum$__DirectiveLocation.FIELD_DEFINITION:
      return r'FIELD_DEFINITION';
    case Enum$__DirectiveLocation.ARGUMENT_DEFINITION:
      return r'ARGUMENT_DEFINITION';
    case Enum$__DirectiveLocation.INTERFACE:
      return r'INTERFACE';
    case Enum$__DirectiveLocation.UNION:
      return r'UNION';
    case Enum$__DirectiveLocation.ENUM:
      return r'ENUM';
    case Enum$__DirectiveLocation.ENUM_VALUE:
      return r'ENUM_VALUE';
    case Enum$__DirectiveLocation.INPUT_OBJECT:
      return r'INPUT_OBJECT';
    case Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION:
      return r'INPUT_FIELD_DEFINITION';
    case Enum$__DirectiveLocation.$unknown:
      return r'$unknown';
  }
}

Enum$__DirectiveLocation fromJson$Enum$__DirectiveLocation(String value) {
  switch (value) {
    case r'QUERY':
      return Enum$__DirectiveLocation.QUERY;
    case r'MUTATION':
      return Enum$__DirectiveLocation.MUTATION;
    case r'SUBSCRIPTION':
      return Enum$__DirectiveLocation.SUBSCRIPTION;
    case r'FIELD':
      return Enum$__DirectiveLocation.FIELD;
    case r'FRAGMENT_DEFINITION':
      return Enum$__DirectiveLocation.FRAGMENT_DEFINITION;
    case r'FRAGMENT_SPREAD':
      return Enum$__DirectiveLocation.FRAGMENT_SPREAD;
    case r'INLINE_FRAGMENT':
      return Enum$__DirectiveLocation.INLINE_FRAGMENT;
    case r'VARIABLE_DEFINITION':
      return Enum$__DirectiveLocation.VARIABLE_DEFINITION;
    case r'SCHEMA':
      return Enum$__DirectiveLocation.SCHEMA;
    case r'SCALAR':
      return Enum$__DirectiveLocation.SCALAR;
    case r'OBJECT':
      return Enum$__DirectiveLocation.OBJECT;
    case r'FIELD_DEFINITION':
      return Enum$__DirectiveLocation.FIELD_DEFINITION;
    case r'ARGUMENT_DEFINITION':
      return Enum$__DirectiveLocation.ARGUMENT_DEFINITION;
    case r'INTERFACE':
      return Enum$__DirectiveLocation.INTERFACE;
    case r'UNION':
      return Enum$__DirectiveLocation.UNION;
    case r'ENUM':
      return Enum$__DirectiveLocation.ENUM;
    case r'ENUM_VALUE':
      return Enum$__DirectiveLocation.ENUM_VALUE;
    case r'INPUT_OBJECT':
      return Enum$__DirectiveLocation.INPUT_OBJECT;
    case r'INPUT_FIELD_DEFINITION':
      return Enum$__DirectiveLocation.INPUT_FIELD_DEFINITION;
    default:
      return Enum$__DirectiveLocation.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{};
